<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++泛型编程 - Nico&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Nico&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Nico&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="泛型编程 如何实现一个通用的交换函数呢？  123456789101112131415161718void Swap(int&amp;amp; left, int&amp;amp; right)&amp;amp;#123;    int temp &amp;#x3D; left;    left &amp;#x3D; right;    right &amp;#x3D; temp;&amp;amp;#125;void Swap(double&amp;amp; left, double&amp;amp; right"><meta property="og:type" content="blog"><meta property="og:title" content="C++泛型编程"><meta property="og:url" content="http://icarus.xinsong.xyz/2023/01/12/C++/13.C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"><meta property="og:site_name" content="Nico&#039;s Blog"><meta property="og:description" content="泛型编程 如何实现一个通用的交换函数呢？  123456789101112131415161718void Swap(int&amp;amp; left, int&amp;amp; right)&amp;amp;#123;    int temp &amp;#x3D; left;    left &amp;#x3D; right;    right &amp;#x3D; temp;&amp;amp;#125;void Swap(double&amp;amp; left, double&amp;amp; right"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021631018.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632204.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632906.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632173.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632360.png"><meta property="article:published_time" content="2023-01-12T14:09:07.000Z"><meta property="article:modified_time" content="2023-01-13T03:37:19.962Z"><meta property="article:author" content="NcPhoton"><meta property="article:tag" content="cpp"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021631018.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icarus.xinsong.xyz/2023/01/12/C++/13.C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"},"headline":"C++泛型编程","image":["https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021631018.png","https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632204.png","https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632906.png","https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632173.png","https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632360.png"],"datePublished":"2023-01-12T14:09:07.000Z","dateModified":"2023-01-13T03:37:19.962Z","author":{"@type":"Person","name":"NcPhoton"},"publisher":{"@type":"Organization","name":"Nico's Blog","logo":{"@type":"ImageObject","url":"http://icarus.xinsong.xyz/img/logo.svg"}},"description":"泛型编程 如何实现一个通用的交换函数呢？  123456789101112131415161718void Swap(int&amp; left, int&amp; right)&amp;#123;    int temp &#x3D; left;    left &#x3D; right;    right &#x3D; temp;&amp;#125;void Swap(double&amp; left, double&amp; right"}</script><link rel="canonical" href="http://icarus.xinsong.xyz/2023/01/12/C++/13.C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Nico&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-12T14:09:07.000Z" title="2023/1/12 22:09:07">2023-01-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-13T03:37:19.962Z" title="2023/1/13 11:37:19">2023-01-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Cpp/">Cpp</a></span><span class="level-item">22 minutes read (About 3233 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">C++泛型编程</h1><div class="content"><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><blockquote>
<p>如何实现一个通用的交换函数呢？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; left, <span class="type">double</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">char</span>&amp; left, <span class="type">char</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++支持函数重载，因此无论是交换double类型还是int类型的变量的值，可以统一使用同一个函数名。</p>
<p>使用函数重载虽然可以实现，但是有以下几个不好的地方：</p>
<ol>
<li>重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。</li>
<li>代码的可维护性比较低，一个出错可能所有的重载均出错。</li>
</ol>
<p>很显然这些函数只有类型不同，那么我们能否写出一个模型，让编译器根据不同的类型利用模板来生成不同的函数呢？</p>
<span id="more"></span>

<p>就像下面的图一样，我们只需要制作模具，后面的事情就简单了许多。</p>
<img src="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021631018.png" alt="image-20220723160806842" style="zoom:67%;" />



<blockquote>
<p>如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多时间。巧的是前人早已将树栽好，我们只需在此乘凉。</p>
</blockquote>
<p><strong>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632204.png" alt="image-20220723160905311"></p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><blockquote>
<p>template&lt;typename T1, typename T2,……,typename Tn&gt;<br>return_type 函数名(参数列表){}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<strong>typename</strong>是用来定义<strong>模板参数关键字</strong>，也可以使用class(切记：不能使用struct代替class)</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>就像机器人一样，我们将重复简单的事情交给他去做，它可以代替我们完成这些，为我们节省了大量时间和精力。</p>
<p><strong>函数模板就是一个蓝图，它本身并不是一个函数，是编译器使用特定方式产生的具体类型函数的膜具，所以其实模板就是将本来应该我们做的重复的事情交给了编译器</strong>。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632906.png" alt="image-20220729103947049" style="zoom: 50%;" />

 

<blockquote>
<p>在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。</p>
<p>比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型及其他类型也是如此。</p>
</blockquote>
<h3 id="函数模板的实例化"><a href="#函数模板的实例化" class="headerlink" title="函数模板的实例化"></a>函数模板的实例化</h3><blockquote>
<p>用不同类型的参数使用函数模板时，称为函数模板的实例化，有两种方式：</p>
<ul>
<li><strong>隐式实例化</strong>：让编译器根据实参推演模板参数的实际类型；</li>
<li><strong>显式实例化</strong>：在函数名后的&lt;&gt;中指定模板参数的实际类型；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">10.0</span>, d2 = <span class="number">20.0</span>;</span><br><span class="line">    <span class="built_in">Add</span>(a1, a2);</span><br><span class="line">    <span class="built_in">Add</span>(d1, d2);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Add(a1, d1);</span></span><br><span class="line"><span class="comment">    该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型</span></span><br><span class="line"><span class="comment">    通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有</span></span><br><span class="line"><span class="comment">    一个T，</span></span><br><span class="line"><span class="comment">    编译器无法确定此处到底该将T确定为int 或者 double类型而报错</span></span><br><span class="line"><span class="comment">    注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化</span></span><br><span class="line">    <span class="built_in">Add</span>(a1, (<span class="type">int</span>)d1);</span><br><span class="line">    <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a1, d1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板函数的隐式实例化不允许自动类型转换（只能按照实参的类型去推导），但普通函数和显式实例化可以进行自动类型转换。</p>
<p>显式实例化的方式可以让模板参数有一个确定的类型，并且指定的调用使用该类型实例化出的函数，不再需要实参去推导类型，这样就和调用普通函数一样，参数类型不匹配时，会尝试类型转换操作，如果无法转换成功编译器将会报错。</p>
</blockquote>
<p>如何证明模板函数会实例化呢？来看看上面的代码第10、11行的汇编：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632173.png" alt="image-20220729120039234"></p>
<p>可以看到，表面上好像无论实参类型是int还是double我们都是调用的Add函数，但事实上它们调用的是实例化出的函数<code>Add&lt;int&gt;</code>和<code>Add&lt;double&gt;</code>，它们是不同的函数。</p>
<h3 id="模板参数的匹配原则"><a href="#模板参数的匹配原则" class="headerlink" title="模板参数的匹配原则"></a>模板参数的匹配原则</h3><blockquote>
<ol>
<li>一个非模板函数可以和一个同名的模板函数同时存在，而且该函数模板还可以被实例化为这个非模板函数功能完全相同的一个函数。</li>
<li><strong>对于非模板函数和同名函数模板，如果其他条件（参数类型）都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例</strong>。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板，也可以强行调用显式实例化出的函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int Add(int left, int right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T Add(T left, T right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> +right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//与非模板函数匹配，不需要将模板函数实例化，直接调用</span></span><br><span class="line">    <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">//调用显式实例化出的函数Add&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//与非模板函数匹配，不需要将模板函数实例化，直接调用</span></span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);<span class="comment">//没有完全匹配的函数存在，模板函数可以生成类型更加匹配的版本，编译器根据实参类型推导生成更加匹配的Add函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>int Add(int left, int right)<br>T Add(T left, T right)<br>int Add(int left, int right)<br>T Add(T left, T right)</p>
<ol start="3">
<li>一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数，但两者是不同的函数，它们有不同的函数地址</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int Add(int left, int right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T Add(T left, T right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> +right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p1)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line">    <span class="built_in">int</span> (*p2)(<span class="type">int</span>, <span class="type">int</span>) = Add&lt;<span class="type">int</span>&gt;;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>00007FF793BD1217<br>00007FF793BD142E</p>
</blockquote>
<h3 id="模板函数和非模板函数的冲突问题"><a href="#模板函数和非模板函数的冲突问题" class="headerlink" title="模板函数和非模板函数的冲突问题"></a>模板函数和非模板函数的冲突问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int Add(int left, int right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T Add(T left, T right)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> +right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//与非模板函数匹配，不需要将模板函数实例化，直接调用</span></span><br><span class="line">    <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">//调用显式实例化出的函数Add&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们已经知道<code>Add(1, 2);</code>和<code>Add&lt;int&gt;(2, 3);</code>调用的不是同一个函数，那么这样为什么不会有符号表的冲突呢？</p>
<p><strong>猜测</strong>：非模板函数的符号表存放的是<code>Add</code>，而模板函数实例化出的函数符号表存放的是<code>Add&lt;int&gt;</code>，因此不会发生符号表冲突。</p>
<p>隐式实例化过程（<code>Add(1, 2);</code>）实际上是：</p>
<ol>
<li>调用<code>Add</code>时，去符号表里找函数<code>Add</code>，若未找到则执行第3步。</li>
<li>若找到了，接着检查类型是否匹配：如果匹配则直接用函数地址调用此函数。若不匹配则执行第3步；</li>
<li>寻找是否有名为Add的模板函数；</li>
<li>若没有找到相应的模板函数则报错。若找到了执行第5步；</li>
<li>查找此函数模板实例化出的函数中是否有与之类型匹配的函数；</li>
<li>若有，则调用此函数。若没有则尝试实例化出相应类型匹配的函数<code>Add&lt;int&gt;</code>，执行第7步；</li>
<li>实例化出的函数<code>Add&lt;int&gt;</code>会进入符号表，然后调用<code>Add&lt;int&gt;</code>函数；</li>
</ol>
<p>显式实例化过程（<code>Add&lt;int&gt;(2, 3);</code>）实际上是：</p>
<ol>
<li>调用<code>Add&lt;int&gt;</code>时，去符号表找<code>Add&lt;int&gt;</code>;</li>
<li>若找到了则直接调用此函数。若未找到则执行第3步；</li>
<li>寻找名为Add的模板函数；</li>
<li>使用模板函数实例化出相应函数；</li>
<li>实例化出的函数<code>Add&lt;int&gt;</code>会进入符号表，然后调用<code>Add&lt;int&gt;</code>函数；</li>
</ol>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板的定义格式"><a href="#类模板的定义格式" class="headerlink" title="类模板的定义格式"></a>类模板的定义格式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, ..., <span class="keyword">class</span> <span class="title class_">Tn</span>&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 类内成员定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态顺序表</span></span><br><span class="line"><span class="comment">// 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">        : _pData(<span class="keyword">new</span> T[capacity])</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">        , _capacity(capacity)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 使用析构函数演示：在类中声明，在类外定义。</span></span><br><span class="line">    ~<span class="built_in">Vector</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopBack</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line">        <span class="keyword">return</span> _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _pData;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Vector&lt;T&gt;::~<span class="built_in">Vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_pData)</span><br><span class="line">        <span class="keyword">delete</span>[] _pData;</span><br><span class="line">    _size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h3><blockquote>
<p>类模板实例化与函数模板实例化不同，<strong>类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector类名，Vector&lt;int&gt;才是类型</span></span><br><span class="line">Vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//用Vector&lt;int&gt;这个类型定义出对象v1</span></span><br><span class="line">Vector&lt;<span class="type">char</span>&gt; v2;<span class="comment">//用Vector&lt;double&gt;这个类型定义出对象v2</span></span><br></pre></td></tr></table></figure>

<p>汇编如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sxfinn/CDN/img/202212021632360.png" alt="image-20220729140911162"></p>
<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><blockquote>
<p>template&lt;typename T1, typename T2…&gt;中被&lt;&gt;括起来的就叫做模板参数，<strong>一个template&lt;&gt;只能对一个函数或者一个类生效</strong>，也就是一个template&lt;&gt;中模板参数只能在代码下方离他最近的一个函数或者类中使用。</p>
<p>模板参数与函数参数非常相似，不过模板参数既可以是类型又可以是值，而函数参数只能是值。</p>
</blockquote>
<h3 id="类型模板参数"><a href="#类型模板参数" class="headerlink" title="类型模板参数"></a>类型模板参数</h3><blockquote>
<p>类型形参即：出现在模板参数列表中，跟在class或者typename之类的参数类型名称，可以有缺省，缺省的规则和函数参数相同。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">char</span>&gt;<span class="comment">//半缺省</span></span><br><span class="line"><span class="keyword">class</span> S</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">S</span>()</span><br><span class="line">        :<span class="built_in">a</span>(<span class="number">0</span>)</span><br><span class="line">        ,<span class="built_in">b</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="type">int</span>, <span class="type">int</span>&gt; s1;</span><br><span class="line">    S&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板参数和函数参数一样，<strong>缺省参数（默认实参）只能在模板参数列表的结尾</strong>。</p>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><blockquote>
<p>非类型形参，就是用<strong>一个常量</strong>作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成<strong>常量</strong>来使用。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> sx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N = <span class="number">10</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> array</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> _array[index]; &#125;</span><br><span class="line">        <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span> &#123; <span class="keyword">return</span> _array[index]; &#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == _size; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T _array[N];</span><br><span class="line">        <span class="type">size_t</span> _size;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sx::array&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line">    sx::array&lt;<span class="type">char</span>, 15&gt; arr2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>浮点数、类对象以及字符串是不允许作为非类型模板参数的。</li>
<li>非类型的模板参数必须在编译期就能确认结果（常量值）。</li>
</ol>
<h3 id="多重模板参数"><a href="#多重模板参数" class="headerlink" title="多重模板参数"></a>多重模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 , <span class="keyword">typename</span> T2 &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">S</span>()</span><br><span class="line">        :<span class="built_in">a</span>(<span class="number">0</span>)</span><br><span class="line">        ,<span class="built_in">b</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">S</span>();</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">test</span><span class="params">(K k)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 &gt;</span><br><span class="line">S&lt;T1, T2&gt;::~<span class="built_in">S</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 &gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="type">void</span> S&lt;T1, T2&gt;::<span class="built_in">test</span>(K k)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="type">int</span>, <span class="type">int</span>&gt; s1;</span><br><span class="line">    s1.<span class="built_in">test</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.1</span>);</span><br><span class="line">    s1.<span class="built_in">test</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板类和模板函数区别"><a href="#模板类和模板函数区别" class="headerlink" title="模板类和模板函数区别"></a>模板类和模板函数区别</h2><p>模板类的实例化方式：</p>
<ul>
<li>显式实例化</li>
</ul>
<p>模板函数的实例化方式：</p>
<ul>
<li>显式实例化</li>
<li>隐式实例化</li>
</ul>
<p>通常模板函数我们使用隐式的实例化就足够了，但有些<strong>特殊情况</strong>，例如函数没有参数或者函数参数的类型并不是模板参数，无法通过实参去推导出类型，就需要<strong>显式地去实例化函数</strong>。而类的实例化只有显式实例化一种方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>C++泛型编程</p><p><a href="http://icarus.xinsong.xyz/2023/01/12/C++/13.C++模板初阶/">http://icarus.xinsong.xyz/2023/01/12/C++/13.C++模板初阶/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>NcPhoton</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-01-12</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-01-13</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/cpp/">cpp</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/01/12/C++/14.stl/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">C++ STL</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/01/12/C++/12.C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="level-item">C++内存管理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#泛型编程"><span class="level-left"><span class="level-item">1</span><span class="level-item">泛型编程</span></span></a></li><li><a class="level is-mobile" href="#函数模板"><span class="level-left"><span class="level-item">2</span><span class="level-item">函数模板</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#格式"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">格式</span></span></a></li><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#函数模板的实例化"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">函数模板的实例化</span></span></a></li><li><a class="level is-mobile" href="#模板参数的匹配原则"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">模板参数的匹配原则</span></span></a></li><li><a class="level is-mobile" href="#模板函数和非模板函数的冲突问题"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">模板函数和非模板函数的冲突问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类模板"><span class="level-left"><span class="level-item">3</span><span class="level-item">类模板</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类模板的定义格式"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">类模板的定义格式</span></span></a></li><li><a class="level is-mobile" href="#类模板的实例化"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">类模板的实例化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#模板参数"><span class="level-left"><span class="level-item">4</span><span class="level-item">模板参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类型模板参数"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">类型模板参数</span></span></a></li><li><a class="level is-mobile" href="#非类型模板参数"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">非类型模板参数</span></span></a></li><li><a class="level is-mobile" href="#多重模板参数"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">多重模板参数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#模板类和模板函数区别"><span class="level-left"><span class="level-item">5</span><span class="level-item">模板类和模板函数区别</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Nico&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 NcPhoton</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/live2d-widget/autoload.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>