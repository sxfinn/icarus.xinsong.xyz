{"posts":[{"title":"计算机眼中世界","text":"计算机眼中的数字 二进制数的换算 通常再生活中我们所使用的是十进制数，数字都是0~9这十个数字，除开数学领域外，普通人几乎不会涉及到其他进制的应用，正因为十进制在生活中的使用的快捷性和实用性，人类对其的应用非常广泛。 而对于计算机来说，它认识哪些东西呢？ 相信大家都知道，计算机中的一切数据其实都是由1和0组成的，也就是说计算机所认识的数字只有1和0，与我们习惯使用十进制数一样， 计算机所使用的数字也与计算机的组成息息相关。电路可以说是计算机最重要的元件，而每一条电路都只有两种状态：开或者关，两种状态恰好与1和0相对应，这也就解释了计算机使用二进制的原因。 二进制数的换算我们如果想将二进制数与十进制数互相转换，那该如何实现呢？ 下面我会用例子给大家说明例：二进制数 ‘1010’ 如果转化为十进制数是多少呢？ 运用类比思想 ，我们可以想：十进制数例如 ‘121’ 个位上1的权重为10的零次方十位上的权重为10的一次方百位上的权重为10的二次方，于是可以表示为1*10^2^+2 *10^1^+1 *10^0^ 运算结果是 121。 所以对于‘1010’最低为为第一位，则第n位的权重位2的n-1次方，于是可表示为1 *2^3^+0 *2^2^+1 *2^1^ +0 *2^0^运算结果是 10。即等于十进制的10.而对于二进制数的各种运算就不做详细阐述了，运用类比的思想，将十进制数的运算方法照搬过来，其实也就是二进制数的运算方式了。 计算机的内存内存的基本单位bit通常我们的电脑有32位计算机和64位计算机，而这里的‘位’到底是什么呢？ 这里所说的位数其实是计算机的地址线根数，而我们知道每根地址线会存在两种状态，即正和负，这些所有的地址线的状态则可以表示为很多个二进制数。在高中数学中我们学习过排列组合，因此不难知道，假如地址线有x根，则这些地址线状态总共就有2的x次方种（每一根有两种，x根的组合）. 这里我们以32位计算机为例子： 00000000000000000000000000000000这里有32个0，代表32根地址线都处于负 我们一直对其进行加1的操作 00000000000000000000000000000000(+1)00000000000000000000000000000010(+1) …………………(+1)11111111111111111111111111111111 最终变成了32个1组成的二进制数那这个数为多少呢？根据排列组合的知识很容易的出其值为2的32次方-1=4294967295. 内存大小的换算仍然以32位计算机为例，可以知道32位计算机可以表示从0到4294967295这么多的数字。 在日常生活中，每户人都有属于自己的街道名称，门牌号等住址信息，这样就方便了我们寻找一个地址。 计算机也是这样，计算机中的数据也会有一个自己的”地盘“，并且拥有明确的编号，像下面这样每一个编号都代表着一块空间，于是内存就被分配了编号和大小。 00000000000000000000000000000000 0 00000000000000000000000000000001 1 00000000000000000000000000000010 2 … – 11111111111111111111111111111110 4294967294 11111111111111111111111111111111 4294967295 – – 而这里的每一个编号所代表的空间的大小就为1个byte（字节） 不同内存大小的换算如下： 1pb=1024tb 1tb=1024gb 1gb=1024mb 1mb=1024kb 1kb=1024byte 1byte=8bit 通过这样的计算方法也可以计算出32位计算机的内存大小约为4GB. C语言是什么一门语言既然是一门语言，那么如同日语、英语一样，是供人们之间交流的。 计算机语言就是人和计算机交流的媒介，它使得我们可以命令计算机处理执行一些我们想让他做的事。 main函数-程序的入口1.main函数一定要有2.main函数在一个程序中有且只有一个框架： 1234int main(){ return 0;} 接下来我们在VS2019环境下证实一下 调试后直接跳到了主函数内部的第一个位置。 据此，我们可以证明main函数的确是程序的入口。 常见数据类型如果我们想表示一个人的年龄，那么可以用一个整数来表示，那如果想表示一本书的价格呢？那是不是就该用一个小数来表示了呢？于是浮点型和整型的数据类型便诞生了。 整型 数据类型 解释 int 整型 char 字符 short 短整型 long 长整型 longlong 超长整型 浮点型 数据类型 解释 float 单精度浮点型 double 双精度浮点型 注意：双精度浮点型精度更高 变量的定义方式 通常定义一个变量的方式为： 数据类型+变量名； 以int为例，我们来定义一个名字为i的变量。 123int i=0;//使用int类型创建了一个变量i，//i向内存申请了一块空间，空间名叫ii=10;//向i空间内放入整型10 于是一个类型为int，名称为i的变量就创建好并被赋值啦。 注意：C语言没有字符串类型 常量和变量常量常量即为不能改变的量 字面常量 常变量 标识符常量 枚举常量 字面常量 字面常量就是直接写出来的数 例如：10，99等这样的数字 常变量 常变量即被const修饰的变量 例如：const int i=9；// i 就不能再被赋予其他值了，我们来尝试一下： 1234567int main(){ //const-常属性 const int i = 9; i = 1; return 0;} 可以看到这里已经报错了 值得一提的是该定义方式下的变量为常变量，之所以叫常变量，是因为虽然不能再被赋值，但是 i 仍为变量，只不过具有了常属性，所以叫常变量。 注意：这里的 i 不能作为定义数组时的数组元素个数[i] 标识符常量 标识符常量是由#define定义的常量 例如：#define MAX 10即定义了MAX为常数 10 ，在程序中遇到MAX后会直接将MAX替换为10 接下来我们来试试： 1234567#include&lt;stdio.h&gt;#define MAX 10int main(){ printf(&quot;%d&quot;, MAX); return 0;} 运行结果如下： 注意：这里的 a 能作为定义数组时的数组元素个数[a] 枚举常量字面意思就可以知道”枚举“就是一一列举，并且由关键字enum修饰。 接下来举一个例子： 1234567891011121314151617#include&lt;stdio.h&gt;enum sex //枚举关键{ MALE, //表示枚举出来的可能值 FEMALE, neutrality};int main(){ enum sex a = MALE; //给相应的变量赋值 enum sex b = FEMALE; enum sex c = neutrality; printf(&quot;a=%d\\n&quot;, a); //依次打印出变量的值 printf(&quot;b=%d\\n&quot;, b); printf(&quot;c=%d\\n&quot;, c); return 0;} 输出为：a=0b=1c=2表明在枚举时系统会按照顺序依次从0开始对枚举出来的MALE/FEMALE/neutrality的赋值 如果我们稍稍改变一下上面的代码，来看看它如何对枚举常量赋值。 1234567891011121314151617#include&lt;stdio.h&gt;enum sex{ MALE, FEMALE=2, neutrality};int main(){ enum sex a = MALE; enum sex b = FEMALE; enum sex c = neutrality; printf(&quot;a=%d\\n&quot;, a); printf(&quot;b=%d\\n&quot;, b); printf(&quot;c=%d\\n&quot;, c); return 0;} 输出依次为：a=0b=2c=3 可以看出其赋值是依次递增1的，如果人为的给其赋值，则下一个仍然是递增一个1 变量 全局变量 局部变量 变量的使用 代码块— { } 全局变量全局变量—定义在块之外的变量 局部变量局部变量—定义在块之内的变量 变量的使用 接下来举一个例子来更好的认识全局变量和局部变量 123456789#include&lt;stdio.h&gt;int a = 0;int b = 0;int main(){ int x = 0; int y = 0; return 0;} a和b是定义在{ }之外的叫做全局变量 x和y是定义在{ }之内的叫做局部变量 C语言规定：定义变量必须在当前代码块的最前面（C99之前） 变量的作用域和生命周期生命周期大家都知道指的是事物的存在时间，人的生命周期是从出生到死亡，而在我们活着的这段时间里我们可以做很多事情，而当我们的生命周期结束——即死亡后，便彻底消失在了这世界上。因此，我们所创建的变量在内存中也有它的生命周期。 在创建一个变量时就会占用一部分内存，这个变量的生命周期开始，而内存时有限的，我们不能只向内存索取，而不给予内存空间反馈，这样最终内存会耗尽。因此，在变量使用结束后我们会销毁这个变量，并将空间还给操作系统，这样，一个变量的生命周期就结束了 作用域 我仍然使用人来作为例子，在人处于生命周期内，也就是活着的时候，我们可以做很多事情，旅游、学习，甚至时改变世界，因此我们活着时，所处的世界就是我们的作用域…… 而当我们的生命结束，便无法对这个世界再产生影响，也就是脱离了我们的作用域了。 局部变量也是这样，变量的作用域就是其所在的块内，在它的块内时，它处于生命周期中，并且可以发挥作用。 因此局部变量的作用域：其所在的块内。 全局变量就如同长生不老的神一般，世界创世之初就存在，只有这个世界消失了，它才会跟着消失。而对于全局变量来说它所处的世界就是一个工程。 因此，全局变量作用域是整个工程。 总结： 1、局部变量的生命周期：进入作用域开始，出作用域结束2、全局变量的作用域：整个工程 字符与字符串 字符 字符串 字符 ==字符==：被‘ ’括起来的一个==字母==、==数字==或者是==符号==。例：‘a’，’c’，‘#’ 这些都是字符 可我们之前说了计算机只认识0和1两个数字，那么字符在计算机中是如何存储的呢？ 我们从计算机的数据的存储方式来说： 数据在计算机上存储的时候，存储的是二进制的数，因此需要存储字符时，实际存储的是某一个数，也就是ASCII码值。 字符串 被” “括起来的==一串字符==。 例如：”hello world！“就是一个字符串。 接下来我将会使用一个代码讲述字符串一个很容易忽视的细节 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o' }; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof(arr1)); return 0;} 运行结果输出为： 6 5 通过上运行结果可看出可以看出，arr和arr1的大小是不同的。 表面上看好像上面两个数组中存放的都是 ‘h’ ’e‘ ’l‘ ’l‘ ’o’ ，但我们通过调试可以看到： arr比arr1这里多了一个’\\0‘（终止字符) 也就是说在字符串“hello”中实际在末尾还有一个’\\0‘作为字符串结束的标志。 那么就能解释在用sizeof对两个数组求大小时出现的大小不同的情况了。 除此以外还有一种情况让我们值得思考： strlen函数是用于求出字符串的长度，并且不包括’\\0‘，知道即可，目前不必深究。 那就是利用strlen函数求出arr和arr1的字符串长度，代码如下： 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o'}; printf(&quot;%d\\n&quot;, strlen(arr)); printf(&quot;%d\\n&quot;, strlen(arr1)); return 0;} 运行结果输出为： 这里又是为什么呢？明明strlen求的是字符串的长度，与’\\0‘无关了，为什么还会得出一个相差如此大的结果呢？ 这就要从strlen的实现来解释了，strlen函数是从字符串的第一个字符开始，每跳过一个一个字符计数器count就会+1，直到遇到字符串结束标志为止。而arr1在内存中的位置是随机的，无法确定arr1后面遇到的第一个’\\0‘在哪里，所以strlen（arr1）是个随机值。 如果将上面的代码改为： 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o','\\0'}; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof(arr1)); return 0;} 输出结果为： 6 6就符合我们的预期了！ 同时上述写法中arr和arr1是完全相同的，并无差异。","link":"/2022/12/07/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C/"},{"title":"C++入门基础上","text":"C++关键字C++关键字全集(参考 C++ Primer ): asm auto bad _cast bad _typeid bool break case catch char class const const _cast continue default delete do double dynamic _cast else enum except explicit extern false finally float for friend goto if inline int long mutable namespace new operator private protected public register reinterpret _cast return short signed sizeof static static _cast struct switch template this throw true try type _info typedef typeid typename union unsigned using virtual void volatile wchar_t while 命名空间 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的，std：c++标准库的命名空间。 在C语言中我们如果使用了同一个标识符定义了不同的函数或者是变量，会导致它们之间产生冲突，而C++为了解决这个问题，引入了命名空间的概念，不同命名空间的成员占有不同的内存空间，即使名称相同，但相互之间并不会受到影响。因此在C++中，库函数也是被定义在命名空间中的。 例如：C语言的头文件包含通常是 #include&lt;xxx.h&gt;，包含后我们便可以直接使用库函数，而在C++中我们的头文件通常是： #include&lt;xxx&gt;，并且无法直接使用库函数，必须要指定命名空间std才能使用。 不过C++是兼容C几乎所以语法的，因此我们可以在C++中穿插C的代码，不过有一些混用是很容易出错的，要小心并且正确的使用。 命名空间定义定义命名空间需要使用namespace关键字，后面跟上要定义的命名空间的名字，将命名空间成员定义在后面的{}内即可，类似于结构体和类的定义方式。 命名空间内可以定义变量，函数，类型，使用命名空间的类型定义出的变量不属于命名空间。 一般的命名空间定义方式 12345678910111213141516namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; };} 命名空间的嵌套定义 123456789101112131415161718192021222324namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; }; namespace psm { int b; void print() { cout &lt;&lt; &quot;hello psm!&quot; &lt;&lt; endl; } }} 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合并成同一个命名空间中 1234567891011121314151617181920namespace n1{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot;n1:swap&quot; &lt;&lt; endl; }}namespace n2{ int b;}namespace n1{ int c; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot;n1:swap&quot; &lt;&lt; endl; }} 像这样子去定义编译时会报错： 函数“void n1::swap(int &amp;,int &amp;)”已有主体 删除其中一个即可正常编译，由此可见编译时两个名字相同的命名空间会合并，如果有重复的定义则会报错。 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。 命名空间的使用定义在命名空间中的变量、类型以及函数我们是无法直接使用的，由于命名空间就定义了一个新的作用域，而程序中默认是只使用两个作用域的内容的： 全局作用域 局部作用域 并且根据局部优先原则会程序会先检索当前作用域的内容，如果没有找到我们需要的，再到全局域去检索，所以默认情况下我们所定义的命名空间的作用域的内容我们是无法直接访问的。 比如： 123456789101112131415161718192021namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; };}int main(){ cout &lt;&lt; a &lt;&lt; endl;//该语句编译出错，无法识别a return 0;} 报错：“a”: 未声明的标识符 命名空间的使用方式有三种： 加命名空间名称及作用域限定符 12345int main(){ cout &lt;&lt; sx::a &lt;&lt; endl;//指定使用在sx这个命名空间中的a return 0;} 作用域限定符是临时的，因此每次使用时都需要加命名空间和作用域限定符（限定符限定的是成员的名称，因此限定符应紧挨着在成员名称的前面，例如：sx::Stu s） 使用using声明命名空间中的成员，声明我们可以不加限定符使用此成员 12345678using sx::a;//指定地将sx中的a引入int main(){ cout &lt;&lt; a &lt;&lt; endl; //可以使用a Stu s; //无法使用Stu类型 return 0;} 这样只能使用指定使用我们需要的成员，并且声明时指定的应是成员的名称（变量名吗，函数名，类型名）。 使用using namespace 将命名空间中的成员引入至全局域 12345678using namespace sx;int main(){ cout &lt;&lt; a &lt;&lt; endl; Stu s; return 0;} 这种方法会将命名空间的所有成员一次性引入，可以直接访问其中所有的成员，平时我们可以这样使用，但是着违背了命名空间诞生的初衷，容易产生命名冲突的问题，因此在工程中通常是使用第一种或者第二种方法。 如何证明命名空间是被引入至全局域的呢？ 1234567891011121314151617int a = 1;using namespace sx;int main(){ cout &lt;&lt; a &lt;&lt; endl;//“a”: 不明确的符号 return 0;}using namespace sx;int main(){ int a = 1; cout &lt;&lt; a &lt;&lt; endl; return 0;} 第一个程序提示错误，而第二个程序正常运行。 引入至全局域后我们的程序即可在全局域中找到定义在命名空间sx中的变量 a ，而我们本身又在全局域中定义了一个变量 a ，那么自然如果不指定是哪个域中的也就产生了歧义，使得a变量名指代不明确。 可如果我们再次定义的a变量是局部的，即使命名空间中的a被引入至全局域，但并不会产生歧义，因为局部优先的原则，我们并不会去全局域中检索变量a，也就不存在命名冲突。 注意：即使是引入至全局域，命名空间sx中的a和本身定义在全局的a是拥有各自的内存空间的，”引入”仅仅是让其在全局域中可被检索，它仍然是属于命名空间sx的，有点像环境变量，引入就像是将某个命令所在的路径添加至环境变量，环境变量路径中的命令是可以在计算机任何路径下使用的，然而其被使用的命令可能并不在当前路径，它们之间是相互独立的。 指定使用全局域中的内容123456789101112131415161718namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using namespace sx;int main(){ int a = 1; cout &lt;&lt; ::a &lt;&lt; endl;//这里的a访问的是全局的 return 0;} 即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 命名空间是有一些比较坑的地方的，例如： 1234567891011121314151617181920212223242526272829303132333435363738//代码1int a = 1;namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using namespace sx;int main(){ cout &lt;&lt; ::a &lt;&lt; endl; return 0;}//代码2int a = 1;namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using sx::a;int main(){ cout &lt;&lt; ::a &lt;&lt; endl; return 0;} 代码1可以正常运行，而代码2却显示a多次定义，个人觉得还是有些奇怪的，不过项目中我们并不会将命名空间展开，更不会有这样的写法。使命名空间变量具有与全局变量相同的名称是错误的（参考微软官方文档https://docs.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170）。因此不用过于纠结这里的差异。 总之，使用using将命名空间展开或者是声明成员，即代表着后续的代码可以使用此命名空间的成员。 C++输入输出向世界打个招呼！ 12345678#include&lt;iostream&gt;using std::cout;int main(){ cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; return 0;} 使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含&lt; iostream &gt;头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用&lt;iostream&gt; +std的方式。 使用C++输入输出更方便，它会自动识别类型（函数重载实现）而不需增加数据格式控制，比如：整形–%d，字符–%c 例如： 12345678910111213#include&lt;iostream&gt;//using namespace std;using std::cout;using std::endl;using std::cin;int main(){ int i = 1; double d = 1.1; cout &lt;&lt; &quot;i =&quot; &lt;&lt; i &lt;&lt; &quot;,d =&quot; &lt;&lt; d &lt;&lt; endl; return 0;} 但是C++的这样的输入输出方式在有些场景下使用会非常麻烦，而C语言就会很方便，例如左对齐右对齐或者是保留几位小数这样的场景，推荐使用C语言的输出方式printf函数。 缺省参数缺省参数即可有可无的参数，就像汽车备胎，带上备胎也能上路不带也不影响，除非运气实在太差。 缺省参数是声明或定义函数时为函数的参数指定一个默认值，在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。 1234567891011void testfunc(int t = 10){ cout &lt;&lt; t &lt;&lt; endl;}int main(){ testfunc(100);//传入100，就使用指定的实参 testfunc();//没有实参，就使用默认的形参10 return 0;} 缺省参数的分类 全缺省参数 ​ 即所有参数都有自己的默认值，传参时可以全部省略。 12345678910void FAll(int x = 1, int y = 2, int z = 3){ cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;}int main(){ FAll();//全缺省 return 0;} 半缺省参数 ​ 即只有部分参数都有自己的默认值，传参时一定需要传参。 123456789void FHalf(int x, int y = 10, int z = 30){ cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;}int main(){ FHalf(5);//半缺省 return 0;p} 注意： 半缺省参数只能依次从右到左且连续，因为形参是从左往右依次传给实参，所以必须保证没有默认值的实参一定能有形参传值给它。 缺省参数不能在定义和声明中同时出现，以免给的默认值不同产生歧义。 123456void Test(int a = 10);void Test(int a = 20)//报错{ cout &lt;&lt; a &lt;&lt; endl;} 缺省值必须是常量或者是全局变量 C语言不支持 注意：如果定义和声明分离，那么只能缺省在声明 如果缺省参数在定义中，而声明没有，那么声明的头文件展开后，由于声明和定义在不同的源文件中，它们会先分别编译，那么包含定义的那个源文件在编译时编译器认为该函数是没有缺省参数的，但是该源文件函数的调用却没有传入参数，就发生了编译错误。 函数重载在我们的中文中常常会有一词多义的情况，但是我们可以通过上下文来帮助我们判断并确定它所表达意义而不是让我们无法识别。 讲个笑话： 我国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！ 那么一个相同的函数名我们想让它不只是有一种功能或者是不止能处理一种特定情况呢，函数重载可以帮助我们解决这个问题。 函数重载的概念 函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数或 类型或顺序)必须不同，常用来处理实现功能类似但数据类型不同的问题。 例如： 1234567891011121314151617181920212223int Add(int a, int b){ cout &lt;&lt; &quot;int Add(int a, int b)&quot; &lt;&lt; endl; return a + b;}double Add(double a, double b){ cout &lt;&lt; &quot;double Add(double a, double b)&quot; &lt;&lt; endl; return a + b;}float Add(float a, float b){ cout &lt;&lt; &quot;float Add(float a, float b)&quot; &lt;&lt; endl; return a + b;}int main(){ int ret1 = Add(1, 2); int ret2 = Add(1.1, 2.2); int ret3 = Add((float)1.1, (float)2.2); return 0;} 输出： 相同的函数名传入不同类型的参数调用的函数实体不同。 注意：无法区分仅按返回类型区分的函数 例如： 12345678short Add(short left, short right){ return left + right;}int Add(short left, short right){ return left + right;} 因为函数调用时只能根据实参的类型去找相匹配的函数，而无法识别返回类型。 函数重载的底层实现C语言是不支持函数重载的，但是C++却引入了这个特性，那么一定是因为底层实现有区别，于是我们从程序的编译和运行来探索一下，一个程序要运行起来，那么必须要经过预处理、编译、汇编、链接最终成可执行文件，在Windows中是后缀为 exe的文件，但由于VS是集成环境不方便查看，我们可以在Linux环境下尝试。 程序的编译过程： 符号表的合并 实际我们的项目通常是由多个头文件和多个源文件构成，而通过我们C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？ 所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。 那么链接时，面对Add函数，连接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。 【程序的编译具体参见】： 【C语言进阶】程序的编译 – Sabrina 函数名修饰 由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂，下面我们使用了gcc演示了这个修饰后的名字。 通过下面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+参数类型首字母】。 分别使用C的编译器和C++的编译器去编译并获得一个可执行文件 使用C语言（gcc）编译器编译后结果 使用objdump -S 命令查看gcc生成的可执行文件： 使用C++编译器（g++）编译后结果 使用objdump -S 命令查看g++生成的可执行文件： linux下：修饰后的函数名= _Z + 函数名长度 + 形参类型首字母 通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载，另外我们也从底层理解了，为什么函数重载要求参数不同！而跟返回值没关系。 C++的编译和链接方式 采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数，而我们另一个模块中想要调用这些函数也就必须使用相对应的C++的规则去链接函数（找修饰后的函数名）才能找到函数的地址。 C的编译和链接方式 对于C程序，由于不支持重载，编译时函数是未加任何修饰的，而且链接时也是去寻找未经修饰的函数名。 C和C++直接混合编译时的链接错误 在C++程序中，函数名是会被参数类型信息修饰的，这就造成了它们之间无法直接相互调用。 例如： print(int)函数，使用g++编译时函数名会被修饰为 _Z5printi，而使用gcc编译时函数名则仍然是print，如果直接在C++中调用使用C编译规则的函数，会链接错误，因为它会去寻找 _Z5printi而不是 print。 结论：在Linux环境下，采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数。 对重载函数的调用不明确难道说有了重载函数那么函数在调用时即使函数名相同就一定能区分了吗？ 来看看下面这种情况： 1234567891011121314void test(int a = 1, int b = 2){ cout &lt;&lt; &quot;testab&quot; &lt;&lt; endl;}void test(){ cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;}int main(){ test(); return 0;} 那么在12行调用test函数，按照C++的链接规则，我们应该找的是_Z4test，这样的被修饰过的函数名。 第1行的test函数经过修饰是_Z4testii 第6行的test函数经过修饰是_Z4test 那是否意味着我们不传参调用时就一定去找的_Z4test呢？但是明明第1行的函数带有默认参数即使不传参也可以调用啊。 事实上这个程序是可以编译通过的因为被修饰后的函数名并不会产生冲突，只会在调用函数时会存在歧义，链接过程中，这两个重载的函数都会成为被调用的候选人，并且都符合调用的条件，多个匹配函数找到，调用将被拒绝，因此我们链接过程中不仅仅是寻找函数名那么简单，还有很多复杂的规范。 【拓展阅读】：C++的函数重载 - 吴秦 - 博客园 extern “C”我们在写C++代码时，由于其兼容C语言，因此我们通常会使用一些C标准库里的函数，那如果它们的函数名修饰规则不同，那么C++编译器又是怎么去调用C的库的呢？ 在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略. 在C++工程中需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，该函数是按照C语言规则来编译和链接的。 比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree,两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。 源文件A（cpp）: 1234int Add(int num1, int num2){ return num1 + num2;} 源文件B（cpp）: 123456extern &quot;C&quot; int Add(int num1, int num2);int main(){ Add(1, 2);//在模块B中调用A中的函数 return 0;} error LNK2019: 无法解析的外部符号_Add，该符号在函数 _main 中被引用 注意： 这里的模块A的 Add函数仍然是按照C++规则去编译的，函数名仍会被修饰为_Z3Addii，不过在模块B 使用extern ”C“会让编译器让Add函数按照C的方式链接，所以在调用时用C的方式去寻找Add，所以会报错。 总结： extern “C” 只是 C++ 的关键字，不是 C 的 所以，如果在 C 程序中引入了 extern “C” 会导致编译错误。 被 extern “C” 修饰的目标一般是对一个全局C或者 C++ 函数的声明 从源码上看 extern “C” 一般对头文件中函数声明进行修饰。 C 和 cpp 中头文件函数声明的形式都是一样的（因为两者语法基本一样），对应声明的实现却可能由于语言特性而不同了( C 库和 C++ 库里面当然会不同)。 extern “C” 这个关键字声明的真实目的，就是实现 C++ 与C及其它语言的混合编程 一旦被 extern “C” 修饰之后，它便以 C 的方式工作（编译阶段：以C的方式编译，链接阶段：寻找C方式编译生成的符号）， C 中引用 C++ 库的函数，或 C++ 中引用 C 库的函数，都可以通过这个方式(即在C++文件中用extern “C” 声明，实现C与C++的兼容。 【关于extern “C”的具体使用】： C++和C的混合编译（extern“C”） – Sabrina 引用引用的概念引用不是定义了一个新的变量，而是是一个别名，也就是说，它是某个已存在变量的另一个名字，它和被引用的对象共用同一块内存空间。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 别名字面意思就是另一个名字，例如孙悟空，他的别名是孙行者，孙悟空也是他，齐天大圣也是它，一切可以指代他的名称都可以称作他的别名。 初始化引用格式 引用实体类型 &amp; 引用变量名 = 引用实体 1234567891011#include&lt;iostream&gt;using namespace std;int main(){ int a = 1; int&amp; quote = a;//初始化quote为a的别名 cout &lt;&lt; a &lt;&lt; quote &lt;&lt; endl; quote = 2; cout &lt;&lt; a &lt;&lt; quote &lt;&lt; endl; return 0;} 我们进入调试窗口： 通过调试可以看到，a和quote的地址是一样的，并且quote的类型就为int&amp;，所以quote的改变一定会影响a。 引用特性 引用在定义时必须初始化； 一个变量可以有多个引用； 引用一旦引用一个实体，引用指向的对象就不能再改变； 引用的实体可以是另一个引用; 例如： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//定义引用时未初始化int main(){ int a = 1; int&amp; quote;//未初始化引用，error: ‘rodents’ declared as reference but not initialized quote = a;}//修改引用实体int main(){ int a = 1; int b = 2; int&amp; quote = a; int&amp; quote = b;//只能引用一个实体,编译出错 return 0;}//引用另一个引用int main(){ int a = 1; int&amp; quote1 = a; int&amp; quote2 = quote1;//它们的地址仍然相同，指向同一块空间 return 0;} 常引用在C++中，与C语言不同，被const修饰的变量会被当做是一个常量（只对该变量内存空间有读权限，没有写权限），而不是常变量，因此引用的类型一定要和被引用的实体相匹配，可以有权限的缩小，但不能有权限的扩大。 例如： 12345678910111213141516171819202122//权限的缩小int main(){ int a = 1; const int&amp; quote = a;//从可读可写-》只可读 return 0;}//权限的放大会报错int main(){ const int a = 1; int&amp; quote = a;//从只可读-》可读可写 return 0;}//常引用int main(){ const int a = 1; const int&amp; quote = a; quote = 2;//不可赋值 return 0;} 使用场景 做参数 ​ 对于需要在函数内部修改函数外部实参的函数，让形参为实参的引用，就可以在函数内部修改外部变量，并且 还可以减少形参拷贝实参的开销。 123456789101112131415void swap(int&amp; num1, int&amp; num2){ int tmp = num1; num1 = num2; num2 = tmp;}int main(){ int n1 = 3; int n2 = 5; swap(n1, n2); cout &lt;&lt; &quot;n1=&quot; &lt;&lt; n1 &lt;&lt; endl &lt;&lt; &quot;n2=&quot; &lt;&lt; n2 &lt;&lt; endl; return 0;} 做返回值 如果返回的变量在函数调用结束后不会被自动销毁，则可以返回该变量的引用，减少返回值拷贝的开销 1234567int&amp; count(){ static int n = 1; ++n; cout &lt;&lt; &quot;int&amp; count()&quot; &lt;&lt; endl; return n;} 返回值不能是函数内创建的局部变量的引用 ​ 否则会非法访问内存（访问不属于程序的内存） 123456789101112int&amp; Add(int a, int b){ int c = a + b; return c;}int main(){ int&amp; ret = Add(2, 8);//Add(2, 8)的类型是c的引用，当赋值给ret时，c变量已经销毁 cout &lt;&lt; ret &lt;&lt; endl; return 0;} 总结：如果函数调用结束后栈帧销毁但是返回对象仍未销毁，则可以使用引用返回，否则只能传值返回。 传值和传引用的区别 以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。 函数的传参如果是传值调用的话，形参实际上是实参的一份拷贝，也就是说每一次调用函数，都要将实参拷贝给形参，这也带来了资源的消耗，如果多次调用此函数，那么必定会导致效率的低下。 可以使用如下代码测试多次调用函数时传值调用和传引用调用的时间差异 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;struct A{ A() { memset(arr, 0, sizeof(arr)); } int arr[1000];};void TestFunc1(A p){}void TestFunc2(A&amp; p){}void TestEfficiencyByCall(){ A p; size_t start1 = clock(); for (int i = 0; i &lt; 1000000; i++) { TestFunc1(p); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i &lt; 10000; i++) { TestFunc2(p); } size_t end2 = clock(); cout &lt;&lt; &quot;传值调用 void TestFunc1(A p)：&quot; &lt;&lt; end1 - start1 &lt;&lt; endl; cout &lt;&lt; &quot;传引用调用 void TestFunc1(A&amp; p)：&quot; &lt;&lt; end2 - start2 &lt;&lt; endl;}int main(){ TestEfficiencyByCall(); return 0;} 运行结果如下： 值和引用的作为返回值类型的性能比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct A{ A() { memset(arr, 0, sizeof(arr)); } int arr[1000];};A a;A TestFunc1(){ return a;}A&amp; TestFunc2(){ return a;}void TestEfficiency(){ size_t start1 = clock(); for (int i = 0; i &lt; 1000000; i++) { TestFunc1(); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i &lt; 10000; i++) { TestFunc2(); } size_t end2 = clock(); cout &lt;&lt; &quot;值返回 void TestFunc1(A p)：&quot; &lt;&lt; end1 - start1 &lt;&lt; endl; cout &lt;&lt; &quot;引用返回 void TestFunc1(A&amp; p)：&quot; &lt;&lt; end2 - start2 &lt;&lt; endl;}int main(){ TestEfficiency(); return 0;} 运行结果： 可以看到无论是作为参数还是作为返回值，传递引用和值的时间的开销差异都是比较大的。 我们可以看一看函数返回值是如何传递的： 函数返回值从被调用的函数的栈帧到调用方栈帧的传递过程大致如上。 通常我们会创建一个变量接收函数得返回值，在这里就是这个在main函数中预先开好空间的用于存储函数返回值的对象。 接下来看过程： 如果是传值返回，则产生的临时变量会是返回对象的一份临时拷贝，然后再拷贝给main函数中预先开好空间的用于存储函数返回值的对象，而如果是传引用返回，则临时变量会是a的引用，临时对象再赋值给main函数中预先开好空间的用于存储函数返回值的对象，那这里也会是一个引用，因此我们在main函数中就可以访问到a对象了。 不过不是每次都需要创建一个临时变量，对于一些比较小的变量，会直接用寄存器来传递值。 注：临时变量的类型就是定义的返回类型，此临时变量通常也是也是具有常性的，不过也有例外，那就是传引用返回的情况。 传值返回：那么该临时变量是有常性的。 传引用返回：无常性，只和返回的类型是否被const修饰有关。 临时变量存储于调用方函数的栈帧**。 引用和指针的区别引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用（引用的对象必须存在）。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 引用在语法层面上就是一个别名，别名是不单独享有内存空间的，它和被引用的实体共用同一块内存空间。 12345678int main(){ int a = 9; int&amp; ra = a; cout &lt;&lt; &quot;&amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;&amp;ra = &quot; &lt;&lt; &amp;ra &lt;&lt; endl; return 0;} 这样的语法解释实在有些难以理解它在底层是如何做到的。 实际上在底层实现上引用还是有空间的，因为引用本质还是指针的方式来实现的。 1234567891011int main(){ int a = 9; int&amp; ra = a; ra = 99; int* pa = &amp;a; *pa = 99; return 0;} 我们来看看汇编： 汇编指令大致都是相同的，也就是说它和指针实际上是同根同源的。 指针和引用差异汇总： 引用在定义时必须初始化，而指针不需要； 引用在初始化引用一个实体后就不能再引用其他实体了，而指针指向的对象可以随意修改； 没有NULL引用，但是又NULL指针； 在sizeof中的含义不同，引用结果为被引用实体的类型大小，而指针的大小是地址空间所占的字节数； 引用在初始化后，一切对引用的操作都是对实体对象操作的，而指针可以操作指针变量本身，也可以操作被指向的对象； 有多级指针但没有多级引用； 访问实体方式不同，指针需要我们显式的去解引用方能对指向的对象进行操作，而引用是编译器替我们处理； 引用相对于指针更加的安全，不存在野指针等潜在的风险； 一些引用的注意事项类型转换实现方法以及临时变量的特性 看如下代码： 1234567int main(){ double d = 9.9; int&amp; a = d; cout &lt;&lt; a &lt;&lt; endl; return 0;} 报错： “初始化”: 无法从“double”转换为“int &amp;” 改动如下即可正常编译： 1234567int main(){ double d = 9.9; const int&amp; a = d; cout &lt;&lt; a &lt;&lt; endl; return 0;} 这是什么原因？？const修饰过后为什么就能正常编译了呢？？？（warning） 这里不得不提到类型转换时发生的小动作； 类型转换是如何实现的呢？不论是显式的还是隐式的发生的类型转换，它这个类型转换的效果都是“临时”的，仅仅在当前行生效，也就是说本身发生转换的那个变量或者说是对象它的类型并没有改变。 既然如此，那么中间一定会有另一个临时变量的产生，而是这个我们看不到的临时变量在发挥让我们看起来像“类型转换”的作用。 那么再来看第4行代码，int&amp;只能初始化为int类型的引用，因此这里会发生隐式类型转换，即产生一个int类型的变量，并且让这个临时变量在这一行中代替d来产生作用，a就被初始化为了这个临时变量的引用； 为什么不用const修饰就无法通过编译呢？ 答案是：临时变量具有常性，也就是说临时变量具有只可读不可写的性质，那么如果不使用const对引用加以限制，就造成了权限的放大，而这是不被C++所允许的，因此必须加上const修饰a； 嘿，那么新问题来了，既然临时变量只在当前行生效，也就是程序走完这一行临时变量就销毁了，而a作为此临时变量的引用，却在第5行正常访问了a，那么这里我们还可以得出一个结论： const修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，直到引用的生命周期结束。 概括一下： 类型转换伴随着临时变量的产生； 临时变量具有常性； const修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，知道引用的生命周期结束； 不会被修改的变量尽量用const修饰； 关于临时对象的类型的注意事项 如下两段代码有何差异？ 123456789//代码1int main(){ double d = 9.9; const int&amp; a = (int&amp;)d; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; return 0;} 输出： d = 9.9a = -858993459 123456789//代码2int main(){ double d = 9.9; const int&amp; a = d; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; return 0;} 输出： d = 9.9a = 9 出错了，奇怪，这两段代码的执行结果应该相同才对啊？？？不急我们耐心分析一下这两段代码的差异。 差异就只有第四行，我们来单独看看 代码1： const int&amp; a = (int&amp;)d; 这行代码的意思应该是将 d (double类型)强制类型转换为 int&amp;，我们都知道强转类型时会生成一个临时变量（int&amp;），再初始化a为为这个临时变量的引用； 关系如图： 这里的关系文字描述为d是double类型， tmp是d的引用（int&amp;），而a又是tmp的引用（int&amp;），可以直接认为a是d的引用，只不过引用的类型为 const int; 代码2： const int&amp; a = d; 这行代码的意思是初始化a为d的引用，不过类型并不匹配，int&amp;需要一个引用一个int的实体或者一个int&amp;的引用，因此，d会发生隐式类型转换，产生一个int类型的临时变量，即a会是这个临时变量的引用。 关系如图： 这里的关系文字描述为d是double类型，而tmp是一个临时的int类型，a是tmp的引用； 这样就解释的通了，但是是否真是如此，我们需要通过地址来验证； 代码1： 可以看到他d和a的地址是一样的，说明a是d的引用（指向d的地址），但只是引用的类型和d的类型不同。 代码2： a的地址和d不同，这是因为a是隐式类型转换所产生的临时变量的引用，而此临时变量是一个int类型，而非引用，具有自己独立的内存空间，而a指向这块临时变量的空间，因此地址不同。 这两段代码的唯一差异就是类型转换时生成的临时变量的类型不同，一个是int类型，一个是int&amp;类型，即一个有自己的单独内存空间，而另一个与发生类型转换的对象共享一块空间（其实引用是有单独的内存空间，不过经过编译器处理，我们对引用操作时都是实际上操作的是被引用的实体，因此可以视作没有分配内存），而a都是临时变量的引用，就导致了最终结果的不同。 因此在使用引用时，一定要注意这些可能会遇到的问题，一不留神就可能掉坑了，要规范正确的使用引用。","link":"/2022/12/05/1.C++%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"C++入门基础","text":"内联函数C++中函数的使用我们已经比较清楚了，与C语言中函数的使用大多相同，主要是增加了重载的特性，对C语言的函数的一些缺陷做了一些补充。 那么对于一些比较简单却又经常使用的功能，我们在C语言中常常使用宏来替换，宏呢与函数相比没有栈帧的开辟，类型的检查，没有传参，仅仅是做一个替换，非常适合功能简单却使用频繁的应用场景，但是宏正因为如此，也就具有了不安全、无法调试的缺陷，那么C++中如何处理这样地缺陷呢？ 内联函数应运而生它既继承了宏的优点也继承了函数的优点，即既没有开辟栈帧的开销，又可以去调试，并且有类型的检查。 内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生 处理宏的一些问题。 概念 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。 我们得明白，函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视，要尽可能处理函数调用机制所用时间占比大的这种情况。 为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。 先来看看普通函数的调用过程： 调用函数时是使用call指令，去调用某地址上的函数。（注意：普通函数都是有地址的，可以用以区分内联函数） 如果在上述函数的前面加上inline关键字将其改为内联函数，在编译期间编译器会用函数体替换函数的调用。 不过我们通常在Debug模式下默认函数不会被当做内联，即使你加上了inline，都会被编译器忽略，只有在release模式下，inline才有可能会被采纳，至于为什么是有可能，编译器只会把你的inline关键字当做一个建议，至于编译器是否按照你所要求的去做，这就不一定了，因为这仅仅是一个建议，编译器会结合具体情况比如函数体指令的多少来判断到底是否当做内联函数。 所以我们如何去观察一个函数是否被当做内联函数呢？ 在release模式下 查看编译生成的汇编代码中是否存在call Add 监视器窗口查看Add函数是否有地址； 在debug模式下需要对编译器进行设置，否则不会展开，因为在debug模式下，编译器默认不会对代码进行优化，内联函数其实算一种优化方式。 在项目—&gt;属性中找到 C/C++选项—&gt;常规 ​ 将调试信息格式改为程序数据库(/Zi) 在C/C++选项中找到优化 将内联函数扩展选择—&gt;只适用于__inline(Ob1) ​ 重新生成可执行文件即可 完成后，我们便可以在debug模式下查看到内联函数的展开 这里并没有call Add函数，而是函数体的展开（当然不仅仅是简单的展开，还会涉及一些其他指令，不做深入讨论）。 特性 inline是一种空间换时间的做法 ，节省了开辟栈帧的时间开销； ​ 与调用普通函数相比不需要去开辟栈帧空间，节省了时间，相当于inline函数体所有指令都在当前栈内被执行； inline对于编译器仅仅是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化会自动忽略内联。 ​ 不仅是以上两种情况，函数体内的指令一旦较多，编译器就会自动忽略，如下： ​ 函数体指令较复杂： ​ ​ 函数体指令较简单： inline函数不建议声明和定义分离，分离会导致链接错误。因为inlinn函数被展开，也就不会有函数地址，自然不用提去链接了。 1234567891011121314151617181920//func.h文件#pragma once#include&lt;iostream&gt;using namespace std;inline void f(int i);//func.cpp文件#include&quot;test.h&quot;void f(int i){ cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;}//main.cpp文件#include&quot;test.h&quot;int main(){ f(1); return 0;} 报错：error LNK2019: 无法解析的外部符号 “void __cdecl f(int)” (?f@@YAXH@Z)，函数 main 中引用了该符号。 如果想要一个函数成为内联，但是类的定义和类实例化的地方在不同的源文件（声明定义分离），那么最好是将此函数定义在类中。 对于内联函数，其工作原理是： 对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。 各个文件是分离编译的，在func.c中由于声明了f函数是内联的，并且函数体也很简短，因此编译器遵循了我们的建议，使其成为一个内联函数，由于没有函数地址，自然无法被除本源文件以外的地方调用；也可以说内联函数在符号表不会有合并这一步操作，仅仅存在于本源文件中。 内联函数的缺点难道内联函数就没有缺点吗，当然有！不然还要函数做什么？内联函数随着一次次的调用展开，会造成代码膨胀的问题，通俗讲就是生成的可执行文件会变大，这是我们不愿意看到的（有谁愿意看着自己的电脑硬盘被榨干呢？） 可以大致从几个方面看： 编译后的程序会存在多份相同的函数指令拷贝，这些函数拷贝编译后都是二进制的指令，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。 可执行程序在运行前要先载入内存，程序的执行就是一步步去内存取指令然后交给CPU执行的过程，可以试想可执行文件大，那么其指令也就越多，载入内存后消耗的空间也越大。 ​ 很好理解，普通的函数都有一个地址，每当我们需要使用这个函数时，直接通过函数名访问地址，然后就是建立栈帧的过程，在新栈帧中执行相应函数指令。 ​ 内联函数没有它的地址，我们需要调用这个函数时，只能临时拷贝一份，再执行相应指令。 ​ 举一个例子就是，普通函数就是一个坚信好 “记性不如烂笔头的乖学生”，老师讲一个重要的、多次使用的知识点时，他就记在笔记本上，需要了就拿出来看看就会了。内联函数也是一个爱记笔记的学生，不过它丢三落四的，刚记下笔记笔记本就丢了，每次需要时，就只能又去问老师再记下来，慢慢的他写过的笔记本就很多了，不过他自己还浑然不知。 ​ 他们两个同学的笔记本都是一个作用，就是记录下这个知识，但是随着使用次数的增加，这位有收拾的同学只需要一个笔记本就能终生受用，而这位丢三落四的同学则会随着记了又丢，丢了又记的过程产生很多个笔记本，内联函数也是同样的道理。 那么它们的过程实际区别如下： ​ 在程序载入过程中，两个函数体内容相同的普通函数和内联函数，普通函数的函数指令只向内存中载入了一次，之后每次调用此函数都只需要一条指令，直接访问其函数地址并取指令。 ​ 内联函数不会载入内存，没有函数地址。在编译后这些调用内联函数的语句都会被展开为内联函数的指令（做了一些特殊处理，并不是完全复制的函数体指令），由于编译后内联函数展开部分就只是一条条的指令，这些指令都会被载入内存，可以看到这里调用了多少次，内联就展开了多少次，展开的指令都会被载入内存，可以等效于调用了几次就将内联函数的指令载入了几次到内存。 那么也就得出差异，普通函数只需要载入内存一次，而内敛函数是调用了几次就会载入内存几次。 如果内联函数调用次数很多，调用结束后由于调用所产生的内存消耗并不会被释放（普通函数调用结束后栈帧会销毁） ​ 如图： 总体来说，如果除去开辟栈帧的花销，内联函数和普通函数的所执行的指令数、时间几乎是相同的，重点在于如何把控执行一个函数时，它开辟的栈帧的消耗占整个函数调用的比重，如何把控这个比重，决定了我们是否建议一个函数为内联。 我们来写个程序验证一下，并从指令的角度来看： 12345678910111213inline void func(){ cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;}int main(){ func(); func(); func(); func(); return 0;} 来看看内联函数的汇编指令： 12345678910111213141516171819202122232425262728 func();00007FF6AA4D1522 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D1529 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1530 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D1535 lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D153C mov rcx,rax 00007FF6AA4D153F call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D1545 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D154C mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1553 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D1558 lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D155F mov rcx,rax 00007FF6AA4D1562 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D1568 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D156F mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1576 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D157B lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D1582 mov rcx,rax 00007FF6AA4D1585 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D158B lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D1592 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1599 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D159E lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D15A5 mov rcx,rax 00007FF6AA4D15A8 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] 接着我们取消内联再来看看： 12345678 func();00007FF679261572 call func (07FF679261285h) func();00007FF679261577 call func (07FF679261285h) func();00007FF67926157C call func (07FF679261285h) func();00007FF679261581 call func (07FF679261285h) 差别还是蛮大的，这些指令都会在运行时载入内存，造成代码膨胀。 一些其他不足 通常，编译器比程序设计者更清楚对于一个特定的函数是否合适进行内联扩展；一些情况下，对于程序员指定的某些内联函数，编译器可能更倾向于不使用内联甚至根本无法完成内联。 对于一些开发中的函数，它们可能从原来的不适合内联扩展变得适合或者倒过来。尽管内联函数或者非内联函数的转换易于宏的转换，但增加的维护开支还是使得它的优点显得更不突出了。 对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。 判断是否设置为内联：一般只将那些短小的、频繁调用的函数声明为内联函数。 最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。 auto关键字auto为自动的意思，C语言中貌似也有提到过（自动变量什么的，记不清了几乎没使用过），那么在C++中auto有什么作用、应用于哪些场景呢？ auto简介 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它，大家可思考下为什么？ C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。 12345678910111213int main(){ auto a = 1; auto b = 2.0; auto c = 2.0f; auto d = 'w'; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; cout &lt;&lt; typeid(d).name() &lt;&lt; endl; return 0;}//auto e;无法通过编译。 既然是编译期间自动推导类型，那么就说明一定得初始化咯。 使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。 详细使用规则既然是占位符则说明auto可以是任何类型，而不一定是对其进行初始化数据的类型。 auto和指针结合起来使用 ​ 用auto声明指针类型时，用auto和auto*没有任何区别，但是auto对于引用的声明必须加上&amp;； 12345678910111213141516int main(){ int a = 10; auto p1 = &amp;a;//auto在编译时会被替换为int* auto* p2 = &amp;a;//auto在编译时会被替换为int int&amp; ref = a; auto ref1 = ref;//ref是a的别名，因此推导出是int类型 ref1 = 12;//a并不会改变 cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(ref).name() &lt;&lt; endl; cout &lt;&lt; typeid(p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(p2).name() &lt;&lt; endl; cout &lt;&lt; typeid(ref1).name() &lt;&lt; endl; return 0;} 同一行定义多个变量 ​ 在同一行定义多个变量时，这些变量的类型必须相同，否则编译器会报错，因为编译器实际只对第一个类型进行推导，然后替换为auto，并用该类型定义其他变量。 12345int main(){ auto a = 1, b = 1.0; return 0;} 在声明符列表中，“auto”必须始终推导为同一类型 这样看auto好像还挺万能的，那么auto能适用于所以场景吗？ auto不能推导类型的场景 不能作为函数的形参 12345// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a和b的实际类型进行推导int Add(auto a, auto b){ return a + b;} error C3533: 参数不能为包含“auto”的类型 函数在编译时是需要形参类型来确定修饰后函数名的，所以形参类型要先确定。 这种显然是不可行的，如果可以直接使用auto推导，那么就没后面的模板什么事了。 注：返回值是可以用auto的。 不能用来直接声明数组 12345int main(){ auto arr[] = { 1,2,3,4,5 }; return 0;} error C3318: “auto []”: 数组不能具有其中包含“auto”的元素类型 error C3535: 无法推导“auto []”的类型(依据“initializer list”) 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法 auto为了在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用 基于范围的for循环for循环是我们非常熟悉的，用法也比较单一，通常在知道循环次数的情况下使用，那么什么是范围for呢？ 范围for的语法C++98中如果我们要遍历一个数组通常是下面这种方式： 12345678void TestFor(){ int array[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i) array[i] *= 2; for (int* p = array; p &lt; array + sizeof(array) / sizeof(array[0]); ++p) cout &lt;&lt; *p &lt;&lt; endl;} 对于一个范围已知的集合而言，由我们来说明循环的范围显然是多余的，有时候不注意还会出错。因此C++11中引入了基于范围的for循环。for循环后的括号由冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。 12345678void TestFor(){ int array[] = { 1, 2, 3, 4, 5 }; for (auto&amp; e : array) e *= 2; for (auto e : array) cout &lt;&lt; e &lt;&lt; &quot; &quot;;} 循环体内就和普通的循环一样了，我们可以使用break跳出循环，也可以使用continue结束本次循环，只不过是编译器帮助我们确定迭代的范围而已。 范围for的使用条件 for循环迭代的范围是确定的 对于数组而言，迭代的范围就是从第一个元素到最后一个元素； 对于类而言，应该提供begin以及end的方法，循环的范围就是从begin到end； 也就是说我么给for的应该是一组数据集合，例如数组，链表等等… 看看一下代码是否有问题： 12345void TestFor(int array[]){ for (auto&amp; e : array) cout &lt;&lt; e &lt;&lt; endl;} “begin”: 未找到匹配的重载函数 显然是有问题的，数组名作为形参，其本质上是一个指针，指针是一组数据的集合吗？？显然不是。 迭代的对象的迭代器要实现++和==的操作。(关于迭代器这个问题，以后会讲，现在大家了解一下就可以了) ​ 可以先简单说说迭代器，迭代器就是一个封装后的指针，通过这个封装后的指针我们可以通过地址找到数据的存储位置。为什么要封装呢？因为对于原生指针我们执行++操作，它是在相邻的位置移动，这样对于链表等数据结构是无法正确访问的，可如果我们对++操作符进行重载，就可以让它根据他的存储特性去移动指针了！ 新的指针空值nullptr C++11从学习C语言之初，我们就说要养成一个好习惯——声明一个变量时给一个合适的初值，否则可能会出现不可预料的错误，比如未初始化的指针。如果当前指针没有明确的指向，那么可以给其赋值为空； 123456int main(){ int* p = NULL; int* p1 = 0; return 0;} 这两者其实是一样的，NULL其实是一个宏，即是0值； 在传统C头文件里(stddef.h)中，可以看到如下代码： 1234567#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如： 123456789101112131415void func(int){ cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;}void func(int*){ cout &lt;&lt; &quot;f(int*)&quot; &lt;&lt; endl;}int main(){ func(0); func(NULL); func((int*)NULL); return 0;} 我们的本意是让func(NULL)去调用void func(int*)的，但却出现了问题，由于NULL被定义成0，而0默认被当做一个整型，因此与程序的初衷相悖。 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。 因此在C++程序中我们更倾向使用nullptr而不是NULL，来看看nullptr是什么。 12345678int main(){ int* p = NULL; int* p1 = 0; cout &lt;&lt; &quot; &quot; &lt;&lt; typeid(NULL).name() &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; return 0;} 注意： 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。 为了提高代码的健壮性（适用于更多场景），在后续表示指针空值时建议最好使用nullptr。","link":"/2022/12/05/2.C++%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"VSCode配置C-C++环境","text":"转载自：【教程】VScode中配置C语言/C++运行环境_哔哩哔哩_bilibili 下载编辑器VScode 官网：https://code.visualstudio.com/ 安装VScode（建议附加任务全部勾选） 下载编译器MinGW并解压 官网页面：https://www.mingw-w64.org/ 下载页面：https://sourceforge.net/projects/mingw-w64/files/ -内置了iconv工具 非官方下载页面：MinGW Distro - nuwen.net -此版本未内置iconv工具 你可以进入官网自行寻找 你也可以直接点击为你找好的下载页面 下载页面中选择 x86_64-win32-seh 下载 如果你因为网络环境限制无法下载 不限速下载，请笑纳^-^：https://wwn.lanzouh.com/iLOip031ku6b 密码:1234 在C盘中解压文件 理论上你可以在任何地方解压，但注意路径不能包含中文，至于特殊字符请自行测试 将MinGW添加至环境变量 进入mingw64下的bin文件夹，复制当前路径，Win + i唤起系统设置，输入高级系统设置并进入，点击环境变量，选择path，编辑，新建，粘贴路径，按下三个确定 配置VScode插件 打开VScode安装插件 Chinese 和 C/C++ ，等待安装完毕后重启VScode 切换C/C++插件至 1.8.4 版本（非必要，不过对于小白来说更方便，此版本运行即自动配置） 因最新版本不会自动生成launch.json文件，给后续优化带来不便，故退回旧版本。 运行代码 新建文件夹，修改为英文名称并进入，右键 通过Code打开 若在安装时未勾选相关选项，可能没有这个选项，请自行在VScode内操作打开文件夹 新建一个文件，英文命名且扩展名为 .c 编写相关代码 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ printf(&quot;Hello World!\\n&quot;); printf(&quot;你好世界！\\n&quot;); system(&quot;pause&quot;); // 防止运行后自动退出，需头文件stdlib.h return 0;} VScode菜单栏，点击运行，启动调试，稍等程序运行，输出结果在下方终端，上方调试面板，点击最右边的 橙色方框 停止程序运行 调整和优化 请根据自己的需要进行优化 代码运行后 .vscode 文件夹会自动生成在你的源文件目录下 .vscode 文件夹下的 task.json 和 launch.json 用来控制程序的运行和调试 将程序运行在外部控制台【墙裂推荐】 打开.vscode 文件夹下的 launch.json 文件，找到 &quot;externalConsole&quot;: false, 将 false 改为 true 并保存 解决中文乱码问题【墙裂推荐】| VSCode中解决终端的中文乱码问题 - 我等着你 - 博客园 中文乱码是由于VSC的默认编码格式是UTF-8，那么编译后程序的字符串的保存方式仍然为UTF-8，而CMD的编码方式为GBK。GBK的编码中文和符号是双字节，字符和整型是单字节。utf-8的中文和符号是三字节，字符和整型是单字节，二者的中文字符并不兼容。为解决这个问题，我们需要将二者的编码方式设为相同编码。方法多种多样，最方便、副作用最小的是下面将要介绍的方法： 先了解一下gcc编译选项： -finput-charset:输入字符集设置(需要和源文件编码一致)，告诉编译器以什么样的编码形式读入源文件中的字符串。 -fexec-charset:执行字符集设置(需要设置为当前运行环境支持的编码),告诉编译器在内存中以什么样的编码形式保存字符串。 -fwide-exec-charset:宽字符执行编码(在windows下应设置为utf-16LE)，告诉编译器在内存中以什么样的编码形式保存宽字符串。 修改程序编码方式为GBK： 打开.vscode 文件夹下的 task.json 文件，找到 &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; 在后面加上英文 逗号 然后回车到下一行，粘贴下面文本 &quot;-fexec-charset=GBK&quot; 并保存 编译时用&quot;-fexec-charset=GBK&quot;这个参数（目前的配置是有的），生成的程序的字符串就是GBK编码的，源文件编码格式不会受到影响，仍是UTF-8。 注意：加入此参数需要依赖你下载的mingw内置iconv工具！！！ iconv是一个计算机程序以及一套应用程序编程接口的名称。 作为应用程序的iconv采用命令行界面，允许将某种特定编码的文件转换为另一种编码。 若缺少iconv工具使用了此参数，会出现如下报错： 1no iconv implementation, cannot convert from utf-8 to gbk 收纳生成的 exe 可执行文件【可选】 打开.vscode 文件夹下的 task.json 文件，找到 &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; 修改成 &quot;${fileDirname}\\\\coin\\\\${fileBasenameNoExtension}.exe&quot; 并保存，同理，launch.json 下也有相同的字段，需要你修改 在源文件同目录下新建 coin 文件夹，程序运行后，可执行文件将会生成在里面（其中 coin 可修改成你喜欢的英文名字） 这样 .c 文件一多起来的时候，就不会出现 .exe 和 .c 相互穿插在目录中^-^ ​ 以上优化C++的项目同理，不再演示。 提示 若源代码文件夹含有中文路径，将会无法编译程序。 若你的Windows用户名使用了中文，可能无法运行。","link":"/2022/12/05/VSCode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/01/04/hello-world/"},{"title":"搭建hexo个人博客","text":"简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo安装hexo之前需要安装Nodejs组件，这个在我的另一篇文章： Hexo是我们博客的框架，我们需要在我们的电脑里创建一个文件夹，可以命名为Blog，Hexo框架与你发布的博客网页以后都会在这个文件中。创建好后进入文件夹中，按住shift键，右键鼠标点击打开powershell窗口； 打开后 使用npm命令安装Hexo，命令行窗口输入： 1npm install -g hexo-cli 等待一会儿即可，接着输入命令初始化我们的博客： 1hexo init blog 上面的两个命令都作用于我们刚刚创建的Blog文件夹。 然后我们就可以看到我们的Blog/文件夹目录下会出现一个blog文件夹，接着我们进入blog文件夹； 输入命令： 1cd blog 接下来我们来检测我们网站的雏形，依次输入以下命令； 12345hexo new test_my_sitehexo ghexo s 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。 在浏览器地址窗口输入：localhost:4000 即可访问到我们本地的博客内容。 未经修改过的博客页面应该是上面这个样子的，也可以看到我们刚刚创建的test_my_site这篇文章。 这样就说明我们本地的博客页面是正常的。 现在来介绍常用的Hexo 命令 npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 推送网站刚刚我们看到的只是我们本地的预览，别人并无法访问，接下来要做的就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。 创建Github仓库进入Github网页创建一个新仓库，点击New repository 仓库名为固定格式： Github用户名.github.io 例如我的sxfinn.github.io 我们使用 ssh 免密部署，这种方式可以避免输密码的繁琐，并且速度也是最快的。 创建密钥对为了方便运行 GitHub Actions 时登录 GitHub 账号，我们使用 SSH 方式登录。就是要把设备的私钥交给 GitHub Actions，公钥交给 GitHub，需要去 Settings 里去配置。 进入git bash 123ssh-keygen -t rsa -C &quot;Github的邮箱地址&quot;# 例如 ssh-keygen -t rsa -C &quot;123123123@gmail.com&quot; 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 输入后接着按三个回车 1234567891011121314151617181920212223[root@localhost ~]# ssh-keygen -t rsa &lt;== 建立密钥对，-t代表类型，有RSA和DSA两种Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): &lt;==密钥文件默认存放位置，按Enter即可Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. &lt;== 生成的私钥Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 生成的公钥The key fingerprint is:SHA256:K1qy928tkk1FUuzQtlZK+poeS67vIgPvHw9lQ+KNuZ4 root@localhost.localdomainThe key's randomart image is:+---[RSA 2048]----+| +. || o * . || . .O + || . *. * || S =+ || . =... || .oo =+o+ || ==o+B*o. || oo.=EXO. |+----[SHA256]-----+ 密钥对生成后默认的位置是用户文件。以 windows 为例：密钥对文件在 C:\\Users\\用户名里，其中 Users 可能因为系统原因显示的是用户。这个文件夹里会有一个.ssh 的目录，这个里面就是我们的密钥对。 其中 id_rsa 是私钥，id_rsa.pub 是公钥。 配置公钥，应该已经配好，不然如何上到的项目资源，配置路径：github 网站–&gt;Settings–&gt;SSH and GPG keys 新增一个公钥点击 Add SSH key，然后把 id_rsa.pub 这个文件用文本文档打开，将内容复制进去。 使用下面的命令测试是否成功： 1ssh -T git@github.com 出现如下信息则说明添加成功。 配置部署信息在配置之前我们要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，之后我们对博客配置的修改都是通过此文件来进行的。 如下图： 现在我们要做的就是将Hexo与Github关联起来，打开站点的配置文件_config.yml，下拉到最后修改为： 1234deploy: type: git repo: 你的地址 branch: master 注意：repo一行中“你的地址”，即为你刚刚创建的GitHub仓库的ssh链接。 例如我的： 保存站点配置文件。 我们刚刚配置的文件其实就是在我们执行推送到远端这个hexo d这个命令时，让hexo知道该推送到哪里去，很显然我们部署在我们的GitHub仓库里。 安装Git部署插件，输入命令：（仍然是Blog/blog 目录下） 1npm install hexo-deployer-git --save 一定要记得执行此命令否则无法自动部署。 这时我们输入三条命令： 12345hexo cleanhexo ghexo d 其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即你刚刚创建的仓库名。 你就会发现你的博客已经上线了，可以在网络上被访问了，这与你在本地预览的博客内容是一样的。 绑定域名虽然在网络上已经可以访问到我们的网站了，但我们大多数人都还是想使用自己的个性域名来访问网站的，这就需要绑定我们的域名。接下来我将演示阿里云域名绑定。其他厂商区别也都不大，可以作为参照。 登录到阿里云，进入域名控制台点击解析； 添加解析记录 方案一（建议）：如果是想用主域名和www的域名访问站点 需要添加两个解析记录： 第一个解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的至少一个 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 第二个解析记录的记录类型为CNAME，主机记录为www，记录值为你的新建的仓库名——你的github用户名.github.io 注意：这里直接添加两个CNAME一个类型为@另一个为www都指向 你的github用户名.github.io 也可以的（但主机记录为@的域名添加CNAME记录值可能会有与其他服务，例如电子邮件的冲突问题，因此不建议） 方案二：如果是想使用单独的一个二级域名（包括www域）如blog域名访问站点 Custom domain填入相应域名再添加一个解析记录，记录类型为CNAME，指向 你的github用户名.github.io 即可。 方案三：如果是单独的只想使用主域名访问站点 添加解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的一个至少一个 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 Page的自动双重定向如下图添加了我们填写的Custom domain的解析记录会报错：DNS valid for primary，并且提示我们www域名未正确配置，这是为何？ 带着些历史原因，通常我们的印象中www域名和主域名是访问同一个站点的，大部分网站都这个机制，包括Github Page。 这段时间搞了几种框架的网站建设了，我发现不是域名指向站点的 IP 就能访问站点。 以typecho搭建的网站为例，即使一个域名指向了我们的 IP ，但如果我们的站点中没有保存这个域名的信息，也就是没有添加此域名作为访问站点的域名，那么这个域名仍然无法访问我们的站点，也就是说访问站点时是有域名认证的~，能解析到我的 IP 和站点还不行，我的站点还必须认证了此域名。 利用GitHub page部署网站也有一个这个问题，那就是page的 IP 就那么4个，是如何能够访问我们的站点而不是其他人的站点呢？实际上GitHub是根据我们提交的CNAME去确定我们的站点的，CNAME的值会去填充Custom domain，而这个Custom domain会和我们的站点形成一种绑定关系，我们只有使用这个Custom domain才能正确访问站点。 既然只能通过这一个Custom domain来访问站点，那么Github Page是怎么实现的www域名和主域名都能访问站点这样的机制呢？ 原因是Github Page提供了双重定向的机制。 GitHub Page推荐我们通过DNS提供商在配置一个主域名同时配置一个 www 子域名，这样主域名和www的域名都可以访问站点 如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。 正确配置这两个域名后： 如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 虽然只能填写一个Custom domain，也只能通过此Custom domain访问站点，但是通过DNS提供商对www域名和主域名DNS的正确配置GitHub Page会为我们自动创建双重定向，可以让 非Custom domain：www域 和主域其中一个 重定向到Custom domain，从而能够达到www域名和主域名都能访问站点的效果。而如果使用其他子域名（非www），则只能使用这一个子域名访问站点。自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。 例如，如果您将www.example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，example.com则将重定向到www.example.com,如果您将example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，www.example.com则将重定向到example.com. 正是由于Page支持这样的机制，GitHub Page在我们Custom domain设置为 主域名或者www域名时，会主动检测DNS提供方是否将主域名和www域名都正确配置了（即使我们并不想使用重定向机制），像上图这样只添加了我们填写的Custom domain的这一条xinsong.xyz的解析记录，会提示我们：DNS valid for primary，www.xinsong.xyz就不能正确访问我们的站点，只能通过xinsong.xyz去访问。而如果这里的Custom domain是www.xinsong.xyz，并且也只添加了www的解析记录，那么这里也会提示：**DNS valid for primary，并且报错：xinsong.xyz配置错误，也只能通过www.xinsong.xyz访问站点。如果不想看到Page报错和提示或者想使用双重定向机制，那么按照上面的方案一**做就能正确配置不会报错了。 因此提示 DNS valid for primary 是Github Page主动检查是否满足重定向机制的结果，一旦提示我们DNS valid for primary，说明未能创建双重定向，只有使用当前的Custom domain才能访问我们的站点。 登录GitHub，进入之前创建的仓库，点击setting，设置Custom domain，输入你的域名。 这样就通过我们的个性化域名来访问我们自己的网站了。 但是这样做每次推送到远端时这个Custom domain都会被覆盖，需要重新输入，因此还需要做如下操作： 进入Blog/blog/source目录下，创建一个记事本文件，输入GitHub Page页面的Custom domain。这里建议是带www的域名。 保存即可，命名为CNAME，注意保存类型选择所有文件而不是文本文件。 这样我们每次推送到远端时就可以保证我们始终都能使用此域名进行访问。 然后再进入blog文件中打卡powershell，依次执行： 12345hexo cleanhexo ghexo d 这时候无论怎么折腾，我们在浏览器中输入我们的域名，就可以访问我们的网站了。 最终GitHub Page推荐我们在配置一个主域名的同时配置一个 www 子域名。 如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。 正确配置这两个域名后： 如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 警告：不要在你的 DNS 提供商上为你的自定义主域名创建一个 CNAME 记录！这样做可能会导致与其他服务，如电子邮件等，在该域的问题。 所以根据GitHub Page的官方说明，总结下： 使用子域名时（非www域），建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此子域去访问站点 单独使用主域名时（不配置www域），建议在DNS提供商上为该主域名创建一个 A 记录（CNAME可行，但不建议，可能发生电子邮件及其他服务的冲突问题），那么只能通过此主域访问站点 使用www/主域名时，建议在DNS提供商上为该主域名创建一个 A 记录，在DNS提供商上为该www域名创建一个 CNAME 记录即可自动创建双重定向（定向到我们CNAME文件中的地址，无论CNAME文件为 www.example.com 还是 example.com ），使用www域和主域均可访问站点 单独使用www域时，建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此www域去访问站点 自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。 你可以使用除了 www 以外的一个自定义子域名和一个自定义顶端域名来通过域名重定向（有时候也叫“域名转发”）。但是，请注意，这只能用于用户和组织的 Pages，而不是项目的 Pages。 参考文章： 在你的 DNS 提供者上配置 A 记录的技巧 - GitHub Pages 指南 - UDN开源文档 管理 GitHub Pages 站点的自定义域 - GitHub Docs","link":"/2022/12/05/%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"c","slug":"c","link":"/tags/c/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"inline","slug":"inline","link":"/tags/inline/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"}],"categories":[{"name":"c","slug":"c","link":"/categories/c/"},{"name":"程序设计","slug":"程序设计","link":"/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"cpp","slug":"程序设计/cpp","link":"/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/cpp/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"建站","slug":"建站","link":"/categories/%E5%BB%BA%E7%AB%99/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"Live2D Widget 特性 Feature在网页中添加 Live2D 看板娘。兼容 PJAX，支持无刷新加载。Add Live2D widget to web page. Compatible with PJAX. （注：以上人物模型仅供展示之用，本仓库并不包含任何模型。） 你也可以查看示例网页： 在 米米的博客 的左下角可查看效果 demo.html，展现基础功能 login.html，仿 NPM 的登陆界面 使用 Usage如果你是小白，或者只需要最基础的功能，那么只用将这一行代码加入 html 页面的 head 或 body 中，即可加载看板娘： 1&lt;script src=&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 添加代码的位置取决于你的网站的构建方式。例如，如果你使用的是 Hexo，那么需要在主题的模版文件中添加以上代码。对于用各种模版引擎生成的页面，修改方法类似。如果网站启用了 PJAX，由于看板娘不必每页刷新，需要注意将该脚本放到 PJAX 刷新区域之外。 但是！我们强烈推荐自己进行配置，让看板娘更加适合你的网站！如果你有兴趣自己折腾的话，请看下面的详细说明。 配置 Configuration你可以对照 autoload.js 的源码查看可选的配置项目。autoload.js 会自动加载三个文件：waifu.css，live2d.min.js 和 waifu-tips.js。waifu-tips.js 会创建 initWidget 函数，这就是加载看板娘的主函数。initWidget 函数接收一个 Object 类型的参数，作为看板娘的配置。以下是配置选项： 选项 类型 默认值 说明 waifuPath string https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/waifu-tips.json 看板娘资源路径，可自行修改 apiPath string https://live2d.fghrsh.net/api/ API 路径，可选参数 cdnPath string https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/ CDN 路径，可选参数 tools string[] 见 autoload.js 加载的小工具按钮，可选参数 其中，apiPath 和 cdnPath 两个参数设置其中一项即可。apiPath 是后端 API 的 URL，可以自行搭建，并增加模型（需要修改的内容比较多，此处不再赘述），可以参考 live2d_api。而 cdnPath 则是通过 jsDelivr 这样的 CDN 服务加载资源，更加稳定。 自定义 Customization如果以上「配置」部分提供的选项还不足以满足你的需求，那么你可以自己进行修改。本仓库的目录结构如下： src/waifu-tips.js 包含了按钮和对话框的逻辑； waifu-tips.js 是由 src/waifu-tips.js 自动打包生成的，不建议直接修改； waifu-tips.json 中定义了触发条件（selector，CSS 选择器）和触发时显示的文字（text）； waifu.css 是看板娘的样式表。 waifu-tips.json 中默认的 CSS 选择器规则是对 Hexo 的 NexT 主题 有效的，为了适用于你自己的网页，可能需要自行修改，或增加新内容。警告：waifu-tips.json 中的内容可能不适合所有年龄段，或不宜在工作期间访问。在使用时，请自行确保它们是合适的。 要在本地部署本项目的开发测试环境，你需要安装 Node.js 和 npm，然后执行以下命令： 123git clone https://github.com/stevenjoezhang/live2d-widget.gitnpm installnpm run build 如果有任何疑问，欢迎提 Issue。如果有任何修改建议，欢迎提 Pull Request。 部署 Deploy在本地完成了修改后，你可以将修改后的项目部署在服务器上，或者通过 CDN 加载，以便在网页中使用。 Using CDN要自定义有关内容，可以把这个仓库 Fork 一份，然后把修改后的内容通过 git push 到你的仓库中。这时，使用方法对应地变为 1&lt;script src=&quot;https://fastly.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 将此处的 username 替换为你的 GitHub 用户名。为了使 CDN 的内容正常刷新，需要创建新的 git tag 并推送至 GitHub 仓库中，否则此处的 @latest 仍然指向更新前的文件。此外 CDN 本身存在缓存，因此改动可能需要一定的时间生效。相关文档： Git Basics - Tagging Managing releases in a repository Self-host你也可以直接把这些文件放到服务器上，而不是通过 CDN 加载。 如果你能够通过 ssh 连接你的主机，请把 Fork 并修改后的代码仓库克隆到服务器上。 如果你的主机无法用 ssh 连接（例如一般的虚拟主机），请在本地修改好代码后，通过 ftp 等方式将文件上传到主机的网站的目录下。 如果你是通过 Hexo 等工具部署的静态博客，请把本项目的代码放在博客源文件目录下（例如 source 目录）。重新部署博客时，相关文件就会自动上传到对应的路径下。为了避免这些文件被 Hexo 插件错误地修改，可能需要设置 skip_render。 这样，整个项目就可以通过你的域名访问了。不妨试试能否正常地通过浏览器打开 autoload.js 和 live2d.min.js 等文件，并确认这些文件的内容是完整和正确的。一切正常的话，接下来修改 autoload.js 中的常量 live2d_path 为 live2d-widget 这一目录的 URL 即可。比如说，如果你能够通过 1https://example.com/path/to/live2d-widget/live2d.min.js 访问到 live2d.min.js，那么就把 live2d_path 的值修改为 1https://example.com/path/to/live2d-widget/ 路径末尾的 / 一定要加上。完成后，在你要添加看板娘的界面加入 1&lt;script src=&quot;https://example.com/path/to/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 就可以加载了。 鸣谢 Thanks 感谢 BrowserStack 容许我们在真实的浏览器中测试此项目。Thanks to BrowserStack for providing the infrastructure that allows us to test in real browsers! 感谢 jsDelivr 提供的 CDN 服务。Thanks jsDelivr for providing public CDN service. 代码自这篇博文魔改而来：https://www.fghrsh.net/post/123.html 感谢 一言 提供的语句接口。 点击看板娘的纸飞机按钮时，会出现一个彩蛋，这来自于 WebsiteAsteroids。 更多 More更多内容可以参考：https://nocilol.me/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02https://github.com/xiazeyu/live2d-widget.jshttps://github.com/summerscar/live2dDemo 关于后端 API 模型：https://github.com/xiazeyu/live2d-widget-modelshttps://github.com/xiaoski/live2d_models_collection 除此之外，还有桌面版本：https://github.com/amorist/platelethttps://github.com/akiroz/Live2D-Widgethttps://github.com/zenghongtu/PPethttps://github.com/LikeNeko/L2dPetForMac 以及 Wallpaper Engine：https://github.com/guansss/nep-live2d 许可证 LicenseReleased under the GNU General Public License v3http://www.gnu.org/licenses/gpl-3.0.html 本仓库并不包含任何模型，用作展示的所有 Live2D 模型、图片、动作数据等版权均属于其原作者，仅供研究学习，不得用于商业用途。 Live2D 官方网站：https://www.live2d.com/en/https://live2d.github.io Live2D Cubism Core は Live2D Proprietary Software License で提供しています。https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.htmlLive2D Cubism Components は Live2D Open Software License で提供しています。http://www.live2d.com/eula/live2d-open-software-license-agreement_en.html The terms and conditions do prohibit modification, but obfuscating in live2d.min.js would not be considered illegal modification. https://community.live2d.com/discussion/140/webgl-developer-licence-and-javascript-question 更新 Update2018年10月31日，由 fghrsh 提供的原 API 停用，请更新至新地址。参考文章：https://www.fghrsh.net/post/170.html 2020年1月1日起，本项目不再依赖于 jQuery。 2022年11月1日起，本项目不再需要用户单独加载 Font Awesome。","link":"/live2d-widget/README.html"},{"title":"404","text":"糟糕！出了些偏差！ 您似乎来到了没有知识存在的荒原… 要不，试试搜索？","link":"/404.html"},{"title":"","text":"// live2d_path 参数建议使用绝对路径 //const live2d_path = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\"; const live2d_path = \"/live2d-widget/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { // 配置选项的具体用法见 README.md initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", //apiPath: \"https://live2d.fghrsh.net/api/\", //cdnPath: \"https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\", cdnPath: \"https://npm.elemecdn.com/akilar-live2dapi@latest/\", tools: [\"hitokoto\", \"asteroids\", \"switch-model\", \"switch-texture\", \"photo\", \"info\", \"quit\"] }); }); } console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);","link":"/live2d-widget/autoload.js"},{"title":"","text":"{\"name\":\"live2d-widget\",\"version\":\"0.9.0\",\"description\":\"Live2D widget for web pages\",\"main\":\"autoload.js\",\"type\":\"module\",\"scripts\":{\"build\":\"rollup -c rollup.config.js -f iife | terser -c -m > waifu-tips.js\",\"build-dev\":\"rollup -c rollup.config.js -f iife -o waifu-tips.js -w\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/stevenjoezhang/live2d-widget.git\"},\"keywords\":[\"Live2d\"],\"author\":\"stevenjoezhang \",\"license\":\"GPL-3.0-or-later\",\"bugs\":{\"url\":\"https://github.com/stevenjoezhang/live2d-widget/issues\"},\"homepage\":\"https://github.com/stevenjoezhang/live2d-widget#readme\",\"devDependencies\":{\"@fortawesome/fontawesome-free\":\"^6.2.0\",\"@rollup/plugin-node-resolve\":\"^15.0.0\",\"@rollup/pluginutils\":\"^5.0.1\",\"rollup\":\"^3.2.3\",\"terser\":\"^5.15.1\"}}","link":"/live2d-widget/package.json"},{"title":"","text":"import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { createFilter } from \"@rollup/pluginutils\"; function string(opts = {}) { if (!opts.include) { throw Error(\"include option should be specified\"); } const filter = createFilter(opts.include, opts.exclude); return { name: \"string\", transform(code, id) { if (filter(id)) { return { code: `export default ${JSON.stringify(code)};`, map: { mappings: \"\" } }; } }, renderChunk(code, chunk, outputOptions = {}) { return `/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ ` + code; } }; } export default { input: \"src/waifu-tips.js\", plugins: [nodeResolve(), string({ include: \"**/*.svg\", })] };","link":"/live2d-widget/rollup.config.js"},{"title":"","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t","link":"/live2d-widget/live2d.min.js"},{"title":"","text":"/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ !function(){\"use strict\";function e(e){return Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e}let t;function o(o,s,n){if(!o||sessionStorage.getItem(\"waifu-text\")&&sessionStorage.getItem(\"waifu-text\")>n)return;t&&(clearTimeout(t),t=null),o=e(o),sessionStorage.setItem(\"waifu-text\",n);const i=document.getElementById(\"waifu-tips\");i.innerHTML=o,i.classList.add(\"waifu-tips-active\"),t=setTimeout((()=>{sessionStorage.removeItem(\"waifu-text\"),i.classList.remove(\"waifu-tips-active\")}),s)}class s{constructor(e){let{apiPath:t,cdnPath:o}=e,s=!1;if(\"string\"==typeof o)s=!0,o.endsWith(\"/\")||(o+=\"/\");else{if(\"string\"!=typeof t)throw\"Invalid initWidget argument!\";t.endsWith(\"/\")||(t+=\"/\")}this.useCDN=s,this.apiPath=t,this.cdnPath=o}async loadModelList(){const e=await fetch(`${this.cdnPath}model_list.json`);this.modelList=await e.json()}async loadModel(t,s,n){if(localStorage.setItem(\"modelId\",t),localStorage.setItem(\"modelTexturesId\",s),o(n,4e3,10),this.useCDN){this.modelList||await this.loadModelList();const o=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${o}/index.json`)}else loadlive2d(\"live2d\",`${this.apiPath}get/?id=${t}-${s}`),console.log(`Live2D 模型 ${t}-${s} 加载完成`)}async loadRandModel(){const t=localStorage.getItem(\"modelId\"),s=localStorage.getItem(\"modelTexturesId\");if(this.useCDN){this.modelList||await this.loadModelList();const s=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${s}/index.json`),o(\"我的新衣服好看嘛？\",4e3,10)}else fetch(`${this.apiPath}rand_textures/?id=${t}-${s}`).then((e=>e.json())).then((e=>{1!==e.textures.id||1!==s&&0!==s?this.loadModel(t,e.textures.id,\"我的新衣服好看嘛？\"):o(\"我还没有其他衣服呢！\",4e3,10)}))}async loadOtherModel(){let e=localStorage.getItem(\"modelId\");if(this.useCDN){this.modelList||await this.loadModelList();const t=++e>=this.modelList.models.length?0:e;this.loadModel(t,0,this.modelList.messages[t])}else fetch(`${this.apiPath}switch/?id=${e}`).then((e=>e.json())).then((e=>{this.loadModel(e.model.id,0,e.model.message)}))}}const n={hitokoto:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:function(){fetch(\"https://v1.hitokoto.cn\").then((e=>e.json())).then((e=>{const t=`这句一言来自 「${e.from}」，是 ${e.creator} 在 hitokoto.cn 投稿的。`;o(e.hitokoto,6e3,9),setTimeout((()=>{o(t,4e3,9)}),6e3)}))}},asteroids:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{if(window.Asteroids)window.ASTEROIDSPLAYERS||(window.ASTEROIDSPLAYERS=[]),window.ASTEROIDSPLAYERS.push(new Asteroids);else{const e=document.createElement(\"script\");e.src=\"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\",document.head.appendChild(e)}}},\"switch-model\":{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{}},\"switch-texture\":{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{}},photo:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{o(\"照好了嘛，是不是很可爱呢？\",6e3,9),Live2D.captureName=\"photo.png\",Live2D.captureFrame=!0}},info:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{open(\"https://github.com/stevenjoezhang/live2d-widget\")}},quit:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{localStorage.setItem(\"waifu-display\",Date.now()),o(\"愿你有一天能与重要的人重逢。\",2e3,11),document.getElementById(\"waifu\").style.bottom=\"-500px\",setTimeout((()=>{document.getElementById(\"waifu\").style.display=\"none\",document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\")}),3e3)}}};function i(t){const i=new s(t);function c(t){let s,n=!1,i=t.message.default;window.addEventListener(\"mousemove\",(()=>n=!0)),window.addEventListener(\"keydown\",(()=>n=!0)),setInterval((()=>{n?(n=!1,clearInterval(s),s=null):s||(s=setInterval((()=>{o(i,6e3,9)}),2e4))}),1e3),o(function(e){if(\"/\"===location.pathname)for(let{hour:t,text:o}of e){const e=new Date,s=t.split(\"-\")[0],n=t.split(\"-\")[1]||s;if(s{for(let{selector:n,text:i}of t.click)if(s.target.matches(n))return i=e(i),i=i.replace(\"{text}\",s.target.innerText),void o(i,4e3,8)})),t.seasons.forEach((({date:t,text:o})=>{const s=new Date,n=t.split(\"-\")[0],c=t.split(\"-\")[1]||n;n.split(\"/\")[0]{document.hidden||o(t.message.visibilitychange,6e3,9)}))}localStorage.removeItem(\"waifu-display\"),sessionStorage.removeItem(\"waifu-text\"),document.body.insertAdjacentHTML(\"beforeend\",'\\n \\n \\n \\n '),setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0),function(){n[\"switch-model\"].callback=()=>i.loadOtherModel(),n[\"switch-texture\"].callback=()=>i.loadRandModel(),Array.isArray(t.tools)||(t.tools=Object.keys(n));for(let e of t.tools)if(n[e]){const{icon:t,callback:o}=n[e];document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\",`${t}`),document.getElementById(`waifu-tool-${e}`).addEventListener(\"click\",o)}}(),function(){let e=localStorage.getItem(\"modelId\"),o=localStorage.getItem(\"modelTexturesId\");null===e&&(e=1,o=53),i.loadModel(e,o),fetch(t.waifuPath).then((e=>e.json())).then(c)}()}window.initWidget=function(e,t){\"string\"==typeof e&&(e={waifuPath:e,apiPath:t}),document.body.insertAdjacentHTML(\"beforeend\",'\\n 看板娘\\n ');const o=document.getElementById(\"waifu-toggle\");o.addEventListener(\"click\",(()=>{o.classList.remove(\"waifu-toggle-active\"),o.getAttribute(\"first-time\")?(i(e),o.removeAttribute(\"first-time\")):(localStorage.removeItem(\"waifu-display\"),document.getElementById(\"waifu\").style.display=\"\",setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0))})),localStorage.getItem(\"waifu-display\")&&Date.now()-localStorage.getItem(\"waifu-display\"){o.classList.add(\"waifu-toggle-active\")}),0)):i(e)}}();","link":"/live2d-widget/waifu-tips.js"},{"title":"","text":"{\"mouseover\":[{\"selector\":\"#live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool-hitokoto\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool-asteroids\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool-switch-model\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool-switch-texture\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool-photo\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool-info\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool-quit\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home a\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about a\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags a\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\"]},{\"selector\":\".menu-item-categories a\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\"]},{\"selector\":\".menu-item-archives a\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\"]},{\"selector\":\".menu-item-friends a\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search a\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".menu-item a\",\"text\":[\"快看看这里都有什么呢？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\".followme\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".copy-btn\",\"text\":[\"代码可以直接点击复制哟。\"]},{\"selector\":\".highlight .table-container, .gist\",\"text\":[\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".beian a\",\"text\":[\"我也是有户口的人哦。\",\"我的主人可是遵纪守法的好主人。\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}],\"time\":[{\"hour\":\"6-7\",\"text\":\"早上好！一日之计在于晨，美好的一天就要开始了～\"},{\"hour\":\"8-11\",\"text\":\"上午好！工作顺利嘛，不要久坐，多起来走动走动哦！\"},{\"hour\":\"12-13\",\"text\":\"中午了，工作了一个上午，现在是午餐时间！\"},{\"hour\":\"14-17\",\"text\":\"午后很容易犯困呢，今天的运动目标完成了吗？\"},{\"hour\":\"18-19\",\"text\":\"傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～\"},{\"hour\":\"20-21\",\"text\":\"晚上好，今天过得怎么样？\"},{\"hour\":\"22-23\",\"text\":[\"已经这么晚了呀，早点休息吧，晚安～\",\"深夜时要爱护眼睛呀！\"]},{\"hour\":\"0-5\",\"text\":\"你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？\"}],\"message\":{\"default\":[\"好久不见，日子过得好快呢……\",\"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\",\"嗨～快来逗我玩吧！\",\"拿小拳拳锤你胸口！\",\"记得把小家加入收藏夹哦！\"],\"console\":\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\",\"copy\":\"你都复制了些什么呀，转载要记得加上出处哦！\",\"visibilitychange\":\"哇，你终于回来了～\"}}","link":"/live2d-widget/waifu-tips.json"},{"title":"","text":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 12px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; /*left: 0;*/ right: 15px; line-height: 0; margin-bottom: -10px; position: fixed; transform: translateY(3px); transition: transform .3s ease-in-out, bottom 3s ease-in-out; z-index: 1000; } #waifu:hover { transform: translateY(0); } #waifu-tips { animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #live2d { cursor: grab; height: 300px; position: relative; width: 300px; } #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; right: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { display: block; height: 30px; text-align: center; } #waifu-tool svg { fill: #7b8c9d; cursor: pointer; height: 25px; transition: fill .3s; } #waifu-tool svg:hover { fill: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }","link":"/live2d-widget/waifu.css"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"Live2D 看板娘 / Demo #github svg { transition: all 1s; fill: #222; color: #fff; position: absolute; top: 0; right: 0; border: 0; width: 80px; height: 80px; } #github:hover svg { width: 160px; height: 160px; }","link":"/live2d-widget/demo/demo.html"},{"title":"","text":"import Model from \"./model.js\"; import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; import tools from \"./tools.js\"; function loadWidget(config) { const model = new Model(config); localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); (function registerTools() { tools[\"switch-model\"].callback = () => model.loadOtherModel(); tools[\"switch-texture\"].callback = () => model.loadRandModel(); if (!Array.isArray(config.tools)) { config.tools = Object.keys(tools); } for (let tool of config.tools) { if (tools[tool]) { const { icon, callback } = tools[tool]; document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\", `${icon}`); document.getElementById(`waifu-tool-${tool}`).addEventListener(\"click\", callback); } } })(); function welcomeMessage(time) { if (location.pathname === \"/\") { // 如果是主页 for (let { hour, text } of time) { const now = new Date(), after = hour.split(\"-\")[0], before = hour.split(\"-\")[1] || after; if (after userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(messageArray, 6000, 9); }, 20000); } }, 1000); showMessage(welcomeMessage(result.time), 7000, 11); window.addEventListener(\"mouseover\", event => { for (let { selector, text } of result.mouseover) { if (!event.target.closest(selector)) continue; if (lastHoverElement === selector) return; lastHoverElement = selector; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); window.addEventListener(\"click\", event => { for (let { selector, text } of result.click) { if (!event.target.closest(selector)) continue; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); result.seasons.forEach(({ date, text }) => { const now = new Date(), after = date.split(\"-\")[0], before = date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] { if (!document.hidden) showMessage(result.message.visibilitychange, 6000, 9); }); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 1; // 模型 ID modelTexturesId = 53; // 材质 ID } model.loadModel(modelId, modelTexturesId); fetch(config.waifuPath) .then(response => response.json()) .then(registerEventListener); })(); } function initWidget(config, apiPath) { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); const toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } } export default initWidget;","link":"/live2d-widget/src/index.js"},{"title":"","text":"import randomSelection from \"./utils.js\"; let messageTimer; function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); const tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } export default showMessage;","link":"/live2d-widget/src/message.js"},{"title":"","text":"看板娘登陆平台 html, body { height: 100%; } body { display: flex; align-items: center; justify-content: center; padding-top: 40px; padding-bottom: 40px; background-color: #f5f5f5; } .form-signin { width: 100%; max-width: 330px; padding: 15px; margin: 0 auto; } .form-signin .checkbox { font-weight: 400; } .form-signin .form-control { position: relative; box-sizing: border-box; height: auto; padding: 10px; font-size: 16px; } .form-signin .form-control:focus { z-index: 2; } .form-signin input[type=text] { margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .form-signin input[type=password] { margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; } #stage { position: relative; } #stage img { width: 100%; margin-bottom: 20px; border-radius: 20px; } #stage button { position: absolute; padding: 0; } #inner { position: relative; background-color: #999; clip-path: circle(120px at center); } #cover { position: absolute; background-color: #CB3837; width: 100%; height: 100%; bottom: 10%; transition: all 1s; box-shadow: 0 0 0 5px rgba(0, 0, 0, .1); } #text { position: absolute; bottom: 30%; font-size: 2em; left: 50%; transform: translateX(-50%); opacity: 0.4; font-weight: bold; } #detail { position: absolute; background: rgba(255, 255, 255, .1); width: 100%; height: 10px; bottom: 0; } #handle { position: absolute; background: #ccc; bottom: -2px; box-shadow: 0 1px 0 1px rgba(0, 0, 0, .1); height: 8px; left: 50%; margin-left: -15px; width: 30px; cursor: pointer; } #info { left: 40px; bottom: 20px; } #refresh { right: 40px; bottom: 20px; } #live2d { cursor: grab; height: 300px; width: 300px; } #live2d:active { cursor: grabbing; } MIMIPOWERED 看板娘登陆平台 用户名 密码 记住我 登录 Copyleft &copy; Mimi 2019 /* * _(:з」∠)_ * Created by Shuqiao Zhang in 2019. * https://zhangshuqiao.org */ /* * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */ window.addEventListener(\"load\", () => { \"use strict\"; if (!CSS.supports(\"clip-path\", \"circle(120px at center)\")) { document.getElementById(\"stage\").innerHTML = ''; return; } const apiPath = \"https://live2d.fghrsh.net/api\"; let state = 0, loading = false, modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { modelId = 1; modelTexturesId = 53; } loadModel(modelId, modelTexturesId); function loadModel(modelId, modelTexturesId) { localStorage.setItem(\"modelId\", modelId); if (modelTexturesId === undefined) modelTexturesId = 0; localStorage.setItem(\"modelTexturesId\", modelTexturesId); loadlive2d(\"live2d\", `${apiPath}/get/?id=${modelId}-${modelTexturesId}`, null); console.log(\"live2d\", `模型 ${modelId}-${modelTexturesId} 加载完成`); setTimeout(() => { coverPosition(\"80%\"); state = 2; }, 2000); } function loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); fetch(`${apiPath}/rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { loadModel(modelId, result.textures.id); setTimeout(() => { state = 2; coverPosition(\"80%\"); loading = false; }, 1000); }); } function loadOtherModel() { const modelId = localStorage.getItem(\"modelId\"); fetch(`${apiPath}/switch/?id=${modelId}`) .then(response => response.json()) .then(result => { loadModel(result.model.id); }); } function coverPosition(pos) { document.getElementById(\"cover\").style.bottom = pos; } document.getElementById(\"info\").addEventListener(\"click\", () => { fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { alert(\"「\" + result.hitokoto + \"」——\" + result.from); }); }); document.getElementById(\"refresh\").addEventListener(\"click\", () => { if (loading) return; state = 0; coverPosition(\"10%\"); loading = true; setTimeout(loadRandModel, 1000); }); document.getElementById(\"handle\").addEventListener(\"click\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } else if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"focus\", () => { if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"blur\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } }); });","link":"/live2d-widget/demo/login.html"},{"title":"","text":"import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; class Model { constructor(config) { let { apiPath, cdnPath } = config; let useCDN = false; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } else if (typeof apiPath === \"string\") { if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; } else { throw \"Invalid initWidget argument!\"; } this.useCDN = useCDN; this.apiPath = apiPath; this.cdnPath = cdnPath; } async loadModelList() { const response = await fetch(`${this.cdnPath}model_list.json`); this.modelList = await response.json(); } async loadModel(modelId, modelTexturesId, message) { localStorage.setItem(\"modelId\", modelId); localStorage.setItem(\"modelTexturesId\", modelTexturesId); showMessage(message, 4000, 10); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); } else { loadlive2d(\"live2d\", `${this.apiPath}get/?id=${modelId}-${modelTexturesId}`); console.log(`Live2D 模型 ${modelId}-${modelTexturesId} 加载完成`); } } async loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); showMessage(\"我的新衣服好看嘛？\", 4000, 10); } else { // 可选 \"rand\"(随机), \"switch\"(顺序) fetch(`${this.apiPath}rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { if (result.textures.id === 1 && (modelTexturesId === 1 || modelTexturesId === 0)) showMessage(\"我还没有其他衣服呢！\", 4000, 10); else this.loadModel(modelId, result.textures.id, \"我的新衣服好看嘛？\"); }); } } async loadOtherModel() { let modelId = localStorage.getItem(\"modelId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const index = (++modelId >= this.modelList.models.length) ? 0 : modelId; this.loadModel(index, 0, this.modelList.messages[index]); } else { fetch(`${this.apiPath}switch/?id=${modelId}`) .then(response => response.json()) .then(result => { this.loadModel(result.model.id, 0, result.model.message); }); } } } export default Model;","link":"/live2d-widget/src/model.js"},{"title":"","text":"import fa_comment from \"@fortawesome/fontawesome-free/svgs/solid/comment.svg\"; import fa_paper_plane from \"@fortawesome/fontawesome-free/svgs/solid/paper-plane.svg\"; import fa_user_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-user.svg\"; import fa_street_view from \"@fortawesome/fontawesome-free/svgs/solid/street-view.svg\"; import fa_camera_retro from \"@fortawesome/fontawesome-free/svgs/solid/camera-retro.svg\"; import fa_info_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-info.svg\"; import fa_xmark from \"@fortawesome/fontawesome-free/svgs/solid/xmark.svg\"; import showMessage from \"./message.js\"; function showHitokoto() { // 增加 hitokoto.cn 的 API fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { const text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } const tools = { \"hitokoto\": { icon: fa_comment, callback: showHitokoto }, \"asteroids\": { icon: fa_paper_plane, callback: () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { const script = document.createElement(\"script\"); script.src = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\"; document.head.appendChild(script); } } }, \"switch-model\": { icon: fa_user_circle, callback: () => {} }, \"switch-texture\": { icon: fa_street_view, callback: () => {} }, \"photo\": { icon: fa_camera_retro, callback: () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; } }, \"info\": { icon: fa_info_circle, callback: () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); } }, \"quit\": { icon: fa_xmark, callback: () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.bottom = \"-500px\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); } } }; export default tools;","link":"/live2d-widget/src/tools.js"},{"title":"","text":"function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } export default randomSelection;","link":"/live2d-widget/src/utils.js"},{"title":"","text":"import initWidget from \"./index.js\"; window.initWidget = initWidget;","link":"/live2d-widget/src/waifu-tips.js"}]}