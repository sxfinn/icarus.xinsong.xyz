{"posts":[{"title":"C++类和对象下","text":"再谈构造函数之前讲过构造函数的一些特性，再在这里补充下。 构造函数体赋值1234567891011121314class Date{public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; }private: int _year; int _month; int _day;}; 在程序进入函数体时，成员变量的初始化实际上已经完成，具有了初始值，虽然为构造函数的函数体，可实际函数体的赋值操作并不是对成员的初始化，而只能算是对成员的赋值操作。并且初始化操作只能由一次而在函数体内却可对一个变量多次赋值，因此函数体内的赋值操作不能称为初始化操作。 初始化列表 初始化列表：以一个冒号开始，接着是以逗号分隔每个成员列表，每个成员变量后跟一个括号，括号内为需要初始化的初值或者表达式。 1234567891011121314151617181920class Stack{public: Stack() : _size(0), _capacity(4),//初值 _p((int*)malloc(sizeof(int) * _capacity))//表达式 {} private: int _size; int _capacity; int* _p;};int main(){ Stack s; return 0;} 至于初始化列表是什么，其实就是类的对象的成员定义的地方。 对象的定义大致三个过程： 为类的对象分配内存空间（对象的空间） 在分得的内存空间的基础上初始化成员变量（初始化列表、初始化对象） 初始化结束，对成员变量的赋值（函数体） 例如Date d1(2001,7,28); 可以先视作为d1分配空间，然后在此空间的基础上走Date构造的初始化列表，初始化列表结束，即初始化结束。 【注意事项】： 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次) 类中包含以下成员，必须放在初始化列表位置显式进行初始化： 引用成员变量 const成员变量 自定义成员变量（该类没有默认构造函数） 123456789101112131415161718192021222324252627282930class A{public: A(int a) : _a(a) {}private: int _a;};int global = 0;class B{public: B(int b , int aa) : _b(b), _aa(aa), _ref(global) {}private: const int _b;//const int&amp; _ref;//引用 A _aa;//没有默认构造函数};int main(){ B tmp(1, 2); return 0;} 尽量使用初始化列表初始化，因为不论你是否使用初始化列表，对于自定义类型成员变量，一定会在初始化列表中初始化。通俗来讲就是初始化列表是一定会走一遍的，我们使用初始化列表只是显式的去调用。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Time{public: Time(int hour = 0) :_hour(hour) { cout &lt;&lt; &quot;Time()&quot; &lt;&lt; endl; }private: int _hour;};class Date{public: Date(int day) {}private: int _day; Time _t;};int main(){ Date d(1);} 在Date的构造函数中我们并没有使用初始化列表，但仍然会在初始化列表里调用_t的默认构造函数，而至于为什么初始化列表不去处理内置类型，可以这样理解： 在普通的定义int类型时通常会这样定义： int a = 10;或者int a;，第一个会将a初始化为10，第二个则是随机值。 不过也可以用类似于定义自定义类型的方式去定义： int a(10);显式调用int的构造函数 注意：不存在int a();这样的定义方式，会被当做函数声明（但在初始化列表里可以写括号但无参，因为初始化列表变量前不带类型，不会被当做函数声明） 虽然无法像上面这样但有一个匿名变量的写法： int();，像这样子写会创建一个临时变量，并且值为0，而这和自定义类型的匿名对象方式一样，所以可以看成是调用了int的默认构造，而int的默认构造默认初始化成0值。 所以！！！大致可认为内置类型的变量有两种初始化方法： 调用了默认构造定义的定义方式；（不给值默认初始化为0） 采用普通的定义方式；（不给值默认随机值） 在类的构造函数的初始化列表中，如果我们没有显式的去初始化内置类型变量，都是默认以普通的方式去定义内置类型，而不是调用内置类型的默认构造函数，而当我们初始化列表中显式的初始化内置类型时，可以看作调用了其构造函数并且可以给初值，而不再使用其默认的普通定义方式。 （注：在初始化列表中初始化内置类型如果括号里不给值，会被初始化为0，也可以看作是调用了默认构造函数，默认构造默认值为0） 如下： 1234567891011121314151617181920212223class Time{public: Time(int hour = 0) :_hour(hour) { cout &lt;&lt; &quot;Time()&quot; &lt;&lt; endl; }private: int _hour;};class Date{public: Date(int day) : _day(),//内置类型和自定义类型都支持这样地无参初始化，调用了默认构造 _t()//调用默认构造函数 {}private: int _day; Time _t;}; （个人认为如果这里能把内置类型也在初始化列表也处理了就完美了，既方便又好理解） 总结：只要调用了构造函数，就会走一遍初始化列表！！！ 对于内置类型： ​ 不显式的去初始化内置类型，走的是默认的普通内置类型定义方式； ​ 显式的去初始化内置类型，走的是内置类型的构造函数，即使不给初值也会是零！ 对于自定义类型： ​ 不显式的去初始化自定义类型，走的是调用其默认构造； ​ 显式的去初始化自定义类型，走的是调用其默认构造，并且可以给初始化值； 初始化列表的初始化顺序成员变量在类中的声明次序就是其在初始化列表中初始化的次序，而与其初始化列表的先后顺序无关。 1234567891011121314151617181920class A{public: A(int a) :_a1(a) , _a2(_a1) {} void Print() { cout &lt;&lt; _a1 &lt;&lt; &quot; &quot; &lt;&lt; _a2 &lt;&lt; endl; }private: int _a2; int _a1;};int main() { A aa(1); aa.Print();} 以上程序会输出什么？ A.输出1 1B.程序崩溃C.编译不通过D.输出1 随机值 答案是D，根据声明顺序初始化列表一定会先初始化_a2，再初始化 _a1，而使用_a1初始化_a2时 _a1还是随机值，因此_a会被初始化成随机值，而_a1会被初始化为a的值——1； explicit关键字构造函数不仅可以初始化对象，对于单个参数的构造函数，还具有类型转换的作用。 12345678910111213141516171819202122class Date{public: Date(int year) :_year(year) {} explicit Date(int year) :_year(year) {}private: int _year; int _month; int _day;};int main(){ Date d1(2018); // 用一个整形变量给日期类型对象赋值 // 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值 d1 = 2019;//有explicit修饰构造函数，2019就无法发生隐式转换，这里会报错； Date d2 = 2020;//同理} 上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。 如果没有explicit修饰构造函数的话，这里单参构造函数的隐式转换的过程是先将使用2020构造出一个Date临时对象，再调用拷贝构造去对d1进行拷贝，不过经过编译器的优化，通常会将 构造+拷贝构造 优化成 直接使用2020构造d1. static成员static修饰全局函数，会改变其链接属性，修饰局部变量，会改变其生命周期。 在类中的static成员有什么作用呢？ 概念 声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化。 static有什么特别之处？来看一个题 实现一个类，计算中程序中创建出了多少个类对象。 思路：创建类那么一定会调用构造函数，因此从构造函数和拷贝构造调用了多少次入手，考虑定义一个静态的成员变量_scount，每调用一次构造函数，都执行一次 s_count++操作，再定义一个函数，用于返回静态变量。 12345678910111213141516class A{public: A() { ++_scount; } A(const A&amp; t) { ++_scount; } static int GetACount() { return _scount; }private: static int _scount;};int A::_scount = 0;int main(){ A a[10]; cout &lt;&lt; A::GetACount() &lt;&lt; endl; return 0;} 特性 静态成员属于整个类，因此被所有类对象所共享，而不属于某个对象； 静态成员变量必须在类外定义，定义时不添加static关键字，需要指定类域； 类静态成员可用类名::静态成员或者对象.成员来访问； 静态成员函数没有隐含的this指针，不能访问任何非静态函数； 静态成员和类的普通成员一样，也有public、private、protected三种访问级别； 对于静态成员函数，不需要使用对象去调用，而是只要突破了类域限制，就能访问静态成员，对于以上5个特性我们可以尝试解释： 对于静态成员变量，static修饰会让其生命周期延长（存储于静态区，也叫做数据段），因此需要单独类外定义，类的对象定义时调用构造函数的初始化列表不包括静态成员变量，静态成员变量不属于某个对象； 对于静态成员函数，形参列表中没有隐含的this指针，因此不需要对象的地址就能调用，而非静态成员函数由于this指针的存在，即使突破了类域，却仍需要对象的地址才能调用； 【问题】 静态成员函数可以调用非静态成员函数吗？ 非静态成员函数可以调用类的静态成员函数吗？ 答：静态成员函数不能调用类的非静态成员函数，因为静态成员函数形参没有this指针，而调用非静态成员函数需要传值给this指针。 ​ 非静态成员函数可以调用类的静态成员函数，调用静态成员函数，突破类域即可。 我们前面已经学过static修饰全局函数会改变其链接属性，只能在定义的源文件被调用，那这里被static修饰的成员函数会被改变链接属性吗？ 我尝试了一下如下代码： 12345678910111213141516171819202122232425262728293031//test.hclass Date{public: Date() : _year(1), _month(1), _day(1) {} static void test();private: int _year; int _month; int _day;};//test.cpp#include&quot;date.h&quot;void Date::test(){ cout &lt;&lt; &quot;test()&quot; &lt;&lt; endl;}//main.cpp#include&quot;date.h&quot;int main(){ Date::test(); return 0;} 可以正常编译运行调用test函数，但如果test是全局函数，则只能在定义test函数的源文件才能调用test函数，因此static修饰全局函数和修饰成员函数是完全不同的。 总结： static修饰类的成员函数，不改变链接属性，仅仅影响隐含的this指针； static修饰全局函数，改变其链接属性； C++11的成员初始化新玩法 C++支持非静态的成员变量在声明时进行初始化赋值，但是这里不是真正意义上的赋值，这里仅仅只声明，给声明的成员变量缺省值（默认值或者表达式）。 如下： 123456789101112131415161718class Stack{public: Stack() : _capacity(8)//这里_capacity会被初始化为8而不是4，我们显式初始化默认值无效。 {}private: //非静态成员变量 int _size = 0;//初始化列表中使用_size(0)初始化 int _capacity = 4; int* _p = (int*)malloc(sizeof(int) * _capacity);//初始化列表中使用_size(malloc)初始化};int main(){ Stack s; return 0;} 实际上这个缺省值是初始化列表的缺省值，对象定义时调用构造函数，初始化列表就会使用这些缺省值去初始化成员变量，而如果我们自己也写了初始化列表那么缺省值就被覆盖，使用我们给的值去初始化。 总结：类的非静态成员变量声明所给的缺省值，实际上是初始化列表的缺省值，我们不写初始化列表，才会使用这些默认值初始化成员。 值得一提的是只要这个类中有指针类型，那么从一进入构造函数时，在调试窗口看每个成员变量的值都默认为0，直到我们去在初始化列表初始化或者函数体内赋值，用意是什么我也不清楚，可能是为了防止未正确初始化指针变量导致的野指针问题，奇怪奇怪。 友元 友元分为友元函数和友元类 友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。 例如一些我们定义的全局函数为了能突破类的封装，可以定义为友元函数。 友元一定是万不得已才使用，毕竟会打破封装。 友元函数问题：现在我们尝试去重载operator&lt;&lt;，然后发现我们没办法将operator&lt;&lt;重载成成员函数。因为cout的输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要作为第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。 12345678910111213141516171819202122232425class Date{public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) {} ostream&amp; operator&lt;&lt;(ostream&amp; _cout) { _cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day; return _cout; }private: int _year; int _month; int _day;};int main(){ Date d(2001, 7, 28); d &lt;&lt; cout; return 0;} 友元函数是定义在类外部的全局函数，不属于任何类，可以直接访问类的私有成员，但需要在类的内部声明，声明需要加上friend关键字。 12345678910111213141516171819202122232425262728293031323334class Date{ friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);public: Date(int year, int month, int day) : _year(year) , _month(month) , _day(day) {}private: int _year; int _month; int _day;};ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d){ _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day; return _cout;}istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d){ _cin &gt;&gt; d._year; _cin &gt;&gt; d._month; _cin &gt;&gt; d._day; return _cin;}int main(){ Date d(2001, 7, 28); cin &gt;&gt; d; cout &lt;&lt; d; return 0;} 需要注意的几点： 友元函数可访问类的私有和保护成员，但不是类的成员函数； 友元函数不能用const修饰； 友元函数可以在类定义的任何地方声明，不受类访问限定符的限制； 一个函数可以是多个类的友元； 友元函数的调用与普通函数的调用和原理相同； 友元类友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的非公有成员。 友元关系是单向的，不具有交换性。 ​ 比如下面的这段代码：Date是Time类的友元类，那么可以在Date类的成员函数中直接访问Time类的私有和保护成员，但是想在Time类中访问Date类的私有成员变量则不行。 友元关系不能传递。 ​ 如果B是A的友元，C是B的友元，则无法说C是A的友元。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Date; // 前置声明class Time{ friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量public: Time(int hour = 12, int minute = 0, int second = 0) : _hour(hour) , _minute(minute) , _second(second) {}private: int _hour; int _minute; int _second;};class Date{public: Date(int year = 1900, int month = 1, int day = 1) : _year(year), _month(month), _day(day) {} void SetTimeOfDate(int hour, int minute, int second) { // 直接访问时间类私有的成员变量 _t._hour = hour; _t._minute = minute; _t._second = second; }private: int _year; int _month; int _day; Time _t;};int main(){ Date d; d.SetTimeOfDate(0, 0, 0); return 0;} 内部类概念及特性概念：如果一个类定义在另一个类的内部，这个内部的类就叫做内部类。注意此时的内部类是一个独立的类，它不属于任何类，不属于外部类，外部的类对内部类没有任何优越的访问权限，不能通过外部类的对象去调用内部类。 注意：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。 特性： 内部类可以定义在外部类的public、protected、private都是可以的。 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 sizeof(外部类)=外部类对象大小，和内部类没有任何关系。 1234567891011121314151617181920212223class A{private: static int k; int h;public: class B { public: void foo(const A&amp; a) { cout &lt;&lt; k &lt;&lt; endl;//OK cout &lt;&lt; a.h &lt;&lt; endl;//OK } };};int A::k = 1;int main(){ A::B b;//使用内部类去初始化一个对象 b.foo(A()); return 0;} 访问限定符对内部类的修饰和对类的成员变量和成员函数的作用是一样的，外部类私有的内部类是无法在外部类的外部被使用的，只能使用外部类的成员函数去使用内部类。 再次理解封装C++是基于面向对象的程序，面向对象有三大特性：继承、封装、多态。 C++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起；通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。 下面举个例子来让大家更好的理解封装性带来的好处，比如：乘火车出行。 无规矩不成方圆，正是因为火车站大家都默默得遵守规矩，大家才能出行更安全便捷，来看看火车站的程序： 售票系统：出售火车票，并提供选座服务，用户凭借票进入对号入座。 工作人员：售票、咨询服务、安检、卫生。 火车：运送乘客到目的地。 在整个系统中，每个部分、工作人员、乘客必须配合起来，才能让出行有条不紊，乘客不需要知道售票系统的运作方式，不需要知道火车的构造，按照提示和规范操作即可。 想下，如果是没有任何管理的开放性站台呢？ 火车站没有围墙，站内火车管理调度也是随意，乘车也没有规矩，比如： 那么这样没有了外界的约束，没有了规矩，那又怎么能保证每个人都是有良好素质的呢？那么我们出行的安全、准时、便捷都会被影响。 再次理解面向对象概念：面向对象程序设计(英语：Object-oriented programming,缩写：OOP)是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类(css)的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。 面向对象技术简介 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 上面的简介或许不够直观，面向对象具体是什么呢？和面向过程有何区别？我们以外卖小哥送餐为例子。 现在我们点外卖只需要打开APP，进行点餐操作在家中等待就可以了。 那么商家就会开始制作，外卖小哥接单后就会开始前往商家取餐，最终送达到我们手中。 在手机上我们可以看到外卖小哥的送餐轨迹和商家的制作进度，这些都是三者之间的信息传递而达到的，手机上展现的是模拟现实。 外卖小哥、商家、用户都对应着不同的类。而每一个商家、外卖小哥、用户都是相应类实例化出的对象，通过它们之间的交互共同作用构成外卖系统。 面向对象旨在关注每一个对象，而不是某一个过程，传统的面向过程映射的是送餐的过程、点餐的过程以及制作的过程，而面向对象是通过对象，模拟对象的行为，如商家要制作餐点，用户要点餐，外卖小哥要送餐。 总之，面向对象就是对现实世界的模拟，通过实例化出对象，模拟对象的行为，达到我们的目的。","link":"/2023/01/12/C++/10.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"C++实现日期类","text":"日期类的实现在前面学过默认成员函数后，我们就可以写一个简单的日期类了。 如何写呢？我们可以先分析分析。 日期类的成员变量都是int类型，那么构造函数是要显式定义的，成员变量都是int类型，因此浅拷贝即可。 因此拷贝构造、析构、赋值操作符重载都不需要我们显式定义，使用编译器生成的就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;iostream&gt;using namespace std;int MonthDay[13] = { 0, 31,28,31,30,31,30,31,31,30,31,30,31 };bool IsLeapYear(int year){ if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) return true; else return false;}class Date{public: int GetDay(int year, int month)const { if (IsLeapYear(year) &amp;&amp; month == 2) return 29; else return MonthDay[month]; } Date(int year = 1, int month = 1, int day = 1) :_year(year), _month(month), _day(day) { if (year &lt;= 0 || (month &lt; 0 || month &gt;= 13) || day &gt; GetDay(year, month)) { cout &lt;&lt; &quot;日期错误&quot; &lt;&lt; endl; cout &lt;&lt; year &lt;&lt; &quot;-&quot; &lt;&lt; month &lt;&lt; &quot;-&quot; &lt;&lt; day &lt;&lt; endl; exit(-1); } } void swap(Date&amp; d) { ::swap(_year, d._year); ::swap(_month, d._month); ::swap(_day, d._day); } Date&amp; operator+=(int day) { if (day &lt; 0) { return *this -= -day; } _day += day; while (_day &gt; GetDay(_year, _month)) { _day -= GetDay(_year, _month); _month++; if (_month &gt; 12) { _month = 1; _year++; } } return *this; } Date operator+(int day) { return Date(*this) += day; } Date&amp; operator-=(int day) { if (day &lt; 0) { return *this += -day; } _day -= day; while (_day &lt; 1) { _month--; if (_month &lt; 1) { _year--; _month = 12; } _day += GetDay(_year, _month); } return *this; } Date operator-(int day) { return Date(*this) -= day; } bool operator&gt;(const Date&amp; d)const { if (_year &gt; d._year || _year == d._year &amp;&amp; _month &gt; d._month || _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day) return true; else return false; } bool operator&gt;=(const Date&amp; d)const { return *this &gt; d || *this == d; } bool operator==(const Date&amp; d)const { return _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day; } bool operator!=(const Date&amp; d)const { return !(*this == d); } bool operator&lt;(const Date&amp; d)const { return !(*this &gt;= d); } bool operator&lt;=(const Date&amp; d)const { return *this &lt; d || *this == d; } Date&amp; operator++() { *this += 1; return *this; } Date operator++(int) { Date ret(*this); *this += 1; return ret; } Date&amp; operator--() { *this -= 1; return *this; } Date operator--(int) { Date ret(*this); *this -= 1; return ret; } int operator-(const Date&amp; d)const { Date d1(*this); Date d2(d); int flag = -1; int ret = 0; int num1 = 0; int num2 = 0; if (d1 &gt; d2) { d1.swap(d2); flag = 1; } for (int i = 1; i &lt; d1._month; i++) { num1 += GetDay(d1._year, i); } num1 += d1._day; for (int i = 1; i &lt; d2._month; i++) { num2 += GetDay(d2._year, i); } num2 += d2._day; for (int i = d1._year; i &lt; d2._year; i++) { ret += 365; if (IsLeapYear(i)) ret++; } ret = ret + num2 - num1; return ret * flag; } ostream&amp; operator&lt;&lt;(ostream&amp; out,const Date&amp; d)//定义在外部的 { out &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day &lt;&lt; endl; return out; } istream&amp; operator&gt;&gt;(istream&amp; in, const Date&amp; d)//定义在外部的 { in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day; return in; }private: int _year; int _month; int _day;}; 代码不难，但可能会遇到一些细节处理上的问题。 一些问题前置++与后置++的重载C++中如何区分两者呢，两者的函数名（操作符）作用对象（形参）都是一样的； 因此C++规定了让后置++多一个int参数，用于与前置++构成重载得以区分。 Date&amp; operator++();前置++ Date operator++(int);后置++ 所以调用后置++操作符重载时，会多传一个int值，用于区分前置++，这个参数不需要我们显式去传，编译器帮我们处理。 但注意后置++的操作符重载不能写成Date operator++(int a = 0);，这是不被编译器所允许的。 因为这样会导致调用不明确，我们调用前置++重载时是该调用无参的还是缺省呢？这里就会产生歧义，因此不能给后置++重载的int参数缺省值。 临时变量与const的冲突cout &lt;&lt; d1++ &lt;&lt; endl;这段代码实际上就会出错了，会报错： 二元“&lt;&lt;”: 没有找到接受“Date”类型的右操作数的运算符(或没有可接受的转换) 说明上述代码没有找到对应的函数，可是明明参数什么的都是一致的啊？ d1++调用的是d1.operator++(int)函数，而此函数返回值是一个传值返回，而传递的过程实际上是在调用函数栈帧中创建了一个临时变量来接收被调函数的返回值，因此d1++是一个临时变量，具有常性，但我们的ostream&amp; operator&lt;&lt;(ostream&amp; out,Date&amp; d)函数的参数类型没有被const修饰，而C++对const的对象和非const对象区分得很严格，它们会被当做不同的类型，因此报错。 cout &lt;&lt; ++d1 &lt;&lt; endl;会不会报错呢？这里返回的是d1的引用，而不是一个临时变量的拷贝，对++d1的访问实际上就是对d1的访问，因此不会报错。 流提取&amp;流插入我们没有将这两个函数写成成员函数，而是设置为友元函数。 其实可以是可以，如下： 1234567891011ostream&amp; operator&lt;&lt;(ostream&amp; out)const{ out &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; return out;}istream&amp; operator&gt;&gt;(istream&amp; in){ in &gt;&gt; _year &gt;&gt; _month &gt;&gt; _day; return in;} 设置为成员函数，那么第一个参数就是隐含的this指针，第二个参数是输入输出流的对象。 调用方式：d1 &lt;&lt; cout; 调用时对象就只能作为左操作数，cout或者cin只能作为右操作数，与我们的使用习惯不符合，因此这里采用友元的方式处理流插入和流提取。 声明和定义分离首先我们要知道全局函数我们是不能放在头文件中的，因为头文件中得函数定义会在各个源文件展开并编译，同一个函数在两个不同的源文件有了不同的地址产生冲突，造成重定义。 如果想要成员函数的声明和定义分离，那成员函数的定义也一定得放在.cpp文件中而不是头文件，原因同上，同一个函数在多个源文件内被编译，造成重定义。 那为什么函数定义在类中，能正常编译呢？ 在类中定义得函数是默认内联的，不会放入符号表，即使头文件在多个源文件展开，也不会有重定义错误，因为它们都单独作用于所存在的源文件（没有外部链接属性）。 那可能又会问，放在类的函数不一定会被编译器当做内联，那这些没有被当做内联的函数会有函数地址，为什么也不会有重定义错误？ 答案是即使没有被编译器当做内联，即不会在调用的地方被展开，但是其是具有内联属性的，而无法被外部链接，就不会发生多个源文件相同函数有冲突的情况。 例如下面这种： 123456789101112131415161718192021//func.hinline void print(const int a);//func.cpp#include&quot;date.h&quot;inline void Test(const int a)//编译器不会采用我们的建议使其内联{ for(int i = 0; i &lt; 100; i++) { cout &lt;&lt; a &lt;&lt; endl; }}//main.cpp#include&quot;date.h&quot;int main(){ const int a = 1; Test(a); return 0;} 链接错误：LNK2019: 无法解析的外部符号 “void __cdecl print(int)” (?print@@YAXH@Z)，函数 main 中引用了该符号 则表明在main.cpp中找不到func.cpp中的func函数，可以这样理解——func函数虽然有地址，但是由于我们的inline声明，它无论如何都有内联属性，无法被外部链接。 结论： 公有的函数（包括友元）都不能定义在头文件，否则会有函数重定义的错误； 类的成员函数如果不是内联函数，也不能定义在头文件，否则会有函数重定义的错误； 若函数声明了是内联的，编译器也采纳了，那么内联函数没有地址，无法被外部链接； 若函数声明了是内联的，但编译器没有采纳，虽然产生了函数地址，但有内联属性，也无法被外部链接； 浓缩成一句话，被声明为内联的函数，即使编译器没有采纳内联意见，但仍保留内联属性（没有外部连接属性），必须没有外部链接属性的函数才能定义在头文件中。 说到外部链接属性，那么static修饰全局函数也是改变其连接属性，让函数只能在本源文件内被调用（无法被外部链接）即使其他源文件有一个完全相同的函数定义，但我链接此函数时只会在本源文件找，就不会有函数地址的冲突，因此static修饰全局函数时，这个函数也可以定义在头文件中而不发生重定义的错误。 当然也可以说它们没有了外部链接属性，就不会被放入符号表，也不会有符号表的合并中同一个函数却有多个地址的冲突，因此多个源文件链接到一起时不会报错。（我猜这个是主要原因） 关于代码复用我最开始觉得代码复用很不好，因为一个函数的函数体内要调用另一个函数来实现部分功能，这就需要有压栈的开销，这不是浪费资源吗？因此我带着怀疑在日期类的+运算符重载的重载中复用了+=运算符的重载。 但是当我做修改和添加功能时，我才发现代码复用的好处： 这降低了我们维护代码的难度，相似但细节上有差异的函数我们不需要一个地方出问题了就去全盘修改，而是只需要修改被复用了的函数，最重要的是我们省事啊！","link":"/2023/01/12/C++/11.C++%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"C++内存管理","text":"在C语言的学习中我们已经接触过内存管理，那么C++与C语言之间又有什么不同和相同的地方呢？ C++内存分布1234567891011121314151617181920212223242526272829int globalVar = 1;static int staticGlobalVar = 1;void Test(){ static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = &quot;abcd&quot;; const char* pChar3 = &quot;abcd&quot;; int* ptr1 = (int*)malloc(sizeof(int) * 4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4); free(ptr1); free(ptr3);}1. 选择题：选项 : A.栈 B.堆 C.数据段（静态区） D.代码段（常量区） globalVar在哪里？_数据段___ staticGlobalVar在哪里？__数据段__staticVar在哪里？__数据段__ localVar在哪里？__栈__num1 在哪里？__栈__char2在哪里？__栈__ *char2在哪里？_栈__pChar3在哪里？__栈__ *pChar3在哪里？__代码段__ptr1在哪里？__栈__ *ptr1在哪里？__堆__2. 填空题：sizeof(num1) = __40__;sizeof(char2) = __5__; strlen(char2) = __4__;sizeof(pChar3) = __4/8__; strlen(pChar3) = __4__;sizeof(ptr1) = __4/8__; 以上的内容我们通过C语言的学习就可以完成，通过对于不同变量的存储位置可以更好地理解其特性，内存分区如下： 【说明】： 栈又叫堆栈，存储非静态局部变量、函数参数、返回值等等，栈是向下增长的。 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下）。 堆用于程序运行时动态内存分配，堆是可以上增长的。 数据段–存储全局数据和静态数据。 代码段–可执行的代码/只读常量。 C语言动态内存管理方式C语言中提供了内存管理的函数例如malloc、calloc、realloc和free 12345678910void mem_alloc (){ int* p1 = (int*) malloc(sizeof(int)); free(p1); // 1.malloc/calloc/realloc的区别是什么？ int* p2 = (int*)calloc(4, sizeof (int)); int* p3 = (int*)realloc(p2, sizeof(int)*10); // 这里需要free(p2)吗？ free(p3);} 以上三个函数的的差异和特性我们已经学习过了，不再赘述。 这里不需要free(p2)，realloc对p2进行操作，p2所指向的空间有两种扩展方式： 原地扩容； 异地扩容； 无论哪种方式扩容后的空间都可以交给p3全权管理，不再需要对p2进行操作，因此不需要free(p2); C++内存管理方式 C++是兼容C语言的，因此C语言内存管理方式仍然可以在C++中使用，但有些地方就无能为力并且使用起来会比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。 那么如何使用它们进行内存管理呢？ new和delete操作内置类型123456789101112131415void mem_alloc(){ // 动态申请一个int类型的空间 int* ptr1 = new int; // 动态申请一个int类型的空间并初始化为10 int* ptr2 = new int(10); // 动态申请3个int类型的空间 int* ptr3 = new int[3]; // 动态申请3个int类型的空间，分别依次初始化为2，3，0 int* ptr4 = new int[3]{ 2,3 };//不够的默认初始化为0 delete ptr1; delete ptr2; delete[] ptr3; delete[] ptr4;} 使用new申请内存时，new只需要声明类型和个数即可，并且可以对申请的空间进行初始化操作。 只申请一个内置类型变量时可以用小括号()进行初始化操作； 申请多个内置类型变量时用中括号[]声明变量个数，用{}进行多个变量的初始化操作，与数组初始化时{}的使用方式相同； 可以看到对于申请内置类型空间时，new与malloc、delete与free并没有什么区别，除了可以显式的进行初始化外，相比于传统的malloc，new并没有对变量进行自动初始化操作以及其他特殊处理，而delete的作用貌似也只是与free相同。 注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]。 new和delete操作自定义类型12345678910111213141516171819202122232425262728293031323334353637383940414243class Test{public: Test() : _data(0) { cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl; } ~Test() { cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl; }private: int _data;};void Test1(){ // 申请单个Test类型的空间 Test* p1 = (Test*)malloc(sizeof(Test)); free(p1); // 申请3个Test类型的空间 Test* p2 = (Test*)malloc(sizeof(Test) * 3); free(p2);}void Test2(){ // 申请单个Test类型的对象 Test* p1 = new Test; delete p1; // 申请3个Test类型的对象 Test* p2 = new Test[3]; delete[] p2;}int main(){ cout &lt;&lt; &quot;Test1:&quot; &lt;&lt; endl; Test1(); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Test2:&quot; &lt;&lt; endl; Test2(); return 0;} 输出： Test1: Test2:Test():00000229F58AD590~Test():00000229F58AD590Test():00000229F58B0848Test():00000229F58B084CTest():00000229F58B0850~Test():00000229F58B0850~Test():00000229F58B084C~Test():00000229F58B0848 通过上面这段代码我们可以发现new与malloc的不同，在申请自定义类型的空间时，new会去调用构造函数，delete会去调用析构函数，而malloc与free并没有。 new操作自定义类型的初始化我们已经知道了new会去调用自定义类型的构造函数，那么自定义类型的空间申请如何显式的去调用构造函数初始化呢？ 12345678910111213141516171819202122232425262728class T{public: T(int m = 0, int n = 0) : _m(m), _n(n) { cout &lt;&lt; &quot;T(int m = 0, int n = 0):&quot; &lt;&lt; this &lt;&lt; endl; } ~T() { cout &lt;&lt; &quot;~T():&quot; &lt;&lt; this &lt;&lt; endl; }private: int _m; int _n;};int main(){ T* p1 = new T[3]{ {1,2},{4,5} };//申请多个自定义对象时的初始化方式 delete[] p1; cout &lt;&lt; endl &lt;&lt; endl; T* p2 = new T(8, 9);//申请一个自定义对象时的初始化方式 delete p2; return 0;} 输出： T(int m = 0, int n = 0):000001B53A5807E8T(int m = 0, int n = 0):000001B53A5807F0T(int m = 0, int n = 0):000001B53A5807F8~T():000001B53A5807F8~T():000001B53A5807F0~T():000001B53A5807E8 T(int m = 0, int n = 0):000001B53A5827F0~T():000001B53A5827F0 对于申请一个自定义类型空间的初始化使用()或者{}括上要初始化的一个值或一组值进行初始化； 对于申请多个自定义类型空间的初始化可以使用{}括上要初始化的多个值或者多组值进行初始化； operator new和operator delete operator new和operator delete不是new和delete的重载，new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。 123456789101112131415161718192021222324252627282930313233343536373839404142/*operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。*/void* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc){ // try to allocate size bytes void* p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) { // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); } return (p);}/*operator delete: 该函数最终是通过free来释放空间的*/void operator delete(void* pUserData){ _CrtMemBlockHeader* pHead; RTCCALLBACK(_RTC_Free_hook, (pUserData, 0)); if (pUserData == NULL) return; _mlock(_HEAP_LOCK); /* block other threads */ __TRY /* get a pointer to memory block header */ pHead = pHdr(pUserData); /* verify block type */ _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse)); _free_dbg(pUserData, pHead-&gt;nBlockUse); __FINALLY _munlock(_HEAP_LOCK); /* release other threads */ __END_TRY_FINALLY return;}/*free的实现*/#define free(p) _free_dbg(p, _NORMAL_BLOCK) 通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足时的应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。 new的过程如下： operator new过程如下： delete过程如下： operator delete过程如下： _free_dbg和free其实是一样的，free不是一个函数而是一个宏，free其实就是_free_dbg， new所作的事情： ​ new其实是先调用了operator new函数，而operator new中封装了malloc函数，如果malloc失败，就会抛异常，如果malloc成功就会返回，内存申请后再调用构造函数在分配的内存上去初始化对象（自定义类型），然后返回构造好对象的指针。 delete所做的事情： ​ delete先调用了指向对象的析构函数（自定义类型），再去调用operator delete函数，而operator delete中封装了_free_dbg释放内存。 operator new与operator delete的类专属重载 下面代码演示了，针对链表的节点ListNode通过重载类专属 operator new/ operator delete，实现链表节点使用内存池申请和释放内存，提高效率。 内存池技术内存池(Memory Pool)是一种内存分配方式。通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。 内存池技术在一些特定情况下可以一定程度上的提高动态申请内存的效率，有以下几个优点： 减少new、delete次数，减少运行时间； 避免内存碎片； 效率上看： ​ C语言中使用malloc/free来分配内存，C++中使用new/delete来分配内存，他们的内存申请与释放都是与操作系统进行交互的。具体的内容在严蔚敏数据结构的第八章有相关讲述，主要就是系统要维护一个内存链表，当有一个内存申请过来时，根据相应的分配算法在链表中找个一个合适的内存分配给它。这些算法有的是分配最先找到的不小于申请内存的内存块，有的是分配最大的内存块，有的是分配最接近申请内存大小的内存块。分配的内存块可能会大于所申请的内存大小，这样还要进行切割，将剩余的内存插入到空闲链表中。当释放的时候，系统可能要对内存进行整理，判断free的内存块的前后是否有空闲，若有的话还要进行合并。此外，new/delete还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。总之一句话，调用库中的内存分配函数，十分的耗时。 内存碎片： ​ 什么是内存碎片，从字面意思就很好理解了，就是内存不再是一整块的了，而是碎了。因为连续的这种new/delete操作，一大块内存肯能就被分割成小的内存分配出去了，这些小的内存都是不连续的。当你再去分配大的连续内存的时候，尽管剩余内存的总和可能大于所要分配的内存大小，但系统就找不到连续的内存了，所以导致分配错误。malloc的时候会导致返回NULL，而new的时候则是抛出异常。 ​ 难道说默认的内存管理函数就不好吗？当然不是的。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。 ​ 可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。 如何解决要解决上述两个问题，最好的方法就是内存池技术。具体方法就是大小固定、提前申请、重复利用。 因为内存的申请和释放是很低效的，所以我们只在开始时申请一块大的内存（在该块内存不够用时在二次分配），然后每次需要时都从这块内存中取出，并标记下这块内存被用了，释放时标记此内存被释放了。释放时，并不真的把内存释放给操作系统，只要在一大块内存都空闲的时候，才释放给操作系统。这样，就减少了new/delete的操作次数，从而提高了效率。 在调用内存分配函数的时候，大部分时间所分配的内存大小都是一定的，所以可以采用每次都分配固定大小的内存块，这样就避免了内存碎片产生的可能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct ListNode{ ListNode* _next; ListNode* _prev; int _data; void* operator new(size_t n) { void* p = nullptr; p = allocator&lt;ListNode&gt;().allocate(1); cout &lt;&lt; &quot;memory pool allocate&quot; &lt;&lt; endl; return p; } void operator delete(void* p) { allocator&lt;ListNode&gt;().deallocate((ListNode*)p, 1); cout &lt;&lt; &quot;memory pool deallocate&quot; &lt;&lt; endl; }};class List{public: List() { _head = new ListNode; _head-&gt;_next = _head; _head-&gt;_prev = _head; } ~List() { ListNode* cur = _head-&gt;_next; while (cur != _head) { ListNode* next = cur-&gt;_next; delete cur; cur = next; } delete _head; _head = nullptr; }private: ListNode* _head;};int main(){ List l; return 0;} new和delete的实现原理内置类型 如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。 自定义类型 new的原理 调用operator new函数申请空间； 在申请的空间上执行构造函数，完成对象的构造； 返回构造好对象的地址； delete的原理 在空间上执行析构函数，完成对象中的资源清理工作； 调用operator delete函数释放对象的空间； new T[N]的原理 调用operator new[]函数，在operator new[]中实际调用operator new完成N个对象的申请； 在申请的空间上执行N次构造函数； delete[]的原理 在将要释放的对象空间上执行N次析构函数，完成N个对象中资源的清理； 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放对象空间； 定位new表达式(placement-new)定位new表达式是指在已经分配的原始内存空间中调用构造函数初始化一个对象。 使用格式： new (place_address) type或者new (place_address) type(initializer-list) place_address必须是一个指针，initializer-list是类型的初始化实参列表 使用场景： 定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。 12345678910111213141516171819202122class Test{public: Test() : _data(0) { cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl; } ~Test() { cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl; }private: int _data;};int main(){ // pt现在指向的只不过是与Test对象相同大小的一段原始空间，还不能算是一个对象，因为构造函数没有执行 Test* p = (Test*)malloc(sizeof(Test)); new(p) Test; // 注意：如果Test类的构造函数有参数时，此处需要传参 return 0;} 常见面试题malloc/free和new/delete的区别 malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是： malloc和free是函数，new和delete是操作符; malloc申请的空间不会初始化，new可以显式初始化; malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可; malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型; malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常; 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理; 内存泄漏什么是内存泄露 什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。 内存泄露的危害 内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。 1234567891011121314151617181920212223double division(int a, int b){ if (b == 0) { throw &quot;Division by zero condition!&quot;; } return (a / b);}int main(){ int x = 50; int y = 0; double z = 0; // 1.内存申请了忘记释放 int* p1 = (int*)malloc(sizeof(int)); int* p2 = new int; // 2.异常安全问题 int* p3 = new int[10]; division(1, 0); // 这里函数抛异常导致 delete[] p3未执行，p3没被释放. delete[] p3; return 0;} 内存泄露分类 在C/C++程序中一般我们关心两种方面的内存泄露： 堆内存泄露 堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。 系统资源泄露 指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 如何检测内存泄露 在linux下内存泄漏检测：Linux下几款C++程序中的内存泄露检查工具 在windows下使用第三方工具：VS编程内存泄漏：VLD(Visual LeakDetector) 其他工具：内存泄露检测工具比较 如何避免内存泄露 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。 采用RAII思想或者智能指针来管理资源。 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。 出问题了使用内存泄漏工具检测，不过很多工具都不够靠谱，或者收费昂贵。 如何一次在堆上申请4G内存123456789/ 将程序编译成x64的进程，运行下面的程序试试？#include &lt;iostream&gt;using namespace std;int main(){ void* p = new char[0xfffffffful]; cout &lt;&lt; &quot;new:&quot; &lt;&lt; p &lt;&lt; endl; return 0;}","link":"/2023/01/12/C++/12.C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"C++入门基础上","text":"C++关键字C++关键字全集(参考 C++ Primer ): asm auto bad _cast bad _typeid bool break case catch char class const const _cast continue default delete do double dynamic _cast else enum except explicit extern false finally float for friend goto if inline int long mutable namespace new operator private protected public register reinterpret _cast return short signed sizeof static static _cast struct switch template this throw true try type _info typedef typeid typename union unsigned using virtual void volatile wchar_t while 命名空间 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的，std：c++标准库的命名空间。 在C语言中我们如果使用了同一个标识符定义了不同的函数或者是变量，会导致它们之间产生冲突，而C++为了解决这个问题，引入了命名空间的概念，不同命名空间的成员占有不同的内存空间，即使名称相同，但相互之间并不会受到影响。因此在C++中，库函数也是被定义在命名空间中的。 例如：C语言的头文件包含通常是 #include&lt;xxx.h&gt;，包含后我们便可以直接使用库函数，而在C++中我们的头文件通常是： #include&lt;xxx&gt;，并且无法直接使用库函数，必须要指定命名空间std才能使用。 不过C++是兼容C几乎所以语法的，因此我们可以在C++中穿插C的代码，不过有一些混用是很容易出错的，要小心并且正确的使用。 命名空间定义定义命名空间需要使用namespace关键字，后面跟上要定义的命名空间的名字，将命名空间成员定义在后面的{}内即可，类似于结构体和类的定义方式。 命名空间内可以定义变量，函数，类型，使用命名空间的类型定义出的变量不属于命名空间。 一般的命名空间定义方式 12345678910111213141516namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; };} 命名空间的嵌套定义 123456789101112131415161718192021222324namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; }; namespace psm { int b; void print() { cout &lt;&lt; &quot;hello psm!&quot; &lt;&lt; endl; } }} 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合并成同一个命名空间中 1234567891011121314151617181920namespace n1{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot;n1:swap&quot; &lt;&lt; endl; }}namespace n2{ int b;}namespace n1{ int c; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot;n1:swap&quot; &lt;&lt; endl; }} 像这样子去定义编译时会报错： 函数“void n1::swap(int &amp;,int &amp;)”已有主体 删除其中一个即可正常编译，由此可见编译时两个名字相同的命名空间会合并，如果有重复的定义则会报错。 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。 命名空间的使用定义在命名空间中的变量、类型以及函数我们是无法直接使用的，由于命名空间就定义了一个新的作用域，而程序中默认是只使用两个作用域的内容的： 全局作用域 局部作用域 并且根据局部优先原则会程序会先检索当前作用域的内容，如果没有找到我们需要的，再到全局域去检索，所以默认情况下我们所定义的命名空间的作用域的内容我们是无法直接访问的。 比如： 123456789101112131415161718192021namespace sx{ int a; void swap(int&amp; a, int&amp; b) { cout &lt;&lt; &quot; namespace:sx &quot; &lt;&lt; endl; int tmp = a; a = b; b = tmp; } struct Stu { char name[10]; int age; };}int main(){ cout &lt;&lt; a &lt;&lt; endl;//该语句编译出错，无法识别a return 0;} 报错：“a”: 未声明的标识符 命名空间的使用方式有三种： 加命名空间名称及作用域限定符 12345int main(){ cout &lt;&lt; sx::a &lt;&lt; endl;//指定使用在sx这个命名空间中的a return 0;} 作用域限定符是临时的，因此每次使用时都需要加命名空间和作用域限定符（限定符限定的是成员的名称，因此限定符应紧挨着在成员名称的前面，例如：sx::Stu s） 使用using声明命名空间中的成员，声明我们可以不加限定符使用此成员 12345678using sx::a;//指定地将sx中的a引入int main(){ cout &lt;&lt; a &lt;&lt; endl; //可以使用a Stu s; //无法使用Stu类型 return 0;} 这样只能使用指定使用我们需要的成员，并且声明时指定的应是成员的名称（变量名吗，函数名，类型名）。 使用using namespace 将命名空间中的成员引入至全局域 12345678using namespace sx;int main(){ cout &lt;&lt; a &lt;&lt; endl; Stu s; return 0;} 这种方法会将命名空间的所有成员一次性引入，可以直接访问其中所有的成员，平时我们可以这样使用，但是着违背了命名空间诞生的初衷，容易产生命名冲突的问题，因此在工程中通常是使用第一种或者第二种方法。 如何证明命名空间是被引入至全局域的呢？ 1234567891011121314151617int a = 1;using namespace sx;int main(){ cout &lt;&lt; a &lt;&lt; endl;//“a”: 不明确的符号 return 0;}using namespace sx;int main(){ int a = 1; cout &lt;&lt; a &lt;&lt; endl; return 0;} 第一个程序提示错误，而第二个程序正常运行。 引入至全局域后我们的程序即可在全局域中找到定义在命名空间sx中的变量 a ，而我们本身又在全局域中定义了一个变量 a ，那么自然如果不指定是哪个域中的也就产生了歧义，使得a变量名指代不明确。 可如果我们再次定义的a变量是局部的，即使命名空间中的a被引入至全局域，但并不会产生歧义，因为局部优先的原则，我们并不会去全局域中检索变量a，也就不存在命名冲突。 注意：即使是引入至全局域，命名空间sx中的a和本身定义在全局的a是拥有各自的内存空间的，”引入”仅仅是让其在全局域中可被检索，它仍然是属于命名空间sx的，有点像环境变量，引入就像是将某个命令所在的路径添加至环境变量，环境变量路径中的命令是可以在计算机任何路径下使用的，然而其被使用的命令可能并不在当前路径，它们之间是相互独立的。 指定使用全局域中的内容123456789101112131415161718namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using namespace sx;int main(){ int a = 1; cout &lt;&lt; ::a &lt;&lt; endl;//这里的a访问的是全局的 return 0;} 即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 命名空间是有一些比较坑的地方的，例如： 1234567891011121314151617181920212223242526272829303132333435363738//代码1int a = 1;namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using namespace sx;int main(){ cout &lt;&lt; ::a &lt;&lt; endl; return 0;}//代码2int a = 1;namespace sx{ int a; void swap(int&amp; a, int&amp; b) { int tmp = a; a = b; b = tmp; }}using sx::a;int main(){ cout &lt;&lt; ::a &lt;&lt; endl; return 0;} 代码1可以正常运行，而代码2却显示a多次定义，个人觉得还是有些奇怪的，不过项目中我们并不会将命名空间展开，更不会有这样的写法。使命名空间变量具有与全局变量相同的名称是错误的（参考微软官方文档https://docs.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170）。因此不用过于纠结这里的差异。 总之，使用using将命名空间展开或者是声明成员，即代表着后续的代码可以使用此命名空间的成员。 C++输入输出向世界打个招呼！ 12345678#include&lt;iostream&gt;using std::cout;int main(){ cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; return 0;} 使用cout标准输出(控制台)和cin标准输入(键盘)时，必须包含&lt; iostream &gt;头文件以及std标准命名空间。 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带.h；旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用&lt;iostream&gt; +std的方式。 使用C++输入输出更方便，它会自动识别类型（函数重载实现）而不需增加数据格式控制，比如：整形–%d，字符–%c 例如： 12345678910111213#include&lt;iostream&gt;//using namespace std;using std::cout;using std::endl;using std::cin;int main(){ int i = 1; double d = 1.1; cout &lt;&lt; &quot;i =&quot; &lt;&lt; i &lt;&lt; &quot;,d =&quot; &lt;&lt; d &lt;&lt; endl; return 0;} 但是C++的这样的输入输出方式在有些场景下使用会非常麻烦，而C语言就会很方便，例如左对齐右对齐或者是保留几位小数这样的场景，推荐使用C语言的输出方式printf函数。 缺省参数缺省参数即可有可无的参数，就像汽车备胎，带上备胎也能上路不带也不影响，除非运气实在太差。 缺省参数是声明或定义函数时为函数的参数指定一个默认值，在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。 1234567891011void testfunc(int t = 10){ cout &lt;&lt; t &lt;&lt; endl;}int main(){ testfunc(100);//传入100，就使用指定的实参 testfunc();//没有实参，就使用默认的形参10 return 0;} 缺省参数的分类 全缺省参数 ​ 即所有参数都有自己的默认值，传参时可以全部省略。 12345678910void FAll(int x = 1, int y = 2, int z = 3){ cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;}int main(){ FAll();//全缺省 return 0;} 半缺省参数 ​ 即只有部分参数都有自己的默认值，传参时一定需要传参。 123456789void FHalf(int x, int y = 10, int z = 30){ cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; endl;}int main(){ FHalf(5);//半缺省 return 0;p} 注意： 半缺省参数只能依次从右到左且连续，因为形参是从左往右依次传给实参，所以必须保证没有默认值的实参一定能有形参传值给它。 缺省参数不能在定义和声明中同时出现，以免给的默认值不同产生歧义。 123456void Test(int a = 10);void Test(int a = 20)//报错{ cout &lt;&lt; a &lt;&lt; endl;} 缺省值必须是常量或者是全局变量 C语言不支持 注意：如果定义和声明分离，那么只能缺省在声明 如果缺省参数在定义中，而声明没有，那么声明的头文件展开后，由于声明和定义在不同的源文件中，它们会先分别编译，那么包含定义的那个源文件在编译时编译器认为该函数是没有缺省参数的，但是该源文件函数的调用却没有传入参数，就发生了编译错误。 函数重载在我们的中文中常常会有一词多义的情况，但是我们可以通过上下文来帮助我们判断并确定它所表达意义而不是让我们无法识别。 讲个笑话： 我国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！ 那么一个相同的函数名我们想让它不只是有一种功能或者是不止能处理一种特定情况呢，函数重载可以帮助我们解决这个问题。 函数重载的概念 函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数或 类型或顺序)必须不同，常用来处理实现功能类似但数据类型不同的问题。 例如： 1234567891011121314151617181920212223int Add(int a, int b){ cout &lt;&lt; &quot;int Add(int a, int b)&quot; &lt;&lt; endl; return a + b;}double Add(double a, double b){ cout &lt;&lt; &quot;double Add(double a, double b)&quot; &lt;&lt; endl; return a + b;}float Add(float a, float b){ cout &lt;&lt; &quot;float Add(float a, float b)&quot; &lt;&lt; endl; return a + b;}int main(){ int ret1 = Add(1, 2); int ret2 = Add(1.1, 2.2); int ret3 = Add((float)1.1, (float)2.2); return 0;} 输出： 相同的函数名传入不同类型的参数调用的函数实体不同。 注意：无法区分仅按返回类型区分的函数 例如： 12345678short Add(short left, short right){ return left + right;}int Add(short left, short right){ return left + right;} 因为函数调用时只能根据实参的类型去找相匹配的函数，而无法识别返回类型。 函数重载的底层实现C语言是不支持函数重载的，但是C++却引入了这个特性，那么一定是因为底层实现有区别，于是我们从程序的编译和运行来探索一下，一个程序要运行起来，那么必须要经过预处理、编译、汇编、链接最终成可执行文件，在Windows中是后缀为 exe的文件，但由于VS是集成环境不方便查看，我们可以在Linux环境下尝试。 程序的编译过程： 符号表的合并 实际我们的项目通常是由多个头文件和多个源文件构成，而通过我们C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？ 所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。 那么链接时，面对Add函数，连接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。 【程序的编译具体参见】： 【C语言进阶】程序的编译 – Sabrina 函数名修饰 由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂，下面我们使用了gcc演示了这个修饰后的名字。 通过下面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+参数类型首字母】。 分别使用C的编译器和C++的编译器去编译并获得一个可执行文件 使用C语言（gcc）编译器编译后结果 使用objdump -S 命令查看gcc生成的可执行文件： 使用C++编译器（g++）编译后结果 使用objdump -S 命令查看g++生成的可执行文件： linux下：修饰后的函数名= _Z + 函数名长度 + 形参类型首字母 通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载，另外我们也从底层理解了，为什么函数重载要求参数不同！而跟返回值没关系。 C++的编译和链接方式 采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数，而我们另一个模块中想要调用这些函数也就必须使用相对应的C++的规则去链接函数（找修饰后的函数名）才能找到函数的地址。 C的编译和链接方式 对于C程序，由于不支持重载，编译时函数是未加任何修饰的，而且链接时也是去寻找未经修饰的函数名。 C和C++直接混合编译时的链接错误 在C++程序中，函数名是会被参数类型信息修饰的，这就造成了它们之间无法直接相互调用。 例如： print(int)函数，使用g++编译时函数名会被修饰为 _Z5printi，而使用gcc编译时函数名则仍然是print，如果直接在C++中调用使用C编译规则的函数，会链接错误，因为它会去寻找 _Z5printi而不是 print。 结论：在Linux环境下，采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数。 对重载函数的调用不明确难道说有了重载函数那么函数在调用时即使函数名相同就一定能区分了吗？ 来看看下面这种情况： 1234567891011121314void test(int a = 1, int b = 2){ cout &lt;&lt; &quot;testab&quot; &lt;&lt; endl;}void test(){ cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;}int main(){ test(); return 0;} 那么在12行调用test函数，按照C++的链接规则，我们应该找的是_Z4test，这样的被修饰过的函数名。 第1行的test函数经过修饰是_Z4testii 第6行的test函数经过修饰是_Z4test 那是否意味着我们不传参调用时就一定去找的_Z4test呢？但是明明第1行的函数带有默认参数即使不传参也可以调用啊。 事实上这个程序是可以编译通过的因为被修饰后的函数名并不会产生冲突，只会在调用函数时会存在歧义，链接过程中，这两个重载的函数都会成为被调用的候选人，并且都符合调用的条件，多个匹配函数找到，调用将被拒绝，因此我们链接过程中不仅仅是寻找函数名那么简单，还有很多复杂的规范。 【拓展阅读】：C++的函数重载 - 吴秦 - 博客园 extern “C”我们在写C++代码时，由于其兼容C语言，因此我们通常会使用一些C标准库里的函数，那如果它们的函数名修饰规则不同，那么C++编译器又是怎么去调用C的库的呢？ 在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略. 在C++工程中需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，该函数是按照C语言规则来编译和链接的。 比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree,两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。 源文件A（cpp）: 1234int Add(int num1, int num2){ return num1 + num2;} 源文件B（cpp）: 123456extern &quot;C&quot; int Add(int num1, int num2);int main(){ Add(1, 2);//在模块B中调用A中的函数 return 0;} error LNK2019: 无法解析的外部符号_Add，该符号在函数 _main 中被引用 注意： 这里的模块A的 Add函数仍然是按照C++规则去编译的，函数名仍会被修饰为_Z3Addii，不过在模块B 使用extern ”C“会让编译器让Add函数按照C的方式链接，所以在调用时用C的方式去寻找Add，所以会报错。 总结： extern “C” 只是 C++ 的关键字，不是 C 的 所以，如果在 C 程序中引入了 extern “C” 会导致编译错误。 被 extern “C” 修饰的目标一般是对一个全局C或者 C++ 函数的声明 从源码上看 extern “C” 一般对头文件中函数声明进行修饰。 C 和 cpp 中头文件函数声明的形式都是一样的（因为两者语法基本一样），对应声明的实现却可能由于语言特性而不同了( C 库和 C++ 库里面当然会不同)。 extern “C” 这个关键字声明的真实目的，就是实现 C++ 与C及其它语言的混合编程 一旦被 extern “C” 修饰之后，它便以 C 的方式工作（编译阶段：以C的方式编译，链接阶段：寻找C方式编译生成的符号）， C 中引用 C++ 库的函数，或 C++ 中引用 C 库的函数，都可以通过这个方式(即在C++文件中用extern “C” 声明，实现C与C++的兼容。 【关于extern “C”的具体使用】： C++和C的混合编译（extern“C”） – Sabrina 引用引用的概念引用不是定义了一个新的变量，而是是一个别名，也就是说，它是某个已存在变量的另一个名字，它和被引用的对象共用同一块内存空间。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 别名字面意思就是另一个名字，例如孙悟空，他的别名是孙行者，孙悟空也是他，齐天大圣也是它，一切可以指代他的名称都可以称作他的别名。 初始化引用格式 引用实体类型 &amp; 引用变量名 = 引用实体 1234567891011#include&lt;iostream&gt;using namespace std;int main(){ int a = 1; int&amp; quote = a;//初始化quote为a的别名 cout &lt;&lt; a &lt;&lt; quote &lt;&lt; endl; quote = 2; cout &lt;&lt; a &lt;&lt; quote &lt;&lt; endl; return 0;} 我们进入调试窗口： 通过调试可以看到，a和quote的地址是一样的，并且quote的类型就为int&amp;，所以quote的改变一定会影响a。 引用特性 引用在定义时必须初始化； 一个变量可以有多个引用； 引用一旦引用一个实体，引用指向的对象就不能再改变； 引用的实体可以是另一个引用; 例如： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//定义引用时未初始化int main(){ int a = 1; int&amp; quote;//未初始化引用，error: ‘rodents’ declared as reference but not initialized quote = a;}//修改引用实体int main(){ int a = 1; int b = 2; int&amp; quote = a; int&amp; quote = b;//只能引用一个实体,编译出错 return 0;}//引用另一个引用int main(){ int a = 1; int&amp; quote1 = a; int&amp; quote2 = quote1;//它们的地址仍然相同，指向同一块空间 return 0;} 常引用在C++中，与C语言不同，被const修饰的变量会被当做是一个常量（只对该变量内存空间有读权限，没有写权限），而不是常变量，因此引用的类型一定要和被引用的实体相匹配，可以有权限的缩小，但不能有权限的扩大。 例如： 12345678910111213141516171819202122//权限的缩小int main(){ int a = 1; const int&amp; quote = a;//从可读可写-》只可读 return 0;}//权限的放大会报错int main(){ const int a = 1; int&amp; quote = a;//从只可读-》可读可写 return 0;}//常引用int main(){ const int a = 1; const int&amp; quote = a; quote = 2;//不可赋值 return 0;} 使用场景 做参数 ​ 对于需要在函数内部修改函数外部实参的函数，让形参为实参的引用，就可以在函数内部修改外部变量，并且 还可以减少形参拷贝实参的开销。 123456789101112131415void swap(int&amp; num1, int&amp; num2){ int tmp = num1; num1 = num2; num2 = tmp;}int main(){ int n1 = 3; int n2 = 5; swap(n1, n2); cout &lt;&lt; &quot;n1=&quot; &lt;&lt; n1 &lt;&lt; endl &lt;&lt; &quot;n2=&quot; &lt;&lt; n2 &lt;&lt; endl; return 0;} 做返回值 如果返回的变量在函数调用结束后不会被自动销毁，则可以返回该变量的引用，减少返回值拷贝的开销 1234567int&amp; count(){ static int n = 1; ++n; cout &lt;&lt; &quot;int&amp; count()&quot; &lt;&lt; endl; return n;} 返回值不能是函数内创建的局部变量的引用 ​ 否则会非法访问内存（访问不属于程序的内存） 123456789101112int&amp; Add(int a, int b){ int c = a + b; return c;}int main(){ int&amp; ret = Add(2, 8);//Add(2, 8)的类型是c的引用，当赋值给ret时，c变量已经销毁 cout &lt;&lt; ret &lt;&lt; endl; return 0;} 总结：如果函数调用结束后栈帧销毁但是返回对象仍未销毁，则可以使用引用返回，否则只能传值返回。 传值和传引用的区别 以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。 函数的传参如果是传值调用的话，形参实际上是实参的一份拷贝，也就是说每一次调用函数，都要将实参拷贝给形参，这也带来了资源的消耗，如果多次调用此函数，那么必定会导致效率的低下。 可以使用如下代码测试多次调用函数时传值调用和传引用调用的时间差异 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;struct A{ A() { memset(arr, 0, sizeof(arr)); } int arr[1000];};void TestFunc1(A p){}void TestFunc2(A&amp; p){}void TestEfficiencyByCall(){ A p; size_t start1 = clock(); for (int i = 0; i &lt; 1000000; i++) { TestFunc1(p); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i &lt; 10000; i++) { TestFunc2(p); } size_t end2 = clock(); cout &lt;&lt; &quot;传值调用 void TestFunc1(A p)：&quot; &lt;&lt; end1 - start1 &lt;&lt; endl; cout &lt;&lt; &quot;传引用调用 void TestFunc1(A&amp; p)：&quot; &lt;&lt; end2 - start2 &lt;&lt; endl;}int main(){ TestEfficiencyByCall(); return 0;} 运行结果如下： 值和引用的作为返回值类型的性能比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct A{ A() { memset(arr, 0, sizeof(arr)); } int arr[1000];};A a;A TestFunc1(){ return a;}A&amp; TestFunc2(){ return a;}void TestEfficiency(){ size_t start1 = clock(); for (int i = 0; i &lt; 1000000; i++) { TestFunc1(); } size_t end1 = clock(); size_t start2 = clock(); for (int i = 0; i &lt; 10000; i++) { TestFunc2(); } size_t end2 = clock(); cout &lt;&lt; &quot;值返回 void TestFunc1(A p)：&quot; &lt;&lt; end1 - start1 &lt;&lt; endl; cout &lt;&lt; &quot;引用返回 void TestFunc1(A&amp; p)：&quot; &lt;&lt; end2 - start2 &lt;&lt; endl;}int main(){ TestEfficiency(); return 0;} 运行结果： 可以看到无论是作为参数还是作为返回值，传递引用和值的时间的开销差异都是比较大的。 我们可以看一看函数返回值是如何传递的： 函数返回值从被调用的函数的栈帧到调用方栈帧的传递过程大致如上。 通常我们会创建一个变量接收函数得返回值，在这里就是这个在main函数中预先开好空间的用于存储函数返回值的对象。 接下来看过程： 如果是传值返回，则产生的临时变量会是返回对象的一份临时拷贝，然后再拷贝给main函数中预先开好空间的用于存储函数返回值的对象，而如果是传引用返回，则临时变量会是a的引用，临时对象再赋值给main函数中预先开好空间的用于存储函数返回值的对象，那这里也会是一个引用，因此我们在main函数中就可以访问到a对象了。 不过不是每次都需要创建一个临时变量，对于一些比较小的变量，会直接用寄存器来传递值。 注：临时变量的类型就是定义的返回类型，此临时变量通常也是也是具有常性的，不过也有例外，那就是传引用返回的情况。 传值返回：那么该临时变量是有常性的。 传引用返回：无常性，只和返回的类型是否被const修饰有关。 临时变量存储于调用方函数的栈帧**。 引用和指针的区别引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用（引用的对象必须存在）。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 引用在语法层面上就是一个别名，别名是不单独享有内存空间的，它和被引用的实体共用同一块内存空间。 12345678int main(){ int a = 9; int&amp; ra = a; cout &lt;&lt; &quot;&amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;&amp;ra = &quot; &lt;&lt; &amp;ra &lt;&lt; endl; return 0;} 这样的语法解释实在有些难以理解它在底层是如何做到的。 实际上在底层实现上引用还是有空间的，因为引用本质还是指针的方式来实现的。 1234567891011int main(){ int a = 9; int&amp; ra = a; ra = 99; int* pa = &amp;a; *pa = 99; return 0;} 我们来看看汇编： 汇编指令大致都是相同的，也就是说它和指针实际上是同根同源的。 指针和引用差异汇总： 引用在定义时必须初始化，而指针不需要； 引用在初始化引用一个实体后就不能再引用其他实体了，而指针指向的对象可以随意修改； 没有NULL引用，但是又NULL指针； 在sizeof中的含义不同，引用结果为被引用实体的类型大小，而指针的大小是地址空间所占的字节数； 引用在初始化后，一切对引用的操作都是对实体对象操作的，而指针可以操作指针变量本身，也可以操作被指向的对象； 有多级指针但没有多级引用； 访问实体方式不同，指针需要我们显式的去解引用方能对指向的对象进行操作，而引用是编译器替我们处理； 引用相对于指针更加的安全，不存在野指针等潜在的风险； 一些引用的注意事项类型转换实现方法以及临时变量的特性 看如下代码： 1234567int main(){ double d = 9.9; int&amp; a = d; cout &lt;&lt; a &lt;&lt; endl; return 0;} 报错： “初始化”: 无法从“double”转换为“int &amp;” 改动如下即可正常编译： 1234567int main(){ double d = 9.9; const int&amp; a = d; cout &lt;&lt; a &lt;&lt; endl; return 0;} 这是什么原因？？const修饰过后为什么就能正常编译了呢？？？（warning） 这里不得不提到类型转换时发生的小动作； 类型转换是如何实现的呢？不论是显式的还是隐式的发生的类型转换，它这个类型转换的效果都是“临时”的，仅仅在当前行生效，也就是说本身发生转换的那个变量或者说是对象它的类型并没有改变。 既然如此，那么中间一定会有另一个临时变量的产生，而是这个我们看不到的临时变量在发挥让我们看起来像“类型转换”的作用。 那么再来看第4行代码，int&amp;只能初始化为int类型的引用，因此这里会发生隐式类型转换，即产生一个int类型的变量，并且让这个临时变量在这一行中代替d来产生作用，a就被初始化为了这个临时变量的引用； 为什么不用const修饰就无法通过编译呢？ 答案是：临时变量具有常性，也就是说临时变量具有只可读不可写的性质，那么如果不使用const对引用加以限制，就造成了权限的放大，而这是不被C++所允许的，因此必须加上const修饰a； 嘿，那么新问题来了，既然临时变量只在当前行生效，也就是程序走完这一行临时变量就销毁了，而a作为此临时变量的引用，却在第5行正常访问了a，那么这里我们还可以得出一个结论： const修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，直到引用的生命周期结束。 概括一下： 类型转换伴随着临时变量的产生； 临时变量具有常性； const修饰的引用的实体是临时变量时，临时变量的声明周期就会延长，知道引用的生命周期结束； 不会被修改的变量尽量用const修饰； 关于临时对象的类型的注意事项 如下两段代码有何差异？ 123456789//代码1int main(){ double d = 9.9; const int&amp; a = (int&amp;)d; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; return 0;} 输出： d = 9.9a = -858993459 123456789//代码2int main(){ double d = 9.9; const int&amp; a = d; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; return 0;} 输出： d = 9.9a = 9 出错了，奇怪，这两段代码的执行结果应该相同才对啊？？？不急我们耐心分析一下这两段代码的差异。 差异就只有第四行，我们来单独看看 代码1： const int&amp; a = (int&amp;)d; 这行代码的意思应该是将 d (double类型)强制类型转换为 int&amp;，我们都知道强转类型时会生成一个临时变量（int&amp;），再初始化a为为这个临时变量的引用； 关系如图： 这里的关系文字描述为d是double类型， tmp是d的引用（int&amp;），而a又是tmp的引用（int&amp;），可以直接认为a是d的引用，只不过引用的类型为 const int; 代码2： const int&amp; a = d; 这行代码的意思是初始化a为d的引用，不过类型并不匹配，int&amp;需要一个引用一个int的实体或者一个int&amp;的引用，因此，d会发生隐式类型转换，产生一个int类型的临时变量，即a会是这个临时变量的引用。 关系如图： 这里的关系文字描述为d是double类型，而tmp是一个临时的int类型，a是tmp的引用； 这样就解释的通了，但是是否真是如此，我们需要通过地址来验证； 代码1： 可以看到他d和a的地址是一样的，说明a是d的引用（指向d的地址），但只是引用的类型和d的类型不同。 代码2： a的地址和d不同，这是因为a是隐式类型转换所产生的临时变量的引用，而此临时变量是一个int类型，而非引用，具有自己独立的内存空间，而a指向这块临时变量的空间，因此地址不同。 这两段代码的唯一差异就是类型转换时生成的临时变量的类型不同，一个是int类型，一个是int&amp;类型，即一个有自己的单独内存空间，而另一个与发生类型转换的对象共享一块空间（其实引用是有单独的内存空间，不过经过编译器处理，我们对引用操作时都是实际上操作的是被引用的实体，因此可以视作没有分配内存），而a都是临时变量的引用，就导致了最终结果的不同。 因此在使用引用时，一定要注意这些可能会遇到的问题，一不留神就可能掉坑了，要规范正确的使用引用。","link":"/2023/01/12/C++/1.C++%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"C++ STL","text":"什么是STL STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。 STL的版本 原始版本Alexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。 HP 版本–所有STL实现版本的始祖。 P. J. 版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低，符号命名比较怪异。 RW版本由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般。 SGI版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被GCC(Linux)采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。我们后面学习STL要阅读部分源代码，主要参考的就是这个版本。 STL的六大组件 STL的重要性 在编写程序的过程中可以节省大量时间去做重复的工作，直接使用库中的接口可以又快又好的完成开发任务。STL是C++中的优秀作品，有了它的陪伴，许多底层的数据结构以及算法都不需要自己重新造轮子，站在前人的肩膀上，健步如飞的快速开发。 如何学习STL 熟练使用STL； 了解泛型技术的内涵与STL的实现； 在原有基础上对STL进行扩充； 简化为一句话：能用，明理，能扩展 。 STL的缺陷 STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修订。C++11出来已经相隔了13年，STL才进一步更新。 STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。 STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语法本身导致的。","link":"/2023/01/12/C++/14.stl/"},{"title":"C++泛型编程","text":"泛型编程 如何实现一个通用的交换函数呢？ 123456789101112131415161718void Swap(int&amp; left, int&amp; right){ int temp = left; left = right; right = temp;}void Swap(double&amp; left, double&amp; right){ double temp = left; left = right; right = temp;}void Swap(char&amp; left, char&amp; right){ char temp = left; left = right; right = temp;} C++支持函数重载，因此无论是交换double类型还是int类型的变量的值，可以统一使用同一个函数名。 使用函数重载虽然可以实现，但是有以下几个不好的地方： 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。 代码的可维护性比较低，一个出错可能所有的重载均出错。 很显然这些函数只有类型不同，那么我们能否写出一个模型，让编译器根据不同的类型利用模板来生成不同的函数呢？ 就像下面的图一样，我们只需要制作模具，后面的事情就简单了许多。 如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多时间。巧的是前人早已将树栽好，我们只需在此乘凉。 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。 函数模板概念 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。 格式 template&lt;typename T1, typename T2,……,typename Tn&gt;return_type 函数名(参数列表){} 1234567template&lt;typename T&gt;void Swap(T&amp; left, T&amp; right){ T temp = left; left = right; right = temp;} 注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替class) 原理 就像机器人一样，我们将重复简单的事情交给他去做，它可以代替我们完成这些，为我们节省了大量时间和精力。 函数模板就是一个蓝图，它本身并不是一个函数，是编译器使用特定方式产生的具体类型函数的膜具，所以其实模板就是将本来应该我们做的重复的事情交给了编译器。 在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。 比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型及其他类型也是如此。 函数模板的实例化 用不同类型的参数使用函数模板时，称为函数模板的实例化，有两种方式： 隐式实例化：让编译器根据实参推演模板参数的实际类型； 显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型； 123456789101112131415161718192021222324template&lt;class T&gt;T Add(const T&amp; left, const T&amp; right){ return left + right;}int main(){ int a1 = 10, a2 = 20; double d1 = 10.0, d2 = 20.0; Add(a1, a2); Add(d1, d2); /* Add(a1, d1); 该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型 通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有 一个T， 编译器无法确定此处到底该将T确定为int 或者 double类型而报错 注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅 */ // 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化 Add(a1, (int)d1); Add&lt;int&gt;(a1, d1); return 0;} 模板函数的隐式实例化不允许自动类型转换（只能按照实参的类型去推导），但普通函数和显式实例化可以进行自动类型转换。 显式实例化的方式可以让模板参数有一个确定的类型，并且指定的调用使用该类型实例化出的函数，不再需要实参去推导类型，这样就和调用普通函数一样，参数类型不匹配时，会尝试类型转换操作，如果无法转换成功编译器将会报错。 如何证明模板函数会实例化呢？来看看上面的代码第10、11行的汇编： 可以看到，表面上好像无论实参类型是int还是double我们都是调用的Add函数，但事实上它们调用的是实例化出的函数Add&lt;int&gt;和Add&lt;double&gt;，它们是不同的函数。 模板参数的匹配原则 一个非模板函数可以和一个同名的模板函数同时存在，而且该函数模板还可以被实例化为这个非模板函数功能完全相同的一个函数。 对于非模板函数和同名函数模板，如果其他条件（参数类型）都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板，也可以强行调用显式实例化出的函数。 1234567891011121314151617181920int Add(int left, int right){ cout &lt;&lt; &quot;int Add(int left, int right)&quot; &lt;&lt; endl; return left + right;}template&lt;typename T&gt;T Add(T left, T right){ cout &lt;&lt; &quot;T Add(T left, T right)&quot; &lt;&lt; endl; return +right;}int main(){ Add(1, 2);//与非模板函数匹配，不需要将模板函数实例化，直接调用 Add&lt;int&gt;(2, 3);//调用显式实例化出的函数Add&lt;int&gt; Add(3, 4);//与非模板函数匹配，不需要将模板函数实例化，直接调用 Add(1.0,2.0);//没有完全匹配的函数存在，模板函数可以生成类型更加匹配的版本，编译器根据实参类型推导生成更加匹配的Add函数 return 0;} 输出： int Add(int left, int right)T Add(T left, T right)int Add(int left, int right)T Add(T left, T right) 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数，但两者是不同的函数，它们有不同的函数地址 1234567891011121314151617181920int Add(int left, int right){ cout &lt;&lt; &quot;int Add(int left, int right)&quot; &lt;&lt; endl; return left + right;}template&lt;typename T&gt;T Add(T left, T right){ cout &lt;&lt; &quot;T Add(T left, T right)&quot; &lt;&lt; endl; return +right;}int main(){ int (*p1)(int, int) = Add; int (*p2)(int, int) = Add&lt;int&gt;; cout &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; p2 &lt;&lt; endl; return 0;} 输出： 00007FF793BD121700007FF793BD142E 模板函数和非模板函数的冲突问题123456789101112131415161718int Add(int left, int right){ cout &lt;&lt; &quot;int Add(int left, int right)&quot; &lt;&lt; endl; return left + right;}template&lt;typename T&gt;T Add(T left, T right){ cout &lt;&lt; &quot;T Add(T left, T right)&quot; &lt;&lt; endl; return +right;}int main(){ Add(1, 2);//与非模板函数匹配，不需要将模板函数实例化，直接调用 Add&lt;int&gt;(2, 3);//调用显式实例化出的函数Add&lt;int&gt; return 0;} 前面我们已经知道Add(1, 2);和Add&lt;int&gt;(2, 3);调用的不是同一个函数，那么这样为什么不会有符号表的冲突呢？ 猜测：非模板函数的符号表存放的是Add，而模板函数实例化出的函数符号表存放的是Add&lt;int&gt;，因此不会发生符号表冲突。 隐式实例化过程（Add(1, 2);）实际上是： 调用Add时，去符号表里找函数Add，若未找到则执行第3步。 若找到了，接着检查类型是否匹配：如果匹配则直接用函数地址调用此函数。若不匹配则执行第3步； 寻找是否有名为Add的模板函数； 若没有找到相应的模板函数则报错。若找到了执行第5步； 查找此函数模板实例化出的函数中是否有与之类型匹配的函数； 若有，则调用此函数。若没有则尝试实例化出相应类型匹配的函数Add&lt;int&gt;，执行第7步； 实例化出的函数Add&lt;int&gt;会进入符号表，然后调用Add&lt;int&gt;函数； 显式实例化过程（Add&lt;int&gt;(2, 3);）实际上是： 调用Add&lt;int&gt;时，去符号表找Add&lt;int&gt;; 若找到了则直接调用此函数。若未找到则执行第3步； 寻找名为Add的模板函数； 使用模板函数实例化出相应函数； 实例化出的函数Add&lt;int&gt;会进入符号表，然后调用Add&lt;int&gt;函数； 类模板类模板的定义格式12345template&lt;class T1, class T2, ..., class Tn&gt;class 类模板名{// 类内成员定义}; 1234567891011121314151617181920212223242526272829303132333435// 动态顺序表// 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具template&lt;class T&gt;class Vector{public: Vector(size_t capacity = 10) : _pData(new T[capacity]) , _size(0) , _capacity(capacity) {} // 使用析构函数演示：在类中声明，在类外定义。 ~Vector(); void PushBack(const T&amp; data); void PopBack(); // ... size_t Size() { return _size; } T&amp; operator[](size_t pos) { assert(pos &lt; _size); return _pData[pos]; }private: T* _pData; size_t _size; size_t _capacity;};// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表template &lt;class T&gt;Vector&lt;T&gt;::~Vector(){ if (_pData) delete[] _pData; _size = _capacity = 0;} 类模板的实例化 类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。 123// Vector类名，Vector&lt;int&gt;才是类型Vector&lt;int&gt; v1;//用Vector&lt;int&gt;这个类型定义出对象v1Vector&lt;char&gt; v2;//用Vector&lt;double&gt;这个类型定义出对象v2 汇编如下： 模板参数 template&lt;typename T1, typename T2…&gt;中被&lt;&gt;括起来的就叫做模板参数，一个template&lt;&gt;只能对一个函数或者一个类生效，也就是一个template&lt;&gt;中模板参数只能在代码下方离他最近的一个函数或者类中使用。 模板参数与函数参数非常相似，不过模板参数既可以是类型又可以是值，而函数参数只能是值。 类型模板参数 类型形参即：出现在模板参数列表中，跟在class或者typename之类的参数类型名称，可以有缺省，缺省的规则和函数参数相同。 123456789101112131415161718template&lt;typename T1, typename T2 = char&gt;//半缺省class S{public: S() :a(0) ,b(0) {}private: T1 a; T2 b;};int main(){ S&lt;int, int&gt; s1; S&lt;int&gt; s2; return 0;} 模板参数和函数参数一样，缺省参数（默认实参）只能在模板参数列表的结尾。 非类型模板参数 非类型形参，就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用。 123456789101112131415161718192021namespace sx{ template&lt;class T, size_t N = 10&gt; class array { public: T&amp; operator[](size_t index) { return _array[index]; } const T&amp; operator[](size_t index)const { return _array[index]; } size_t size()const { return _size; } bool empty()const { return 0 == _size; } private: T _array[N]; size_t _size; };}int main(){ sx::array&lt;int&gt; arr1; sx::array&lt;char, 15&gt; arr2; return 0;} 注意： 浮点数、类对象以及字符串是不允许作为非类型模板参数的。 非类型的模板参数必须在编译期就能确认结果（常量值）。 多重模板参数123456789101112131415161718192021222324252627282930313233template&lt;typename T1 , typename T2 &gt;class S{public: S() :a(0) ,b(0) {} ~S(); template&lt;typename K&gt; void test(K k);private: T1 a; T2 b;};template&lt;typename T1, typename T2 &gt;S&lt;T1, T2&gt;::~S(){}template&lt;typename T1, typename T2 &gt;template&lt;typename K&gt;void S&lt;T1, T2&gt;::test(K k){ cout &lt;&lt; k &lt;&lt; endl;}int main(){ S&lt;int, int&gt; s1; s1.test&lt;double&gt;(1.1); s1.test(1); return 0;} 模板类和模板函数区别模板类的实例化方式： 显式实例化 模板函数的实例化方式： 显式实例化 隐式实例化 通常模板函数我们使用隐式的实例化就足够了，但有些特殊情况，例如函数没有参数或者函数参数的类型并不是模板参数，无法通过实参去推导出类型，就需要显式地去实例化函数。而类的实例化只有显式实例化一种方式。 1234567891011121314template&lt;typename T&gt;void print(int n){ T t = 0; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; t &lt;&lt; endl; }}int main(){ print&lt;int&gt;(10); return 0;}","link":"/2023/01/12/C++/13.C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"},{"title":"C++指针和引用的区别","text":"前言指针和引用在形式上很好区别，在C++中相比于指针我们更喜欢使用引用，但是它们的使用场景又极其类似，它们都能直接引用对象，对对象进行处理，那么究竟为什么会引入引用？什么时候使用指针？什么时候使用引用？这两者实在容易混淆，在此我详细介绍一下指针和引用。 指针和引用的定义维基百科中这样解释 指针： 在计算机科学中，指针（英语：Pointer），是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。 引用： 在C++编程语言中，引用是一种简单的引用数据类型，其功能不如从C继承的指针类型，但更安全。C++引用的称谓可能会引起混淆，因为在计算机科学中，引用是一种通用的概念数据类型，指针和C++引用是特定的引用数据类型实现。 但说了和没说差不多。下面用通俗易懂的话来给概述一下。 指针 对于一个类型T，T*就是指向T的指针类型，也就是说T*类型的变量能够保存一个T类型变量的地址。 12345678int main(){ int i = 1; int* p = &amp;i; cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; return 0;} 关系如图： 引用 引用是一个对象的别名，主要用于函数参数和返回值类型，符号X&amp;表示X类型的引用。见下图，所示引用的含义： 指针和引用的区别首先，引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，那么能初始化引用的前提一定是被引用的对象存在，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化。如果你有一个变量是用于指向另一个对象，但是它可能为空，这时你应该使用指针；如果变量总是指向一个对象，并且这个变量一定不为空，这时你应该使用引用。如果定义一个引用变量，不初始化的话连编译都通不过（编译时错误）： 1234567int main(){ int i = 10; int* p; int&amp; r; return 0;} 报错： “r”: 必须初始化引用 而声明指针并不需要初始化操作，即它可以不指向任何对象，也正因如此，指针的安全性不如引用，在使用指针前一定要进行判空操作； 引用初始化后就不能再改变指向，无论如何都只能指向初始化时引用的这个对象；但是指针就不同，指针是一个变量它可以任意改变自己的值，即任意改变指向，而指向其他对象。总的来说，就是引用不可以改变指向，但是可以改变初始化对象的内容，而指针即可以改变指向，又可以改变指向对象的内容； 例如：对指针和引用分别进行++操作，对引用执行此操作，作用对象会直接反应到引用所指向的对象，而对于指针，执行++操作作用于指针变量，会使指针指向下一个对象，而非改变指向对象的内容。 代码如下： 1234567891011121314151617181920int main(){ int i = 10; int* p = &amp;i; int&amp; r = i; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl; r++; cout &lt;&lt; &quot;r++ operation：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl; p++; cout &lt;&lt; &quot;p++ operation：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl; return 0;} 输出： 可以看到对r执行++操作是直接反应到所指向的对象身上，对引用r的改变并不会是引用r的指向改变，它仍然指向i，并且会改变i的值；而如果是指针，则改变的是指针的值而非指向的对象的值。也就是说在引用初始化后对其的赋值等操作，都不会影响其指向，而是影响其指向的对象的内容。 引用的的大小是其指向的对象的大小，因为引用仅仅是一个别名；指针的大小与平台有关，在32位平台下指针大小为4个字节； 123456789int main(){ int i = 10; int* p = &amp;i; int&amp; r = i; cout &lt;&lt; &quot;sizeofo(p) = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; &quot;sizeofo(r) = &quot; &lt;&lt; sizeof(r) &lt;&lt; endl; return 0;} 输出： 由于我是在64位下进行程序编译的，因此指针大小为8个字节，而引用的大小是一个int的大小； 最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针）。 引用在初始化过后，对引用的一切操作实际上是对它指向对象的内容的操作，而指针则是需要*操作符解引用后才能访问到被指向的对象，因此引用的使用也比指针更加的漂亮，更加直观；在初始化时也不需要&amp;操作来取得地址； 总而言之，言而总之——它们的这些差别都可以归结为”指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。“ const修饰的引用和指针之前我们就知道，对于指针而言const的位置可以决定其修饰的对象是谁；那么引用呢？ 常量引用和常量指针常量指针：指向常量的指针，在定义的语句类型前加上const，表示指向的对象是常量； 定义指向常量的指针只限制指针的间接访问操作，而不能规定指针指向的值本身的操作规定性。 1234567int main(){ int i = 10; const int* p = &amp;i; *p = 20; return 0;} 报错： “p”: 不能给常量赋值 常量指针定义”const int* p=&amp;i“告诉编译器，*p是常量，不能将*p作为左值进行操作。 常量引用：指向常量的引用，在引用定义的语句的类型前加上const，表示指向的对象是常量。与指针一样，不能对指向的对象的内容进行改变。 1234567int main(){ int i = 10; const int&amp; r = i; r = 20; return 0;} 报错： “r”: 不能给常量赋值 引用常量和指针常量指针常量：指针中的常量； 在定义指针的语言中的变量名前加const，表示指针本身是一个常量，即指针的指向不可改变。在定义指针常量时必须进行初始化，欸，这像极了引用，是的！ 引用指向的对象不可改变是引用的与生俱来的性质，因此不需要在引用的变量名前加上const。 123456789int main(){ int i = 10; int j = 20; int* const p = &amp;i; *p = 30; p = &amp;j; return 0;} 报错： “p”: 不能给常量赋值 指针常量定义int* const p = &amp;i告诉编译器，p是常量，不能作为左值进行赋值操作，但是允许对指向的对象进行修改。 常量引用常量和常量指针常量常量指针常量：指向常量的指针常量，定义一个指向常量的指针常量，它必须要在定义时初始化。 常量指针常量定义”const int* const p=&amp;i“告诉编译器，p和*p都是常量，他们都不能作为左值进行操作。 那么对于引用呢？引用本身具有不能修改指向的性质，因此引用的指向总是const的，所有的引用都是引用常量，即const不需要修饰引用名。程序决不能给引用本身重新赋值，使他指向另一个变量，因此引用总是const的。如果对引用应用关键字const，其作用就是使其目标称为const变量。即没有：Const double const&amp; a=1；只有const double&amp; a=1； 注意：实际上const double &amp;a 和 double const &amp;a是一样的，都是定义了一个常量的引用。 技巧：有一个规则可以很好的区分const是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。 指针和引用的实现实际上在底层实现上引用还是有空间的，因为引用本质还是指针的方式来实现的。 1234567891011int main(){ int a = 9; int&amp; ra = a; ra = 99; int* pa = &amp;a; *pa = 99; return 0;} 我们来看看汇编： 12345678910111213 int&amp; ra = a;00007FF7BFFC1854 lea rax,[a] //变量a的地址传给rax寄存器中00007FF7BFFC1858 mov qword ptr [ra],rax //将rax中的地址给ra ra = 99;00007FF7BFFC185C mov rax,qword ptr [ra] 00007FF7BFFC1860 mov dword ptr [rax],63h int* pa = &amp;a;00007FF7BFFC1866 lea rax,[a] //变量a的地址传给rax寄存器中00007FF7BFFC186A mov qword ptr [pa],rax //将rax中的地址给pa *pa = 99;00007FF7BFFC186E mov rax,qword ptr [pa] 00007FF7BFFC1872 mov dword ptr [rax],63h 汇编指令大致都是相同的，也就是说它和指针实际上是同根同源的。 虽然指针和引用最终在编译中的实现是一样的，但是引用的形式大大方便了使用也更安全。有人说：”引用只是一个别名，不会占内存空间？“通过这个事实我们可以揭穿这个谎言，实际上引用也是占内存空间的。 理解引用小技巧： C++中与C的区别最明显的是什么？不就是面向对象的特性吗？其实可以把引用当做一个封装了的指针，对对象的操作会被重载成对该指针指向对象的操作。 指针传递和引用传递 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。 引用传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 引用传递和指针传递是不同的（指针略快于引用），虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针的引用。 不论是指针传递还是引用传递，其效率都远远超过值传递，尤其在处理一些比较大的对象，值传递需要更多的时间开销并且占据更多的内存，因此在传值过程中，尽量使用指针传递和引用传递，而因为相比于指针引用的直观性（指针存在多级指针不方便去理解）和可读性，我们建议能使用引用就使用引用传递，尽量不使用值传递，必须使用指针传递才使用指针。","link":"/2023/01/12/C++/4.%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/"},{"title":"C++入门基础下","text":"内联函数C++中函数的使用我们已经比较清楚了，与C语言中函数的使用大多相同，主要是增加了重载的特性，对C语言的函数的一些缺陷做了一些补充。 那么对于一些比较简单却又经常使用的功能，我们在C语言中常常使用宏来替换，宏呢与函数相比没有栈帧的开辟，类型的检查，没有传参，仅仅是做一个替换，非常适合功能简单却使用频繁的应用场景，但是宏正因为如此，也就具有了不安全、无法调试的缺陷，那么C++中如何处理这样地缺陷呢？ 内联函数应运而生它既继承了宏的优点也继承了函数的优点，即既没有开辟栈帧的开销，又可以去调试，并且有类型的检查。 内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以像调用函数一样来调用内联函数，而不必担心会产生 处理宏的一些问题。 概念 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。 我们得明白，函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视，要尽可能处理函数调用机制所用时间占比大的这种情况。 为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。 先来看看普通函数的调用过程： 调用函数时是使用call指令，去调用某地址上的函数。（注意：普通函数都是有地址的，可以用以区分内联函数） 如果在上述函数的前面加上inline关键字将其改为内联函数，在编译期间编译器会用函数体替换函数的调用。 不过我们通常在Debug模式下默认函数不会被当做内联，即使你加上了inline，都会被编译器忽略，只有在release模式下，inline才有可能会被采纳，至于为什么是有可能，编译器只会把你的inline关键字当做一个建议，至于编译器是否按照你所要求的去做，这就不一定了，因为这仅仅是一个建议，编译器会结合具体情况比如函数体指令的多少来判断到底是否当做内联函数。 所以我们如何去观察一个函数是否被当做内联函数呢？ 在release模式下 查看编译生成的汇编代码中是否存在call Add 监视器窗口查看Add函数是否有地址； 在debug模式下需要对编译器进行设置，否则不会展开，因为在debug模式下，编译器默认不会对代码进行优化，内联函数其实算一种优化方式。 在项目—&gt;属性中找到 C/C++选项—&gt;常规 ​ 将调试信息格式改为程序数据库(/Zi) 在C/C++选项中找到优化 将内联函数扩展选择—&gt;只适用于__inline(Ob1) ​ 重新生成可执行文件即可 完成后，我们便可以在debug模式下查看到内联函数的展开 这里并没有call Add函数，而是函数体的展开（当然不仅仅是简单的展开，还会涉及一些其他指令，不做深入讨论）。 特性 inline是一种空间换时间的做法 ，节省了开辟栈帧的时间开销； ​ 与调用普通函数相比不需要去开辟栈帧空间，节省了时间，相当于inline函数体所有指令都在当前栈内被执行； inline对于编译器仅仅是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化会自动忽略内联。 ​ 不仅是以上两种情况，函数体内的指令一旦较多，编译器就会自动忽略，如下： ​ 函数体指令较复杂： ​ ​ 函数体指令较简单： inline函数不建议声明和定义分离，分离会导致链接错误。因为inlinn函数被展开，也就不会有函数地址，自然不用提去链接了。 1234567891011121314151617181920//func.h文件#pragma once#include&lt;iostream&gt;using namespace std;inline void f(int i);//func.cpp文件#include&quot;test.h&quot;void f(int i){ cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;}//main.cpp文件#include&quot;test.h&quot;int main(){ f(1); return 0;} 报错：error LNK2019: 无法解析的外部符号 “void __cdecl f(int)” (?f@@YAXH@Z)，函数 main 中引用了该符号。 如果想要一个函数成为内联，但是类的定义和类实例化的地方在不同的源文件（声明定义分离），那么最好是将此函数定义在类中。 对于内联函数，其工作原理是： 对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。 各个文件是分离编译的，在func.c中由于声明了f函数是内联的，并且函数体也很简短，因此编译器遵循了我们的建议，使其成为一个内联函数，由于没有函数地址，自然无法被除本源文件以外的地方调用；也可以说内联函数在符号表不会有合并这一步操作，仅仅存在于本源文件中。 内联函数的缺点难道内联函数就没有缺点吗，当然有！不然还要函数做什么？内联函数随着一次次的调用展开，会造成代码膨胀的问题，通俗讲就是生成的可执行文件会变大，这是我们不愿意看到的（有谁愿意看着自己的电脑硬盘被榨干呢？） 可以大致从几个方面看： 编译后的程序会存在多份相同的函数指令拷贝，这些函数拷贝编译后都是二进制的指令，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大。 可执行程序在运行前要先载入内存，程序的执行就是一步步去内存取指令然后交给CPU执行的过程，可以试想可执行文件大，那么其指令也就越多，载入内存后消耗的空间也越大。 ​ 很好理解，普通的函数都有一个地址，每当我们需要使用这个函数时，直接通过函数名访问地址，然后就是建立栈帧的过程，在新栈帧中执行相应函数指令。 ​ 内联函数没有它的地址，我们需要调用这个函数时，只能临时拷贝一份，再执行相应指令。 ​ 举一个例子就是，普通函数就是一个坚信好 “记性不如烂笔头的乖学生”，老师讲一个重要的、多次使用的知识点时，他就记在笔记本上，需要了就拿出来看看就会了。内联函数也是一个爱记笔记的学生，不过它丢三落四的，刚记下笔记笔记本就丢了，每次需要时，就只能又去问老师再记下来，慢慢的他写过的笔记本就很多了，不过他自己还浑然不知。 ​ 他们两个同学的笔记本都是一个作用，就是记录下这个知识，但是随着使用次数的增加，这位有收拾的同学只需要一个笔记本就能终生受用，而这位丢三落四的同学则会随着记了又丢，丢了又记的过程产生很多个笔记本，内联函数也是同样的道理。 那么它们的过程实际区别如下： ​ 在程序载入过程中，两个函数体内容相同的普通函数和内联函数，普通函数的函数指令只向内存中载入了一次，之后每次调用此函数都只需要一条指令，直接访问其函数地址并取指令。 ​ 内联函数不会载入内存，没有函数地址。在编译后这些调用内联函数的语句都会被展开为内联函数的指令（做了一些特殊处理，并不是完全复制的函数体指令），由于编译后内联函数展开部分就只是一条条的指令，这些指令都会被载入内存，可以看到这里调用了多少次，内联就展开了多少次，展开的指令都会被载入内存，可以等效于调用了几次就将内联函数的指令载入了几次到内存。 那么也就得出差异，普通函数只需要载入内存一次，而内敛函数是调用了几次就会载入内存几次。 如果内联函数调用次数很多，调用结束后由于调用所产生的内存消耗并不会被释放（普通函数调用结束后栈帧会销毁） ​ 如图： 总体来说，如果除去开辟栈帧的花销，内联函数和普通函数的所执行的指令数、时间几乎是相同的，重点在于如何把控执行一个函数时，它开辟的栈帧的消耗占整个函数调用的比重，如何把控这个比重，决定了我们是否建议一个函数为内联。 我们来写个程序验证一下，并从指令的角度来看： 12345678910111213inline void func(){ cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;}int main(){ func(); func(); func(); func(); return 0;} 来看看内联函数的汇编指令： 12345678910111213141516171819202122232425262728 func();00007FF6AA4D1522 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D1529 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1530 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D1535 lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D153C mov rcx,rax 00007FF6AA4D153F call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D1545 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D154C mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1553 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D1558 lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D155F mov rcx,rax 00007FF6AA4D1562 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D1568 lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D156F mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1576 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D157B lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D1582 mov rcx,rax 00007FF6AA4D1585 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] func();00007FF6AA4D158B lea rdx,[string &quot;func&quot; (07FF6AA4DAE64h)] 00007FF6AA4D1592 mov rcx,qword ptr [__imp_std::cout (07FF6AA4E0198h)] 00007FF6AA4D1599 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF6AA4D1046h) 00007FF6AA4D159E lea rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF6AA4D1014h)] 00007FF6AA4D15A5 mov rcx,rax 00007FF6AA4D15A8 call qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF6AA4E01B0h)] 接着我们取消内联再来看看： 12345678 func();00007FF679261572 call func (07FF679261285h) func();00007FF679261577 call func (07FF679261285h) func();00007FF67926157C call func (07FF679261285h) func();00007FF679261581 call func (07FF679261285h) 差别还是蛮大的，这些指令都会在运行时载入内存，造成代码膨胀。 一些其他不足 通常，编译器比程序设计者更清楚对于一个特定的函数是否合适进行内联扩展；一些情况下，对于程序员指定的某些内联函数，编译器可能更倾向于不使用内联甚至根本无法完成内联。 对于一些开发中的函数，它们可能从原来的不适合内联扩展变得适合或者倒过来。尽管内联函数或者非内联函数的转换易于宏的转换，但增加的维护开支还是使得它的优点显得更不突出了。 对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。 判断是否设置为内联：一般只将那些短小的、频繁调用的函数声明为内联函数。 最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。 auto关键字auto为自动的意思，C语言中貌似也有提到过（自动变量什么的，记不清了几乎没使用过），那么在C++中auto有什么作用、应用于哪些场景呢？ auto简介 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它，大家可思考下为什么？ C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。 12345678910111213int main(){ auto a = 1; auto b = 2.0; auto c = 2.0f; auto d = 'w'; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; cout &lt;&lt; typeid(d).name() &lt;&lt; endl; return 0;}//auto e;无法通过编译。 既然是编译期间自动推导类型，那么就说明一定得初始化咯。 使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。 详细使用规则既然是占位符则说明auto可以是任何类型，而不一定是对其进行初始化数据的类型。 auto和指针结合起来使用 ​ 用auto声明指针类型时，用auto和auto*没有任何区别，但是auto对于引用的声明必须加上&amp;； 12345678910111213141516int main(){ int a = 10; auto p1 = &amp;a;//auto在编译时会被替换为int* auto* p2 = &amp;a;//auto在编译时会被替换为int int&amp; ref = a; auto ref1 = ref;//ref是a的别名，因此推导出是int类型 ref1 = 12;//a并不会改变 cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(ref).name() &lt;&lt; endl; cout &lt;&lt; typeid(p1).name() &lt;&lt; endl; cout &lt;&lt; typeid(p2).name() &lt;&lt; endl; cout &lt;&lt; typeid(ref1).name() &lt;&lt; endl; return 0;} 同一行定义多个变量 ​ 在同一行定义多个变量时，这些变量的类型必须相同，否则编译器会报错，因为编译器实际只对第一个类型进行推导，然后替换为auto，并用该类型定义其他变量。 12345int main(){ auto a = 1, b = 1.0; return 0;} 在声明符列表中，“auto”必须始终推导为同一类型 这样看auto好像还挺万能的，那么auto能适用于所以场景吗？ auto不能推导类型的场景 不能作为函数的形参 12345// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a和b的实际类型进行推导int Add(auto a, auto b){ return a + b;} error C3533: 参数不能为包含“auto”的类型 函数在编译时是需要形参类型来确定修饰后函数名的，所以形参类型要先确定。 这种显然是不可行的，如果可以直接使用auto推导，那么就没后面的模板什么事了。 注：返回值是可以用auto的。 不能用来直接声明数组 12345int main(){ auto arr[] = { 1,2,3,4,5 }; return 0;} error C3318: “auto []”: 数组不能具有其中包含“auto”的元素类型 error C3535: 无法推导“auto []”的类型(依据“initializer list”) 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法 auto为了在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用 基于范围的for循环for循环是我们非常熟悉的，用法也比较单一，通常在知道循环次数的情况下使用，那么什么是范围for呢？ 范围for的语法C++98中如果我们要遍历一个数组通常是下面这种方式： 12345678void TestFor(){ int array[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i) array[i] *= 2; for (int* p = array; p &lt; array + sizeof(array) / sizeof(array[0]); ++p) cout &lt;&lt; *p &lt;&lt; endl;} 对于一个范围已知的集合而言，由我们来说明循环的范围显然是多余的，有时候不注意还会出错。因此C++11中引入了基于范围的for循环。for循环后的括号由冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。 12345678void TestFor(){ int array[] = { 1, 2, 3, 4, 5 }; for (auto&amp; e : array) e *= 2; for (auto e : array) cout &lt;&lt; e &lt;&lt; &quot; &quot;;} 循环体内就和普通的循环一样了，我们可以使用break跳出循环，也可以使用continue结束本次循环，只不过是编译器帮助我们确定迭代的范围而已。 范围for的使用条件 for循环迭代的范围是确定的 对于数组而言，迭代的范围就是从第一个元素到最后一个元素； 对于类而言，应该提供begin以及end的方法，循环的范围就是从begin到end； 也就是说我么给for的应该是一组数据集合，例如数组，链表等等… 看看一下代码是否有问题： 12345void TestFor(int array[]){ for (auto&amp; e : array) cout &lt;&lt; e &lt;&lt; endl;} “begin”: 未找到匹配的重载函数 显然是有问题的，数组名作为形参，其本质上是一个指针，指针是一组数据的集合吗？？显然不是。 迭代的对象的迭代器要实现++和==的操作。(关于迭代器这个问题，以后会讲，现在大家了解一下就可以了) ​ 可以先简单说说迭代器，迭代器就是一个封装后的指针，通过这个封装后的指针我们可以通过地址找到数据的存储位置。为什么要封装呢？因为对于原生指针我们执行++操作，它是在相邻的位置移动，这样对于链表等数据结构是无法正确访问的，可如果我们对++操作符进行重载，就可以让它根据他的存储特性去移动指针了！ 新的指针空值nullptr C++11从学习C语言之初，我们就说要养成一个好习惯——声明一个变量时给一个合适的初值，否则可能会出现不可预料的错误，比如未初始化的指针。如果当前指针没有明确的指向，那么可以给其赋值为空； 123456int main(){ int* p = NULL; int* p1 = 0; return 0;} 这两者其实是一样的，NULL其实是一个宏，即是0值； 在传统C头文件里(stddef.h)中，可以看到如下代码： 1234567#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如： 123456789101112131415void func(int){ cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;}void func(int*){ cout &lt;&lt; &quot;f(int*)&quot; &lt;&lt; endl;}int main(){ func(0); func(NULL); func((int*)NULL); return 0;} 我们的本意是让func(NULL)去调用void func(int*)的，但却出现了问题，由于NULL被定义成0，而0默认被当做一个整型，因此与程序的初衷相悖。 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。 因此在C++程序中我们更倾向使用nullptr而不是NULL，来看看nullptr是什么。 12345678int main(){ int* p = NULL; int* p1 = 0; cout &lt;&lt; &quot; &quot; &lt;&lt; typeid(NULL).name() &lt;&lt; endl; cout &lt;&lt; &quot; &quot; &lt;&lt; typeid(nullptr).name() &lt;&lt; endl; return 0;} 注意： 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。 在C++11中，sizeof(nullptr) 与 sizeof((void)0)所占的字节数相同。* 为了提高代码的健壮性（适用于更多场景），在后续表示指针空值时建议最好使用nullptr。","link":"/2023/01/12/C++/2.C++%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"C++和C的混合编译","text":"简介C++ 语言的创建初衷是 “a better C”，但是这并不意味着 C++ 中类似 C 语言的全局变量和函数所采用的编译和连接方式与 C 语言完全相同。作为一种欲与 C 兼容的语言， C++ 保留了一部分过程式语言的特点（被世人称为”不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是， C++ 毕竟是一种面向对象的程序设计语言，为了支持函数的重载， C++ 对全局函数的处理方式与 C 有明显的不同。 本文将介绍如何通过 extern “C” 关键字在 C++ 中支持 C 语言 和 在C语言中如何支持 C++。 某企业曾经给出如下的一道面试题为什么标准头文件都有类似以下的结构？ 123456789101112131415//head.h#ifndef HEAD_H#define HEAD_H#ifdef __cplusplusextern &quot;C&quot; {#endif /*...*/#ifdef __cplusplus}#endif#endif /* HEAd_H */ 问题分析 这个头文件head.h可能在项目中被多个源文件包含（#include “head.h”），而对于一个大型项目来说，这些冗余可能导致错误，因为一个头文件包含类定义或inline函数，在一个源文件中head.h可能会被#include两次（如，a.h头文件包含了head.h，而在b.c文件中#include a.h和head.h）——这就会出错（在同一个源文件中一个结构体、类等被定义了两次）。 从逻辑观点和减少编译时间上，都要求去除这些冗余。然而让程序员去分析和去掉这些冗余，不仅枯燥且不太实际，最重要的是有时候又需要这种冗余来保证各个模块的独立。 为了解决这个问题，上面代码中的 1234#ifndef HEAD_H#define HEAD_H/*……………………………*/#endif /* HEAD_H */ 就起作用了。如果定义了HEAD_H，#ifndef/#endif之间的内容就被忽略掉。因此，编译时第一次看到head.h头文件，它的内容会被读取且给定HEAD_H一个值。之后再次看到head.h头文件时，HEAD_H就已经定义了，head.h的内容就不会再次被读取了。 那么下面这段代码的作用又是什么呢？ 1234567#ifdef __cplusplusextern &quot;C&quot; {#endif/*.......*/#ifdef __cplusplus}#endif 我们将在后面对此进行详细说明。 关于 extern “C”前面的题目中的 __cplusplus 宏，这是C++中已经定义的宏，是用来识别编译器的，也就是说，将当前代码编译的时候，是否将代码作为 C++ 进行编译。 首先从字面上分析extern “C”，它由两部分组成：extern关键字、”C”。下面我就从这两个方面来解读extern “C”的含义。 首先，被它修饰的目标是 extern 的；其次，被它修饰的目标是 C 的。 extern关键字被 extern “C” 限定的函数或变量是 extern 类型的。 extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。 被extern修饰的函数，需要在编译阶段去链接该目标文件，并且与extern对应的关键字是 static，被static修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其一般是不可能被extern “C”修饰的。 注意：例如语句 extern int a; 仅仅是对变量的声明，其并不是在定义变量 a ，声明变量并未为 a 分配内存空间。定义语句形式为 int a; 变量 a 在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和连接的。 由于C++和C两种语言的亲密性，并且早期大量的库都是由C语言实现的，所以不可避免的会出现在C++程序中调用C的代码、C的程序中调用C++的代码，但是它们各自的编译和链接的规则是不同的。 函数名修饰 由于Windows下vs的修饰规则过于复杂，而Linux下gcc的修饰规则简单易懂，下面我们使用了gcc演示了这个修饰后的名字。 通过下面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+类型首字母】。 分别使用C的编译器和C++的编译器去编译并获得一个可执行文件 使用C语言（gcc）编译器编译后结果 使用objdump -S 命令查看gcc生成的可执行文件： 使用C++编译器（g++）编译后结果 使用objdump -S 命令查看g++生成的可执行文件： linux：修饰后的函数名= _Z + 函数名长度 + 形参类型首字母，Windows下也是相似的，细节上会有所不同，本质上都是通过函数参数信息去修饰函数名。 C++的编译和链接方式 采用g++编译完成后，函数的名字将会被修饰，编译器将函数的参数类型信息添加到修改后的名字中，因此当相同函数名的函数拥有不用类型的参数时，在g++编译器看来是不同的函数，而我们另一个模块中想要调用这些函数也就必须使用C++的函数名修饰规则去链接函数（找修饰后的函数名）才能找到函数的地址。 C的编译和链接方式 对于C程序，由于不支持重载，编译时函数是未加任何修饰的，而且链接时也是去寻找未经修饰的函数名。 C和C++直接混合编译时的链接错误 在C++程序，函数名是会被参数类型信息修饰的，这就造成了它们之间无法直接相互调用。 例如： print(int)函数，使用g++编译时函数名会被修饰为 _Z5printi，而使用gcc编译时函数名则仍然是print，如果直接在C++中调用使用C编译规则的函数，会链接错误，因为它会去寻找 _Z5printi而不是 print。 【C和C++的编译和链接方式的不同】参考： C++的函数重载 - 吴秦 - 博客园 extern“C”的使用extern “C”指令非常有用，因为C和C++的近亲关系。注意：extern “C”指令中的C，表示的一种编译和连接规约，而不是一种语言。 并且extern “C”指令仅指定编译和连接规约，并不影响语义，编译时仍是一个C++的程序，遵循C++的类型检查等规则。 对于下面的代码它们之间是有区别的 1234extern &quot;C&quot; void Add(int a, int b);//指定Add函数应该根据C的编译和连接规约来链接extern void Add(int a, int b);//声明在Add是外部函数，链接的时候去调用Add函数 如果有很多内容要被加上extern “C”，你可以将它们放入extern “C”{ }中。 通过上面的分析，我们知道extern “C”的真实目的是实现类C和C++的混合编程，在C++源文件中的语句前面加上extern “C”，表明它按照类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约。这样在类C的代码中就可以调用C++的函数or变量等。 那么混合编译首先要处理的问题就是要让我们所写的C++程序和C程序函数的编译时的修饰规则和链接时的修饰规则保持一致。 总共就有下面四种情况，也就是说一个C的库，应该能同时被C和C++调用，而一个C++的库也应能够同时兼容C和C++。 为了展示如上四种情况，我们分别建立一个C静态库和C++静态库。 C程序能调用C的库，C++程序能调用C++的库，这是理所应当的，因此我们关注的问题是如何交叉调用。 用法举例静态库是什么库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常，之所以称为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。 试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结： 静态库对函数库的链接是放在编译时期完成的。 程序在运行时与函数库再无瓜葛，移植方便。 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大 创建C静态库我们以一个栈的静态库为例： 首先新建项目Stack_C 新建源文件和头文件 写好栈的代码 注意一定是C程序，即源文件后缀为c 更改输出文件类型 右键项目名称—&gt;属性 更改为配置类型为静态库 生成静态库 查看是否生成成功 VS一般在项目路径下的x64\\Debug路径下： 至此，静态库已经可以成功建立了。 再新建一个项目，写一个去调用该静态库实现的栈的程序（以括号匹配问题为例） 不过对于VS我们的静态库是默认不去使用的，因此我们需要将静态库的路径和库的名称分别添加到库目录和依赖项，才能让程序能去调用该静态库。 更改链接器配置 右键项目名—&gt;点击属性 “属性面板“—&gt;”配置属性”—&gt; “链接器”—&gt;”常规”，附加依赖库目录中输入，静态库所在目录； 增加库目录（路径为我们刚刚生成的静态库所在的Debug文件夹） 增加附加依赖项 名称为Stack_C项目生成的静态库名，一般是项目名 + .lib “属性面板”—&gt;”配置属性”—&gt; “链接器”—&gt;”输入”，附加依赖库中输入静态库名StaticLibrary.lib。 我们先尝试使用C程序来调用该静态库 新建项目 将源文件后缀改为c； 包含上Stack_C项目（静态库项目）的头文件； 点击生成解决方案； 成功生成，说明成功调用。 尝试使用C++程序调用C静态库 将源文件后缀改为cpp； 头文件保持不变； 点击生成解决方法； 结果报错了： 这说明在链接的过程中出现了问题，也就是在我们的程序找不到静态库中函数的地址，原因是我们的静态库是C语言的，没有对函数进行修饰，但在我们的调用方是C++程序，在链接过程中找的是修饰过的函数名，因此无法找到函数的地址。 既然C语言的静态库只能按照C的规则去编译这些函数（即不修饰函数名），那么我们只要让C++程序按照C语言的链接规则（即找未经修饰的函数名）去找到函数不就解决了？ 首先可以确定的是，C的库所遵守的规则必然是C的，那么C程序来调用该库是没问题的，但是如果是C++调用该库就会由于双方遵守的规则的不同而链接错误。 解决的两种思路： 改变C库的编译和链接方式为C++规则； 改变C++程序调用库函数的编译和链接方式为C的规则； 方法1是不行的，因为C语言中可没有extern “C++”这种东西，那么考虑方法2； 这时我们可以借助extern“C”改变C++程序的链接规则，让C++去按照C的规则去找函数名，即未经过任何修饰的函数名，那就一定能找到函数的地址，来去正确调用静态库。 在源文件test.cpp使用extern “C”，去改变包含的头文件中的函数的链接规则。 1234567//调用库的的模块的头文件包含extern &quot;C&quot;{ #include&quot;..\\..\\Stack_C\\Stack_C\\stack.h&quot;}//程序的代码//... 那么在test.cpp去链接这些库函数时，就会直接去找未被修饰的原函数名。 这样就解决了。 还有一个一步到位的解决方法，利用条件编译，根据当前程序的类型，选择是否去执行extern “C”指令。 调用方是C程序，不做处理； 调用方是C++程序，需要使用extern“C”将程序改为C的链接规则； 12345678910//调用库的的模块的头文件包含#ifdef __cplusplus//如果是c++程序，就执行extern “C”，使用C的链接方式，去找未经修饰的函数名extern &quot;C&quot;{#endif#include&quot;..\\..\\Stack_C\\Stack_C\\stack.h&quot;#ifdef __cplusplus}#endif//程序的代码//... 但是这样的处理不太好，我们作为调用方自然是想可以直接通过头文件包含的方式就能使用库里的函数，因此采用下列方法，更改库的头文件函数声明为： 1234567891011121314#ifdef __cplusplus//如果定义了宏__cplusplus就执行#ifdef 到 #endif之间的语句extern &quot;C&quot;{#endifvoid StackInit(struct Stack* s);void StackPush(struct Stack* s, DataType x);void StackPop(struct Stack* s);DataType StackTop(struct Stack* s);int StackSize(struct Stack* s);void StackDestory(struct Stack* s);bool StackEmpty(struct Stack* s);#ifdef __cplusplus}#endif 库的规则： 库是C的静态库，条件编译会忽略extern“C”，并且它的编译和链接规则是无法改变的，只能是C的规则。 调用方的规则： 若是C程序去调用，条件编译忽略掉extern“C”，程序不会报错，并且C程序所遵守的规则与库的规则是一致的，可以正常调用； 若是**C++**程序去调用，条件编译extern“C”就会生效，使得调用方去使用这几个库函数时的规则不再遵守C++的规则而是C的规则，从而可以正常调用； 这样的一段代码，无论是C++程序还是C程序都可以直接#include头文件路径就能去调用该静态库了。 创建C++静态库步骤和创建C的静态库相同，只不过要将项目中的源文件后缀改为cpp，就会生成一个C++的静态库，因此不再阐述。 创建完成后，我们仍使用刚刚的项目，并且添加C++静态库路径到库目录，添加C++静态库名称到附加依赖项，仍然以括号匹配问题为例去调用该库。（记得删除C静态库的库目录和附加依赖项，否则我们的程序有可能还会去调用C的静态库，这样我们就无法探究如何去调用C++静态库的问题了） 尝试使用C程序调用C++静态库我们不着急调用，经过先前的经验，这里可以判断，C++的程序去调用C++的库一定是没问题的，但是C程序就不好说了，因此我们要搞定C程序调用C++库的情况，先搞清楚它们的差异： 首先C++的库若不经任何处理，那么它编译链接规则一定是遵守C++的规范的，但是这样的话C程序调用它，无论如何也无法正常调用的。 那么换种思路，使用extern“C”让C++的库的规则改为C的规则，那么这样C程序是一定可以调用该C++的库的，而C++程序则会因为双方所遵守的规则不同而链接错误。 这样的话相当于C++库被改为了C的库，仍然使用C++程序调用C的库的解决方案： 改变C++程序调用库函数的编译和链接方式为C的规则； 如果对库的头文件中的函数做如下处理： 1234567891011//用C的规则去搞 库的编译和链接方式extern &quot;C&quot;{ void StackInit(struct Stack* s); void StackPush(struct Stack* s, DataType x); void StackPop(struct Stack* s); DataType StackTop(struct Stack* s); int StackSize(struct Stack* s); void StackDestory(struct Stack* s); bool StackEmpty(struct Stack* s);} 那么现在C++的静态库的函数名都是没有经过修饰的。（C的规则） 但是我们去编译仍然报错： error C2059: 语法错误:“字符串” “StackInit”未定义；假设外部返回int “StackPush”未定义；假设外部返回int “StackEmpty”未定义；假设外部返回int “StackTop”未定义；假设外部返回int “StackPop”未定义；假设外部返回int 这是因为我们使用C程序时也包含了此头文件，头文件展开后C语言中无法识别extern“C”，因此报错。 我们尝试使用条件编译来决定是否使用extern“C”，根据调用方的不同改变函数链接规则： 调用方是C++程序，那么需要使用extern“C”将C++程序的函数链接规则变为C的； 调用方是C程序，不使用extern“C”语句做处理； 因此我们做如下处理，将库的头文件中的函数声明加上： 1234567891011121314#ifdef __cplusplus//如果定义了宏__cplusplus就执行#ifdef 到 #endif之间的语句extern &quot;C&quot;{#endifvoid StackInit(struct Stack* s);void StackPush(struct Stack* s, DataType x);void StackPop(struct Stack* s);DataType StackTop(struct Stack* s);int StackSize(struct Stack* s);void StackDestory(struct Stack* s);bool StackEmpty(struct Stack* s);#ifdef __cplusplus}#endif 库的规则： 如此一来，C++静态库的上面这些函数，都是遵守C语言的编译和链接规则的。 调用方的规则： 如果是C的程序来调用，调用方的extern“C”被条件编译忽略，库和调用方的规则是一致的，可以正常调用； 如果是**C++**的程序来调用，那么调用方的extern “C”就会发挥作用，让调用方也是遵守C的规则，与库的规则一致，就可以正常调用了； 总结：C++和C之间的混合编译，为了消除函数名修饰规则不同的的差别，我们需要使用extern ”C“来改变C++的编译和连接方式。 但这样问题也随之而来： 被extern“C”的C++的库函数就失去了函数重载的特性，如果库的这些函数中有同名函数，那么就无法正确编译，因为按照C的方式去编译，函数名会冲突。 如何解决这个问题呢？ 实际上这个问题无法解决，一旦选择了将某个函数指定了按照C的方式去编译链接，那么这个函数就已经失去了重载的特性了，不过Cpp的库中未被指定按照C的规则去编译和链接的那些函数，仍然可以被重载，并且具有C++的一切特性。 因此这个问题无解，只有通过避免“一刀切”的方法来保护那些我们想重载的函数，也就是说一部分库里的函数是实现给C程序调用的，我们就通过extern“C”改变它的编译和链接方式，而对于那些实现给C++程序调用的函数接口，我们不做任何处理，并且不暴露给C程序。 想要实现上述过程，我们需要在静态库项目中创建两个头文件libc.h和libcpp.h，libc.h声明那些需要暴露给C程序的函数接口，并且使用上面介绍的条件编译和extern“C”，libcpp.h声明那些暴露给给Cpp程序的函数接口，这样两个头文件的函数的链接规范互不相同，也互不干扰。只需要将lic.h在C程序调用的地方使用#include 包含，libcpp.h在C++程序调用的地方使用#include包含即可使用。 因此C++库中哪个接口需要暴露给C，我们就用extern“C”修饰哪个接口。 总之，C的库可以给C程序和C++程序调用，而C++库也可以被C程序和C++程序调用 如果要满足这个库中所有的函数都能同时被C++和C调用，那么无论是C的库还是C++的库，最终这个库的编译和链接方式都只能是C的规范，因为C++可以使用C的链接规范但是C不能使用C++的链接规范，也就导致了如果库的链接规范是C++的，那么无论如何，C程序都无法调用。 值得一提的是C++程序中的函数可以使用两种链接规范，因此我们可以针对函数的使用场景来选择该函数的编译和链接规范，使得一部分函数保留C++的特性，但一部分函数就只能为了兼容C而牺牲C++的特性，想要既兼容C又保留C++的特性，这是做不到的。","link":"/2023/01/12/C++/3.C++%E5%92%8CC%E7%9A%84%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91/"},{"title":"C++类和对象","text":"面向过程和面向对象初步认识 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。 C++是基于面向对象的，关注的是对象，将一件事拆分成不同的对象，靠对象之间的交互完成。 以外卖点餐系统为例： 外卖点餐有具体步骤有顾客点餐，商家做餐，外卖员送餐，C语言关注的是点餐的各个步骤，即点餐、做餐和送餐的过程，而C++则是关注顾客、商家、外卖员这三个对象，依托三个对象之间的交互来完成点餐的过程。 类的引入C语言中，结构体内只能定义变量，而在C++中结构体内不仅可以定义变量，还可以定义函数。 1234567891011121314151617181920212223struct Student{ void SetStudentInfo(const char* name, const char* gender, int age) { strcpy(_name, name); strcpy(_gender, gender); _age = age; } void PrintStudentInfo() { cout &lt;&lt; _name &lt;&lt; &quot; &quot; &lt;&lt; _gender &lt;&lt; &quot; &quot; &lt;&lt; _age &lt;&lt; endl; } char _name[20]; char _gender[3]; int _age;};int main(){ Student s; s.SetStudentInfo(&quot;songxin&quot;, &quot;male&quot;, 20); s.PrintStudentInfo(); return 0;} struct是C语言中定义结构体的关键字，在C++中更倾向使用class代替 类的定义12345class classname{ //函数 //成员};//注意这里有分号 class为定义类的关键字，classname为类的名称。**{}中为类的主体，注意类的定义后面要加分号**。 类中的元素称为类的成员：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。 类的两种定义方式： 声明和定义都放在类体中，需要注意的是：成员函数如果在类体中定义，则默认会给编译器建议使此函数成为内联。 声明和定义分离 一般来说我们更青睐第二种方式，即使这样写会麻烦一些。 类的访问限定符及封装C语言中的结构体并没有访问限定符和封装的概念，我们可以对结构体中的内容随意访问并且修改，这就很考验程序员的素养，人人都可以修改结构体的数据，这就会带来一些不可预知的问题。 无规矩不成方圆，我们无法去赌每一个程序员都是能按照规范编写程式，因此C++引入了访问限定符来限制我们对类中成员的权限。 访问限定符C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。 访问限定符如上图，有三种权限分别设置为公有、保护、私有。 访问限定符说明 public修饰的成员在类外可以直接被访问 protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的) 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 class的默认访问权限为private，struct为public(因为struct要兼容C) 既然被保护的成员不能被外部通过对象所直接访问，那么在成员函数中呢？ 1234567891011121314151617181920class Time{public: Time(int hour = 0, int minute = 0, int second = 0) : _hour(hour), _minute(minute), _second(second) {} Time(Time&amp; t) { _hour = t._hour;//通过另一个对象名直接访问了私有成员函数 _minute = t._minute; _second = t._second; }private: int _hour; int _minute; int _second;}; 有两个解释方法： Time是成员函数属于类，而访问限定符限制的是外部，在类域中可以随意访问。 相同class的实例化出的各个对象互为友元。 注意：访问限定符仅在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别。 来看看下面这个问题 C++中struct和class的区别是什么？ C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是的成员默认访问方式是private。 封装面向对象三大特性：封装、继承、多态。 在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？ 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。 封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的不是全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是管理。 类的作用域类新定义了一个作用域，类的所以成员都在类的作用域中。在类外定义成员，需要使用::作用域解析符来指明成员属于哪个类。 12345678910111213141516class Person{public: void PrintPersonInfo();private: char _name[20]; char _gender[3]; int _age;};//类外定义成员函数需要加上::作用域解析符void Person::PrintPersonInfo(){ cout &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; _gender &lt;&lt; endl; cout &lt;&lt; _age &lt;&lt; endl;} 总之，封装有利于管理类的对象，让对象的处理操作更加统一，对于一些我们不想给外界直接访问的成员可以设置为私有，对于需要被外部使用的成员设置为公有，这样的封装设计让我们的程式更加规范安全。 类的实例化 用类去创建对象的过程，称为类的实例化。 类形象的说就是一个模具，我们可以使用设计好的模具去制作出实体对象。 类只声明了类有哪些成员，而并没有为成员分配内存空间。 一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量。 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间。 类对象模型计算类对象的大小1234567891011121314class Person{public: void PrintPersonInfo();private: int _age;};int main(){ Person p; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; cout &lt;&lt; sizeof(p) &lt;&lt; endl; return 0;} 输出： 4 4 这里使用sizeof计算Person类的大小和Person类定义出来的对象大小是一样的。 类对象的存储方式 如果对象中包含类中的所有成员 缺陷：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么如何解决呢？ 只保存成员变量，成员函数指令放在公共的代码段 这里需要给大小 说说内存中的分区，C++程序的内存格局通常分为四个区：静态区(static area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。静态区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。 根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量是存储在静态区的，即实例化的对象并不包括静态变量的创建，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。 那么肯定是第二种存储方式更节省空间，那么实际中到底是哪种存储方式呢？ 依然使用刚刚的代码，简单变形一下 123456789101112131415161718192021222324//即有成员变量又有成员函数class Person1{public: void PrintPersonInfo();private: int _age;};//仅有成员变量class Person2{private: int _age;};//空类class Person3{};int main(){ cout &lt;&lt; sizeof(Person1) &lt;&lt; endl; cout &lt;&lt; sizeof(Person2) &lt;&lt; endl; cout &lt;&lt; sizeof(Person3) &lt;&lt; endl; return 0;} 输出： 4 4 1 很显然，我们计算对象的大小和是否含有成员函数无关（也就是说成员函数存储在代码区），对象中也不存放成员函数的指针。 结论：一个类的大小，实际就是该类中”成员变量”大小之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。 注：这里的成员变量之和并不是简单的字节数相加，而是还要遵循内存对齐规则。 结构体内存对齐规则 第一个成员在与结构体偏移量为0的地址处。 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 ​ 注意：对齐数 = 编译器默认的一个对齐数与该成员大小的较小值。​ VS中默认的对齐数为8; 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 这里的规则和C语言的规则是一样的，就不再展开讲了。 this指针123456789101112131415161718192021222324252627class Date{public: void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; } void SetDate(int year, int month, int day) { _year = year; _month = month; _day = day; }private: int _year; // 年 int _month; // 月 int _day; // 日};int main(){ Date d1, d2; d1.SetDate(2018, 5, 1); d2.SetDate(2018, 7, 1); d1.Display(); d2.Display(); return 0;} 对于上述程序，d1和d2各自有不同的内存空间，可我们的成员函数SetDate中却并没有指定要对哪一个对象的成员进行操作，那么当d1调用时函数是如何知道操作的对象是哪一个呢？ C++中通过引入this指针解决该问题，即：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。 注：实参形参中不能显式地去写this指针。 因此程序还可以这样写： 123456789101112131415161718192021222324252627class Date{public: void Display() { cout &lt;&lt; this-&gt;_year &lt;&lt; &quot;-&quot; &lt;&lt; this-&gt;_month &lt;&lt; &quot;-&quot; &lt;&lt; this-&gt;_day &lt;&lt; endl; } void SetDate(int year, int month, int day) { this-&gt;_year = year; this-&gt;_month = month; this-&gt;_day = day; }private: int _year; // 年 int _month; // 月 int _day; // 日};int main(){ Date d1, d2; d1.SetDate(2018, 5, 1); d2.SetDate(2018, 7, 1); d1.Display(); d2.Display(); return 0;} 实际上我们不写this-&gt;成员，比那一起也会这样给我们处理。 this指针的特性 this指针的类型：TypeOfClass* const，this指针在函数体内不可修改。 只能在“成员函数”的内部使用。 this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参，对象中并不存储this指针。 this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递。 如下两种写法并无差别 关于this指针this指针的存储位置在哪里？ 临时变量都是存储在栈上的，因此this指针作为形参，存储在栈区。 this指针可以为空指针吗？ 1234567891011121314151617181920class A{public: void PrintA() { cout &lt;&lt; _a &lt;&lt; endl; } void Show() { cout &lt;&lt; &quot;Show()&quot; &lt;&lt; endl; }private: int _a;};int main(){ A* p = nullptr; p-&gt;Show(); p-&gt;PrintA();} 要知道0地址处我们是没有访问权限的，若非法访问程序会崩溃。 这里的程序其实Show是可以正常调用，而PrintA是无法正常运行的。 来看看PrintA函数体的汇编指令（部分） 首先Show可以正常调用，说明并不是p为空指针了就无法通过p调用函数了，调用函数访问的是函数的地址，而虽然它们都是成员函数，但是它们都存储在公共代码区，并不是在0地址处去访问函数，所以调用函数并没有问题，问题出在PrintA中的 cout &lt;&lt; _a &lt;&lt; endl;语句访问了_a成员变量，而p又是指向0地址处，因此就相当于访问了0地址处的数据，因此程序崩溃。 this指针可以为空指针，但切忌通过nullptr去访问指向的数据。","link":"/2023/01/12/C++/5.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"C++构造函数","text":"类的6个默认成员函数如果我们写了一个类，这个类我们只写了成员变量没有定义成员函数，那么这个类中就没有函数了吗？并不是的，在我们定义类时即使我们没有写任何成员函数，编译器会自动生成下面6个默认成员函数。 12345class S{public: int _a;}; 这里就来详细介绍一下构造函数。 构造函数使用C语言，我们用结构体创建一个变量时，变量的内容都是随机值，要想要能正确的操作变量中存储的数据，我们还需要调用对应的初始化函数，给成员变量赋一个合适的初值。那么C++呢，我们仍然使用这个方法来试试。 123456789101112131415161718192021222324252627class Date{public: void SetDate(int year, int month, int day) { _year = year; _month = month; _day = day; } void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1, d2; d1.SetDate(2018, 5, 1);//初始化 d1.Display(); d2.SetDate(2018, 7, 1);//初始化 d2.Display(); return 0;} 完全没问题的，毕竟C++完全兼容C嘛，不过这样子做未免有点麻烦，能不能做到我一创建好对象，对象的成员变量就是已经被初始化了而不是我们主动去调用呢？于是C++提供了一个特殊的函数：构造函数。 构造函数是一个特殊的成员函数，名字与类名相同，无返回值，每次使用类实例化对象时会自动调用，保证每个数据成员都有一个合适的初值，方便我们的后续使用，构造函数在对象的生命周期内只会被调用一次。 特性虽然叫构造函数，但它的作用并不是构造一个对象（申请空间创建对象），而是初始化对象。 特征如下 函数名与类名相同； 无返回值； 对象实例化时编译器自动调用对应的构造函数； 构造函数可以重载； 1234567891011121314151617181920212223242526272829303132class Date{public: Date()//无参的构造函数 { } Date(int year, int month, int day)//带参的构造函数 { _year = year; _month = month; _day = day; } void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1;//调用无参的构造函数 Date d2(2001, 7, 28);//调用带参的构造函数 d1.Display(); d2.Display(); Date d3();//这种写法要不得，会被当做函数名为d3，无参、返回类型为Date的函数声明。 //调用无参的构造函数，一定不要加()否则编译器无法识别这是一个函数声明还是调用的无参构造。 return 0;} 如果编译器没有显式的定义构造函数，编译器会自动生成一个无参的默认构造函数，一旦我们显式定义，编译器就不再生成； 123456789101112131415161718class Date{public: void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1;//同样能创建一个对象 d1.Display(); return 0;} 输出： 可以看到使用编译器生成的默认构造函数我们的日期仍然是随机值。 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。 12345678910111213141516171819202122232425262728class Date{public: Date()//无参的默认构造函数 { } Date(int year = 2001, int month = 7, int day = 28)//全缺省的默认构造函数 { _year = year; _month = month; _day = day; } void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1;//这里无法编译通过，因为调用不明确。 d1.Display(); return 0;} 一般我们使用全缺省的构造函数，既可以不传参用缺省值去初始化对象，也可以显式地去调用并用实参初始化对象。 编译器生成的默认构造函数欸好像这货没什么用啊，我刚刚使用这个自动生成的，我的对象的初值还是随机值啊，看起来就像这构造函数什么事都没有做。 其实C++把类型分成内置类型(基本类型)和自定义类型。 内置类型就是语法已经定义好的类型：如int/char…，自定义类型就是我们使用class/struct/union自己定义的类型，看看下面的程序，就会发现编译器生成默认的构造函数会对自定类型成员_t调用的它的默认构造函数。 不过这涉及到我们还没学过的知识——初始化列表，后面会讲。 12345678910111213141516171819202122232425262728293031323334353637class Time{public: Time(int hour = 0, int minute = 0, int second = 0) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; _hour = hour; _minute = minute; _second = second; }private: int _hour; int _minute; int _second;};class Date{public: //使用编译器默认的构造函数 void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: //内置类型 int _year; int _month; int _day; //自定义类型 Time _t;};int main(){ Date d1; d1.Display(); return 0;} 输出： Time(int hour = 0,int minute = 0,int second = 0) -858993460–858993460–858993460 事实上编译器生成的默认构造函数并不是什么都没有做，而是只处理了成员变量中的自定义类型，而没有去初始化内置类型，调用自定义类型成员的构造函数就是在初始化列表做的，下面会详细讲。 成员变量的命名风格看看下面这种成员命名方式有什么缺陷？ 123456789101112131415class Time{public: Time(int hour = 0, int minute = 0, int second = 0) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; hour = hour; minute = minute; second = second; }private: int hour; int minute; int second;}; 简直太难看了，hour = hour这是什么操作？？？到底哪个hour是成员变量，让人去猜吗，代码实在丑陋，因此我们在对成员变量命名时，为了初始化对象不会因为发生命名冲突，又能一眼看出来哪个形参是对应初始化哪个成员变量的，我们通常在对类的成员变量命名方式统一成成员变量名前加上下划线_。 123456789101112131415class Time{public: Time(int hour = 0, int minute = 0, int second = 0) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; _hour = hour; _minute = minute; _second = second; }private: int _hour; int _minute; int _second;}; 当然不止是这样，适合自己的才是最好的，不过一般都是采用加一个前缀或者加上一个后缀的方式来命名成员变量。 这里很容易弄混两个概念，在此强调一下： 默认构造函数是不需要参数的构造函数，有以下三种： 编译器生成的； 显式定义的无参的构造函数； 显式定义的全缺省的构造函数; 默认成员函数是我们如果不写，编译器会自动生成的函数； 构造函数的初始化列表前面说了，在实例化一个类的对象时会自动去调用类的构造函数进行对象的初始化操作，那在C++中一个自定义类型的过程可分为两个过程： 为对象分配内存； 对成员变量赋值； 函数体内赋值； 那我们想想如果成员变量是具有常属性的，那么是不是2过程就无法生效了？那么对于那些具有常性的变量我们以前是怎么定义的呢？初始化操作可以完成这个问题。 初始化是什么？变量在定义的同时为它设定一个初值，例如：引用必须初始化 int&amp; a = 10；，这就是一个典型的初始化操作，而我们要谈的初始化列表也是相似的，那么这种初始化操作有什么与众不同的呢？ 答案是：对于那些一旦有初值就不能再被赋值的变量，初始化列表的作用就体现出来了，例如被const修饰的变量，或者是引用，这些都是具有常属性的，因此就需要在它们创建的过程中就给它们一个初值，保证其可以被正常初始化。 1234567891011121314151617class S{public: S(int i = 0, int j = 0) { _i = i; _j = j; }private: const int _i;//const修饰i具有常属性 int _j;};int main(){ S s; return 0;} 报错： “S::_i”: 必须初始化常量限定类型的对象 error C2166: 左值指定 const 对象 即在编译器看来，这个对象包括对象中的成员变量在进入构造函数的函数体后，就都已经初始化完成了，因此const修饰的变量i就无法再被赋值了。 既然初始化列表是在创建变量阶段对变量进行的初始化，因此就可以使用初始化列表处理给那些无法修改的变量。 初始化列表格式如下： 12345678910111213141516class S{public: S(int i = 0, int j = 0) :_i(i), _j(j) {}private: const int _i; int _j;};int main(){ S s; return 0;} 程序正常运行 同时呢，建议能使用初始化列表就使用，尽量不在构造函数的函数体中为成员变量再赋值，养成好的习惯。 下面分析编译器生成的默认构造函数到底做了什么事情 123456789101112131415161718192021222324252627282930313233343536373839404142class Time{public: Time(int hour = 0, int minute = 0, int second = 0) :_hour(hour), _minute(minute), _second(second) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; } void DisPlay() { cout &lt;&lt; _hour &lt;&lt; &quot;-&quot; &lt;&lt; _minute &lt;&lt; &quot;-&quot; &lt;&lt; _second &lt;&lt; endl; }private: int _hour; int _minute; int _second; };class Date{public: void Display() { cout &lt;&lt; &quot;Date:&quot;; cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; cout &lt;&lt; &quot;Time:&quot;; _t.DisPlay(); }private: int _year; int _month; int _day; Time _t;};int main(){ Date d1; d1.Display(); return 0;} 输出： 可以看到，Date类中的内置类型都未被初始化，而对于自定义类型是去调用了其默认构造函数并且初始化成功了的。 这里要记住一定是调用的自定义成员的默认构造函数，因为编译器生成的Date的默认构造函数调用Time的构造时默认是不传参的，毕竟它也不知道传什么嘛。 如果我们把Time构造函数的缺省值去掉，那么Time就没有默认构造函数，那么创建Date对象时就无法调用Time的默认构造函数，就出错了。 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142class Time{public: Time(int hour, int minute, int second) :_hour(hour), _minute(minute), _second(second) { cout &lt;&lt; &quot;Time(int hour = 1, int minute = 1, int second = 1)&quot; &lt;&lt; endl; } void DisPlay() { cout &lt;&lt; _hour &lt;&lt; &quot;-&quot; &lt;&lt; _minute &lt;&lt; &quot;-&quot; &lt;&lt; _second &lt;&lt; endl; }private: int _hour; int _minute; int _second; };class Date{public: void Display() { cout &lt;&lt; &quot;Date:&quot;; cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; cout &lt;&lt; &quot;Time:&quot;; _t.DisPlay(); }private: int _year; int _month; int _day; Time _t;};int main(){ Date d1; d1.Display(); return 0;} 报错： message : “Date::Date(void)”: 由于 数据成员“Date::_t”不具备相应的 默认构造函数 那我们现在已经知道了编译器生成的默认构造函数它能做什么了，接下来我们显式地去定义一个构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Time{public: Time(int hour = 0, int minute = 0, int second = 0) :_hour(hour), _minute(minute), _second(second) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; } void DisPlay() { cout &lt;&lt; _hour &lt;&lt; &quot;-&quot; &lt;&lt; _minute &lt;&lt; &quot;-&quot; &lt;&lt; _second &lt;&lt; endl; }private: int _hour; int _minute; int _second; };class Date{public: Date() : _year(),//调用了int的默认构造函数，并且会给初始化为0 _month(), _day(), _t()//调用了Time的默认构造函数，这里不写也会自动调用 { cout &lt;&lt; &quot;Date()&quot; &lt;&lt; endl; } void Display() { cout &lt;&lt; &quot;Date:&quot;; cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; cout &lt;&lt; &quot;Time:&quot;; _t.DisPlay(); }private: int _year; int _month; int _day; Time _t;};int main(){ Date d1; d1.Display(); return 0;} 我们为Date定义一个无参的默认构造函数，在初始化列表我不止处理了内置类型还处理了自定义类型。 在C++中支持这样一种定义变量的方法： 123int a;//a是随机值int b(1);int();//创建匿名变量，调用默认构造 这和自定义类型的定义是一样的格式，这是为了让内置类型也能按照自定义类型的方式去定义和初始化，看起来是去调用了int的构造函数。 这样，我们在初始化列表中调用了初始化了内置类型和自定义类型，Date的内置类型也都被初始化为0了，这也印证了编译器生成的默认构造函数并没有去调用int的默认构造，而只调用了自定义类型的默认构造。 注意：就算我们显式的定义了构造函数，如果在初始化列表中不显式的调用Time的构造函数，那么编译器也会默认去调用它的默认构造（创建自定义类型成员变量时就一定会调用），而我们一旦显式的去调用了，那么走我们的调用。 C++中有这样一个特性，编译器能帮你做的，就算你不做它会自动帮你完成，而你一旦做了他就会按照你的方式去完成。 具体什么意思呢？看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Time{public: Time(int hour = 0, int minute = 0, int second = 0) :_hour(hour), _minute(minute), _second(second) { cout &lt;&lt; &quot;Time(int hour = 0, int minute = 0, int second = 0)&quot; &lt;&lt; endl; } void DisPlay() { cout &lt;&lt; _hour &lt;&lt; &quot;-&quot; &lt;&lt; _minute &lt;&lt; &quot;-&quot; &lt;&lt; _second &lt;&lt; endl; }private: int _hour; int _minute; int _second; };class Date{public: Date() : _t()//这里即使不写，编译器会自动去调 { cout &lt;&lt; &quot;Date()&quot; &lt;&lt; endl; } void Display() { cout &lt;&lt; &quot;Date:&quot;; cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; cout &lt;&lt; &quot;Time:&quot;; _t.DisPlay(); }private: int _year; int _month; int _day; Time _t;};int main(){ Date d1; d1.Display(); cout &lt;&lt; int() &lt;&lt; endl; return 0;} 其实这个Date类的构造函数的初始化过程可以说就是编译器默认生成的构造相同了。 总之就是编译器生成的默认构造函数会在初始化列表中调用成员中自定义类型的默认构造，而不会处理内置类型，不论是我们显式定义的还是编译器生成的，编译器都会去调用自定义类的默认构造函数，除非我们在初始化列表中显式的去调用了成员的构造函数。 再言简意骇，就是无论什么构造函数（自动生成，显式定义）编译器都会在初始化列表调用自定义类型成员的构造函数，而如果我们自己显式调用了成员的构造，就执行我们所写的。 可以不显式定义构造函数的情况 如果成员变量都是自定义类型并且都不需要显式调用构造函数，那么编译器生成的默认构造函数就足以处理这种情况 ​ 其他情况都需要我们自己去定义构造函数。 单参数的隐式类型转换123456789101112131415161718192021222324252627282930313233343536class Widget{public: Widget(int n = 0) : _n(n) { cout &lt;&lt; &quot;Widget()&quot; &lt;&lt; endl; } Widget(const Widget&amp; d) : _n(d._n) { cout &lt;&lt; &quot;Widget(Widget&amp; d)&quot; &lt;&lt; endl; } void print() { cout &lt;&lt; &quot;_n = &quot; &lt;&lt; _n &lt;&lt; endl; }private: int _n;};Widget f(Widget u){ Widget v(u); Widget w = v; return w;}int main(){ Widget x = 1;//1会作为构造函数的第一个参数去构造x x.print(); return 0;} 输出： Widget() _n = 1 C++支持第33行这样的写法，实际上这里会发生使用1去构造一个Widget的一个临时对象，再使用这个临时对象去拷贝构造x，不过这里涉及到连续构造编译器的优化，这里可以直接视作使用1作为实参去构造对象x，这里的1会抢占第一个形参。 多参的隐式类型转换12345678910111213141516171819202122232425262728293031323334class Widget{public: Widget(int n , int m = 0)//半缺省 : _n(n), _m(m) { cout &lt;&lt; &quot;Widget()&quot; &lt;&lt; endl; } Widget(const Widget&amp; d) : _n(d._n), _m(d._m) { cout &lt;&lt; &quot;Widget(Widget&amp; d)&quot; &lt;&lt; endl; } void print() { cout &lt;&lt; &quot;_n=&quot; &lt;&lt; _n &lt;&lt; &quot;_m=&quot; &lt;&lt; _m &lt;&lt; endl; }private: int _n; int _m;};int main() { Widget x = {4,3};//与Widget(4,3);效果相同 Widget y = 9;//与Widget(9);效果相同 x.print(); y.print(); return 0;} 输出： Widget()Widget()_n=4_m=3_n=9_m=0 类的构造函数有多个参数时，可以使用类似于初始化数组的方式构造对象，会依照{}中的顺序依次占用构造函数的形参并传值。","link":"/2023/01/12/C++/6.C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"C++拷贝构造函数","text":"拷贝构造函数我们经常会用一个变量去初始化一个同类型的变量，那么对于自定义的类型也应该有类似的操作，那么创建对象时如何使用一个已经存在的对象去创建另一个与之相同的对象呢？ 构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用 拷贝构造函数是构造函数的一个重载，因此显式的定义了拷贝构造，那么编译器也不再默认生成构造函数。 特征拷贝构造也是一个特殊的成员函数。 特征如下： 拷贝构造是构造函数的一个重载； 拷贝构造的参数只有一个并且类型必须是该类的引用，而不是使用传值调用，否则会无限递归； 若没有显式定义拷贝构造函数，编译器会自己生成一个默认拷贝构造，默认的拷贝构造函数对象按内存存储和字节序完成拷贝，也叫浅拷贝； 1234567891011121314151617181920212223242526class Date{public: Date(int year, int month, int day) : _year(year), _month(month), _day(day) {} void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1(2001, 7, 28); Date d2(d1); d1.Display(); d2.Display(); return 0;} 输出： 2001-7-28 2001-7-28 那么对于那些直接管理着内存资源的类（含有指针变量），那么简单的值拷贝还顶得住吗？显然顶不住啊。 通过图示说明： 两个string类的对象指向了同一块空间，这不就乱套了吗，如果其中一个对象通过指针改变了指向内存的数据，那么另一个对象也会受到影响，这是我们不愿发生的，我们希望每个对象都能独立运作。 下面这个程序会崩溃。 123456789101112131415161718192021222324class String{public: String(const char* str = &quot;songxin&quot;) { cout &lt;&lt; &quot;String(const char* str = \\&quot;songxin\\&quot;)&quot; &lt;&lt; endl; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); } ~String() { cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl; free(_str); _str = nullptr; }private: char* _str;};int main(){ String s1; String s2(s1); return 0;} 原因是两个string类的成员指针都指向一块内存，而它们又分别调用了一次析构函数，相当于对同一块内存空间释放了两次，程序崩溃。 因此对于这种情况的对象，我们就不能再使用编译器生成的默认拷贝构造了，而只能自己去显式的定义拷贝构造并且要实现深拷贝。 编译器生成的拷贝构造编译器默认生成的拷贝构造会做些什么呢？ 对于内置类型成员 ​ 完成值拷贝； 对于自定义类型成员 调用成员的拷贝构造； 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Time{public: Time(int hour = 0, int minute = 0, int second = 0) : _hour(hour), _minute(minute), _second(second) {} Time(Time&amp; t) { _hour = t._hour; _minute = t._minute; _second = t._second; }private: int _hour; int _minute; int _second;};Time top(0, 1, 1);class Date{public: Date(int year = 1900, int month = 1, int day = 1, Time&amp; t = top) : _year(year), _month(month), _day(day), _t(t) {}private: int _year; int _month; int _day; Time _t;};int main(){ Time t(1, 1, 1); Date d1(2001, 7, 28,t); Date d2(d1); return 0;} 如果默认生成的拷贝构造没有调用Time类成员的拷贝构造，那么d2的_t的值应该是(_hour = 0, _minute = 0, _second = 0)，而这里最终的结果是d2中的_t和d2中的_t值相同。 这里Date类中自动生成的拷贝构造函数的内置类型会进行字节序拷贝，而对于自定义类型_t调用了Time的拷贝构造函数。 拷贝构造的初始化列表拷贝构造是构造函数的一个重载，因此拷贝构造函数也是有初始化列表的，所以也建议在初始化列表阶段完成对对象的初始化，养成良好习惯。 可以不显式定义拷贝构造函数的情况 成员变量没有指针； 成员有指针，但并没有管理内存资源； 显式定义拷贝构造的误区之前一直存在这个误区： 我们都知道，编译器生成的构造函数在初始化列表会调用成员的构造函数，而我们显式去定义构造函数时，即使我们不写也会在初始化列表去调用自定义类型成员的构造函数。 通过类比，我就犯了一个低级错误： 就是既然编译器生成的拷贝构造可以在初始化列表自动调用自定义成员的拷贝构造，那么我们显式定义的拷贝构造即使不写，也会在初始化列表自动去调用自定义成员的拷贝构造。 于是我写出了如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Time{public: Time(int hour = 0, int minute = 0, int second = 0) : _hour(hour), _minute(minute), _second(second) {} Time(Time&amp; t) { _hour = t._hour; _minute = t._minute; _second = t._second; }private: int _hour; int _minute; int _second;};Time top(2, 2, 2);class Date{public: Date(int year = 1900, int month = 1, int day = 1, Time&amp; t = top) : _year(year), _month(month), _day(day), _t(t) {} Date(Date&amp; d)//显式定义了拷贝构造 { }private: int _year; int _month; int _day; Time _t;};int main(){ Time t(1, 1, 1); Date d1(2001, 7, 28,t); Date d2(d1); return 0;} 通过监视窗口查看d2调用拷贝构造后的值： 并没有拷贝成功。 我只顾着类比它们的功能，可我恰恰忽略了拷贝构造也是一种构造函数啊，那么自然初始化列表也是和普通构造一样，会去调用自定义类的构造函数，不处理内置类型。只不过编译器生成的是经过处理的构造函数达到了拷贝的效果。（太傻逼了这错误） 结论： 拷贝构造函数是构造函数的一种，它也有初始化列表，如果是编译器生成的拷贝构造，它会对内置类型做字节序拷贝，对自定义类型成员会调用自定义成员的拷贝构造。 可如果是我们显式定义出的拷贝构造，它也是有初始化列表的，但是它的初始化列表可不会去调用成员的拷贝构造奥，而是和普通构造函数一样，对于内置类型成员不去初始化值，对于自定义类型成员调用自定义成员的构造函数而不是拷贝构造函数。 编译器关于拷贝构造的优化下面这段代码共调用了多少次拷贝构造？ 12345678910111213141516171819202122232425262728293031class Widget{public: Widget() : _n() { cout &lt;&lt; &quot;Widget()&quot; &lt;&lt; endl; } Widget(const Widget&amp; d) : _n(d._n) { cout &lt;&lt; &quot;Widget(Widget&amp; d)&quot; &lt;&lt; endl; }private: int _n;};Widget f(Widget u){ Widget v(u); Widget w = v; return w;}int main() { Widget x; Widget y = f(f(x));} 我们一个一个数。 首先执行f(x)，那么会传参拷贝（第一次） 函数体Widget v(u);（第二次） Widget w = v;（第三次） return w;用w拷贝构造一个的临时对象tmp（第四次），临时对象tmp作为实参传值拷贝给形参u（第五次） 函数体Widget v(u);（第六次） Widget w = v;（第七次） return w;用w拷贝构造一个的临时对象tmp（第八次），使用临时对象tmp拷贝构造y（第九次） 以上是我们的分析结果，但事实如此吗？ 输出结果： Widget()Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d) 这里调用了七次拷贝构造，和我们分析出的不太一样。 我们知道不同编译器是有差异的，它们和C++标准是有一些出入的，在一些比较新的编译器通常会做下列优化，让我们的程序更快更节约资源。 在一个表达式中，连续构造会被优化： 构造+拷贝构造 12345678910111213141516171819202122class Widget{public: Widget(int n = 0) : _n(n) { cout &lt;&lt; &quot;Widget()&quot; &lt;&lt; endl; } Widget(const Widget&amp; d) : _n(d._n) { cout &lt;&lt; &quot;Widget(Widget&amp; d)&quot; &lt;&lt; endl; }private: int _n;};int main() { Widget x = 1;} 输出： Widget() 按照以前所讲的，第29行这里会发生隐式类型转换，即会用1去调用Widget的构造函数，并且1会作为构造函数的第一个形参，构造出一个Widget临时对象再使用这个临时对象去调用x的拷贝构造，简言之就是先构造再拷贝构造。 但是这里通过输出我们知道Widget x = 1;只调用了一次构造函数，也就是说这种先构造再拷贝构造会被**编译器优化为直接使用1去构造x**，而不是用1构造一个临时对象，再使用临时对象去拷贝构造x。 拷贝构造+拷贝构造 1234567891011121314151617181920212223242526272829303132class Widget{public: Widget(int n = 0) : _n(n) { cout &lt;&lt; &quot;Widget()&quot; &lt;&lt; endl; } Widget(const Widget&amp; d) : _n(d._n) { cout &lt;&lt; &quot;Widget(Widget&amp; d)&quot; &lt;&lt; endl; }private: int _n;};Widget f(Widget u){ Widget v(u); Widget w = v; return w;}int main(){ Widget x; Widget y = f(x); return 0;} 输出： Widget()Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d) 调用了四次拷贝构造。 倘若我们将30行改为f(x);，再来看看输出结果： Widget()Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d)Widget(Widget&amp; d) 这两次居然是一样的，可明明Widget y = f(x);应该比f(x);要多一次拷贝构造啊？？？毕竟多了一步y的拷贝构造。 说明其中有两次拷贝构造被合并为一次拷贝构造了，传参过程和函数体内中是一定不会存在拷贝构造的优化的，只有return w;，会先使用w拷贝构造一个临时对象，再用临时对象去拷贝构造y这段过程会被优化，这两次拷贝构造被优化为直接使用w去拷贝构造y，因此这两段代码调用拷贝构造的次数是相同的。 结论： 构造 + 拷贝构造会被编译器优化为一次构造； 连续的拷贝构造会被编译器优化为一次拷贝构造； 因此为何第一段代码我们也就理解了，第四次和第五次会合并为一次，第八次和第九次会合并为一次，总共调用了七次拷贝构造。 关于这里的优化不是C++标准所规定的，了解即可。","link":"/2023/01/12/C++/7.C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"C++运算符重载","text":"运算符重载本文包括了对C++类的6个默认成员函数中的赋值运算符重载和取地址和const对象取地址操作符的重载。 运算符是程序中最最常见的操作，例如对于内置类型的赋值我们直接使用=赋值即可，因为这些编译器已经帮我们做好了，但是对象的赋值呢？能直接赋值吗？ 概念 C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。 函数名字为：关键字operator后面接需要重载的运算符符号。 函数原型：返回值类型 operator操作符(参数列表) 需要注意的几点： 不能通过连接其他符号来创建新的操作符：比如operator@，必须是已有的操作符； 重载操作符必须有一个类类型或者枚举类型的操作数； 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义； 作为类成员的重载函数时，其形参看起来比操作数数目少1，成员函数的操作符有一个默认的形参this，限定为第一个形参； 参数个数与重载的运算符有关； .* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载； 运算符重载作用于左操作数，会把左操作数当做第一个参数； 既然是对自定义类型对象之间的操作符的重载，那么它的参数一定有此类型的对象，并且需要对对象的成员进行操作，这就需要打破封装的限制，那么这个函数应该设置为全局的还是类的成员呢？ 有以下几种思路： 函数设为公有，成员变量设为公有（不好）； 函数设为公有另外写一个成员函数区获取成员变量的值（不好）； 将函数设为类的友元函数（可以）； 放入类中，作为成员函数（推荐）； 1234567891011121314151617181920212223242526272829// 全局的operator==class Date{public: Date(int year = 1900, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } int _year; int _month; int _day;};// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。bool operator==(const Date&amp; d1, const Date&amp; d2){ return d1._year == d2._year &amp;&amp; d1._month == d2._month &amp;&amp; d1._day == d2._day;}int main(){ Date d1(2018, 9, 26); Date d2(2018, 9, 29); cout &lt;&lt; (d1 == d2) &lt;&lt; endl; return 0;} 这样的写法就打破了封装，让类的成员都暴露了出来，这样的损失不太值得。 赋值运算符重载赋值操作运算符重载特征如下： 参数类型相同； 返回值； 检测是否给自己赋值； 返回*this； 一个类如果没有显式的定义赋值操作符重载，编译器会自动生成一个，完成对象字节序的拷贝（浅拷贝）； 赋值运算符在类中不显式实现时，编译器会生成一份默认的，此时用户在类外再将赋值运算符重载为全局的，就和编译器生成的默认赋值运算符冲突了，故赋值运算符只能重载成成员函数。 12345678910111213141516171819202122232425262728class Date{public: Date(int year = 1900, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } void Display() { cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl; }private: int _year; int _month; int _day;};int main(){ Date d1; Date d2(2018, 10, 1); // 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。 d1 = d2; d1.Display(); d2.Display(); return 0;} 是不是很像自动生成的拷贝构造？那么它也存在一定的问题，对于日期类的对象他能很好的完成赋值操作，可对于指针类型呢？ 下面的程序会崩溃 12345678910111213141516171819202122232425class String{public: String(const char* str = &quot;songxin&quot;) { cout &lt;&lt; &quot;String(const char* str = \\&quot;songxin\\&quot;)&quot; &lt;&lt; endl; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); } ~String() { cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl; free(_str); _str = nullptr; }private: char* _str;};int main(){ String s1(&quot;tanmei&quot;); String s2; s2 = s1; return 0;} 原因也是因为浅拷贝的关系，导致同一块内存被释放了两次，程序崩溃。 可以不显式定义赋值操作符重载函数的情况 成员变量没有指针； 成员变量有指针，但是指针没有管理内存资源； 注意：赋值操作符重载与拷贝构造不同的地方就是拷贝构造是在对象定义时，而赋值操作符重载是作用于已经存在的对象。 const成员const修饰类的成员函数，有点奇怪，const怎么能修饰函数呢？ 将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针指向的对象，表明在该成员函数中不能对指针指向对象的任何成员进行修改。 123456789101112131415161718192021222324252627282930313233343536class Date{public: Date()//构造函数不写的话创建const的对象会报错。 : _year(1900), _month(1), _day(1) {} void Display() { cout &lt;&lt; &quot;Display ()&quot; &lt;&lt; endl; cout &lt;&lt; &quot;year:&quot; &lt;&lt; _year &lt;&lt; endl; cout &lt;&lt; &quot;month:&quot; &lt;&lt; _month &lt;&lt; endl; cout &lt;&lt; &quot;day:&quot; &lt;&lt; _day &lt;&lt; endl &lt;&lt; endl; } void Display() const { cout &lt;&lt; &quot;Display () const&quot; &lt;&lt; endl; cout &lt;&lt; &quot;year:&quot; &lt;&lt; _year &lt;&lt; endl; cout &lt;&lt; &quot;month:&quot; &lt;&lt; _month &lt;&lt; endl; cout &lt;&lt; &quot;day:&quot; &lt;&lt; _day &lt;&lt; endl &lt;&lt; endl; }private: int _year; // 年 int _month; // 月 int _day; // 日};int main(){ Date d1; d1.Display(); const Date d2; d2.Display(); return 0;} const的对象就会调用Display函数会调用哪一个呢？注意到上面代码的第18行的函数被const修饰，那么这个const有什么作用？ 实际上这个const修饰的是*this，表明 *this不可被修改，那么const的对象就会调用被const修饰的函数，否则可能会出现下面的问题。 const对象可以调用非const成员函数吗？ ​ 不可以，权限放大。 非const对象可以调用const成员函数吗？ ​ 可以，权限缩小。 const成员函数内可以调用其它的非const成员函数吗？ ​ 不可以，权限放大。 非const成员函数内可以调用其它的const成员函数吗？ ​ 可以，权限缩小。 还有一个值得注意的地方，上面的代码如果我们不显式定义构造函数的话，实例化const的对象时会报错： “d2”: 必须初始化 const 对象 也就是说编译器认为const对象（包括成员）无法被赋值，应该有初始化操作，而默认生成的构造是没有对int有初始化操作的，因此报错； 取地址及const取地址操作符重载取地址操作符也要重载吗？只有很少的情况会用到，通常直接使用编译器默认生成的就可以。 12345678910111213141516class Date{public: Date* operator&amp;() { return this; } const Date* operator&amp;()const { return this; }private: int _year; // 年 int _month; // 月 int _day; // 日}; 那么什么时候我们会重载呢？ 想让别人获取指定的内容的地址； 隐藏对象真实的地址； 123456789101112131415161718192021222324class Date{public: Date* operator&amp;()//隐藏对象真实地址 { return nullptr; } const int* operator&amp;()const//让用户指定获取成员变量_day的地址 { return &amp;(_day); }private: int _year; // 年 int _month; // 月 int _day; // 日};int main(){ const Date d1; Date d2; cout &lt;&lt; &amp;d1 &lt;&lt; endl;// cout &lt;&lt; &amp;d2 &lt;&lt; endl;// return 0;} 输出： 0000005597AFF7700000000000000000 不过这样的情况确实很少，也没有什么意义。","link":"/2023/01/12/C++/9.C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"C++析构函数","text":"析构函数既然在创建对象时有构造函数（给成员初始化），那么在销毁对象时应该还有一个清除成员变量数据的操作咯。 概念 析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。 特性析构函数是特殊的成员函数 特征如下： 析构函数名是~类名； 无参数无返回值； 一个类有且只有一个析构函数； 对象声明周期结束，编译器自动调用析构函数； 12345678910111213141516171819202122232425262728293031class Stack{public: Stack(int capacity = 4) : _size(0), _capacity(capacity), _p(new int[_capacity]) { cout &lt;&lt; &quot;Stack(int capacity = 4)&quot; &lt;&lt; endl; } ~Stack() { cout &lt;&lt; &quot;~Stack()&quot; &lt;&lt; endl; if (_p) { delete[](_p); _p = nullptr; } _size = _capacity = 0; }private: int _capacity; int _size; int* _p;};int main(){ Stack s; return 0;//程序结束，调用s的析构函数} 输出： 析构函数处理自定义类型1234567891011121314151617181920212223242526272829303132333435363738394041class String{public: String(const char* str = &quot;songxin&quot;) { cout &lt;&lt; &quot;String(const char* str = \\&quot;songxin\\&quot;)&quot; &lt;&lt; endl; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); } ~String() { cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl; free(_str); _str = nullptr; }private: char* _str;};class Person{public: Person() : _age(20), _name() { cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl; } ~Person() { cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl; }private: String _name; int _age;};int main(){ Person p; return 0;} 输出： 析构函数在程序即将结束时，调用了Person的析构函数，在Person类的析构函数即将结束接着调用String类的析构函数。 归纳一下： 析构函数是与构造函数执行相反的操作的，构造函数负责给对象成员变量初始化并加载资源，而析构函数则是给对象的成员变量清理资源，而不是清理对象本身。 编译器生成的默认析构函数编译器默认生成的析构函数能做些什么工作呢？我们前面已经介绍了编译器生成的构造函数会去只会处理自定义类型的成员变量，那么析构既然和构造相对应，析构也应该是只去处理自定义类型的成员变量吧，确实如此，析构函数不会对内置类型有任何处理，只会在调用自身的析构后再去调用自定义类型成员的析构。 关于编译器自动生成的析构函数，下面的程序我们会看到，编译器生成的析构函数，会对自定类型成员调用它的析构函数。 1234567891011121314151617181920212223242526272829303132333435363738class String{public: String(const char* str = &quot;songxin&quot;) { cout &lt;&lt; &quot;String(const char* str = \\&quot;songxin\\&quot;)&quot; &lt;&lt; endl; _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); } ~String() { cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl; free(_str); _str = nullptr; }private: char* _str;};class Person{public: Person() : _age(20), _name() { cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl; } private: String _name; int _age;};int main(){ Person p; return 0;} 输出： 默认生成的析构函数对成员变量的处理 内置类型不处理； 自定义类型成员调用相应的析构函数； 那成员变量中的内置类型处不处理其实都无所谓嘛，反正都要归还给操作系统，但是有例外： 如果成员变量含有指针，并且指针指向一块我们正使用的空间，指针也是内置类型，那如果不释放指针指向的那块空间就会造成内存泄漏，而编译器生成的析构函数是不会处理此情况的，因为需要我们在析构函数中主动释放内存，也就是说需要我们显式的去定义析构函数。 12345678910111213141516171819202122232425262728293031class Stack{public: Stack(int capacity = 4) : _size(0), _capacity(capacity), _p(new int[_capacity])//使用new去申请内存 { cout &lt;&lt; &quot;Stack(int capacity = 4)&quot; &lt;&lt; endl; } ~Stack() { cout &lt;&lt; &quot;~Stack()&quot; &lt;&lt; endl; if (_p) { delete[](_p);//释放内存 _p = nullptr; } _size = _capacity = 0; }private: int _capacity; int _size; int* _p;};int main(){ Stack s; return 0;//程序结束，调用s的析构函数} 析构函数无论是我们显式定义的还是编译器生成的，都会在对象的声明周期结束时自动调用，并且会调用自定义类型成员变量的析构函数来释放资源，而对内置类型不做处理。 可以不显式定义析构函数的情况 类的成员都是自定义类型的； 类的成员都是非指针的内置类型； 成员有指针，但并没有管理内存资源； 如果类的成员变量有指针类型，并且我们让指针指向了一块动态分配的空间，那么就需要我们自己写析构函数了。 总结：不是类直接管理另一块内存资源的，就不需要写析构函数，编译器自己生成的就能处理。","link":"/2023/01/12/C++/8.C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"title":"计算机眼中的世界","text":"计算机眼中的数字 二进制数的换算 通常再生活中我们所使用的是十进制数，数字都是0~9这十个数字，除开数学领域外，普通人几乎不会涉及到其他进制的应用，正因为十进制在生活中的使用的快捷性和实用性，人类对其的应用非常广泛。 而对于计算机来说，它认识哪些东西呢？ 相信大家都知道，计算机中的一切数据其实都是由1和0组成的，也就是说计算机所认识的数字只有1和0，与我们习惯使用十进制数一样，计算机所使用的数字也与计算机的组成息息相关。电路可以说是计算机最重要的元件，而每一条电路都只有两种状态：开或者关，两种状态恰好与1和0相对应，这也就解释了计算机使用二进制的原因。 二进制数的换算我们如果想将二进制数与十进制数互相转换，那该如何实现呢？ 下面我会用例子给大家说明例：二进制数 ‘1010’ 如果转化为十进制数是多少呢？ 运用类比思想 ，我们可以想：十进制数例如 ‘121’ 个位上1的权重为10的零次方十位上的权重为10的一次方百位上的权重为10的二次方，于是可以表示为1*10^2^+2 *10^1^+1 *10^0^ 运算结果是 121。 所以对于‘1010’最低为为第一位，则第n位的权重位2的n-1次方，于是可表示为1 *2^3^+0 *2^2^+1 *2^1^ +0 *2^0^运算结果是 10。即等于十进制的10.而对于二进制数的各种运算就不做详细阐述了，运用类比的思想，将十进制数的运算方法照搬过来，其实也就是二进制数的运算方式了。 计算机的内存内存的基本单位bit通常我们的电脑有32位计算机和64位计算机，而这里的‘位’到底是什么呢？ 这里所说的位数其实是计算机的地址线根数，而我们知道每根地址线会存在两种状态，即正和负，这些所有的地址线的状态则可以表示为很多个二进制数。在高中数学中我们学习过排列组合，因此不难知道，假如地址线有x根，则这些地址线状态总共就有2的x次方种（每一根有两种，x根的组合）. 这里我们以32位计算机为例子： 00000000000000000000000000000000这里有32个0，代表32根地址线都处于负 我们一直对其进行加1的操作 00000000000000000000000000000000(+1)00000000000000000000000000000010(+1) …………………(+1)11111111111111111111111111111111 最终变成了32个1组成的二进制数那这个数为多少呢？根据排列组合的知识很容易的出其值为2的32次方-1=4294967295. 内存大小的换算仍然以32位计算机为例，可以知道32位计算机可以表示从0到4294967295这么多的数字。 在日常生活中，每户人都有属于自己的街道名称，门牌号等住址信息，这样就方便了我们寻找一个地址。 计算机也是这样，计算机中的数据也会有一个自己的”地盘“，并且拥有明确的编号，像下面这样每一个编号都代表着一块空间，于是内存就被分配了编号和大小。 00000000000000000000000000000000 0 00000000000000000000000000000001 1 00000000000000000000000000000010 2 … – 11111111111111111111111111111110 4294967294 11111111111111111111111111111111 4294967295 – – 而这里的每一个编号所代表的空间的大小就为1个byte（字节） 不同内存大小的换算如下： 1pb=1024tb 1tb=1024gb 1gb=1024mb 1mb=1024kb 1kb=1024byte 1byte=8bit 通过这样的计算方法也可以计算出32位计算机的内存大小约为4GB. C语言是什么一门语言既然是一门语言，那么如同日语、英语一样，是供人们之间交流的。 计算机语言就是人和计算机交流的媒介，它使得我们可以命令计算机处理执行一些我们想让他做的事。 main函数-程序的入口1.main函数一定要有2.main函数在一个程序中有且只有一个框架： 1234int main(){ return 0;} 接下来我们在VS2019环境下证实一下 调试后直接跳到了主函数内部的第一个位置。 据此，我们可以证明main函数的确是程序的入口。 常见数据类型如果我们想表示一个人的年龄，那么可以用一个整数来表示，那如果想表示一本书的价格呢？那是不是就该用一个小数来表示了呢？于是浮点型和整型的数据类型便诞生了。 整型 数据类型 解释 int 整型 char 字符 short 短整型 long 长整型 longlong 超长整型 浮点型 数据类型 解释 float 单精度浮点型 double 双精度浮点型 注意：双精度浮点型精度更高 变量的定义方式 通常定义一个变量的方式为： 数据类型+变量名； 以int为例，我们来定义一个名字为i的变量。 123int i=0;//使用int类型创建了一个变量i，//i向内存申请了一块空间，空间名叫ii=10;//向i空间内放入整型10 于是一个类型为int，名称为i的变量就创建好并被赋值啦。 注意：C语言没有字符串类型 常量和变量常量常量即为不能改变的量 字面常量 常变量 标识符常量 枚举常量 字面常量 字面常量就是直接写出来的数 例如：10，99等这样的数字 常变量 常变量即被const修饰的变量 例如：const int i=9；// i 就不能再被赋予其他值了，我们来尝试一下： 1234567int main(){ //const-常属性 const int i = 9; i = 1; return 0;} 可以看到这里已经报错了 值得一提的是该定义方式下的变量为常变量，之所以叫常变量，是因为虽然不能再被赋值，但是 i 仍为变量，只不过具有了常属性，所以叫常变量。 注意：这里的 i 不能作为定义数组时的数组元素个数[i] 标识符常量 标识符常量是由#define定义的常量 例如：#define MAX 10即定义了MAX为常数 10 ，在程序中遇到MAX后会直接将MAX替换为10 接下来我们来试试： 1234567#include&lt;stdio.h&gt;#define MAX 10int main(){ printf(&quot;%d&quot;, MAX); return 0;} 运行结果如下： 注意：这里的 a 能作为定义数组时的数组元素个数[a] 枚举常量字面意思就可以知道”枚举“就是一一列举，并且由关键字enum修饰。 接下来举一个例子： 1234567891011121314151617#include&lt;stdio.h&gt;enum sex //枚举关键{ MALE, //表示枚举出来的可能值 FEMALE, neutrality};int main(){ enum sex a = MALE; //给相应的变量赋值 enum sex b = FEMALE; enum sex c = neutrality; printf(&quot;a=%d\\n&quot;, a); //依次打印出变量的值 printf(&quot;b=%d\\n&quot;, b); printf(&quot;c=%d\\n&quot;, c); return 0;} 输出为：a=0b=1c=2表明在枚举时系统会按照顺序依次从0开始对枚举出来的MALE/FEMALE/neutrality的赋值 如果我们稍稍改变一下上面的代码，来看看它如何对枚举常量赋值。 1234567891011121314151617#include&lt;stdio.h&gt;enum sex{ MALE, FEMALE=2, neutrality};int main(){ enum sex a = MALE; enum sex b = FEMALE; enum sex c = neutrality; printf(&quot;a=%d\\n&quot;, a); printf(&quot;b=%d\\n&quot;, b); printf(&quot;c=%d\\n&quot;, c); return 0;} 输出依次为：a=0b=2c=3 可以看出其赋值是依次递增1的，如果人为的给其赋值，则下一个仍然是递增一个1 变量 全局变量 局部变量 变量的使用 代码块— { } 全局变量全局变量—定义在块之外的变量 局部变量局部变量—定义在块之内的变量 变量的使用 接下来举一个例子来更好的认识全局变量和局部变量 123456789#include&lt;stdio.h&gt;int a = 0;int b = 0;int main(){ int x = 0; int y = 0; return 0;} a和b是定义在{ }之外的叫做全局变量 x和y是定义在{ }之内的叫做局部变量 C语言规定：定义变量必须在当前代码块的最前面（C99之前） 变量的作用域和生命周期生命周期大家都知道指的是事物的存在时间，人的生命周期是从出生到死亡，而在我们活着的这段时间里我们可以做很多事情，而当我们的生命周期结束——即死亡后，便彻底消失在了这世界上。因此，我们所创建的变量在内存中也有它的生命周期。 在创建一个变量时就会占用一部分内存，这个变量的生命周期开始，而内存时有限的，我们不能只向内存索取，而不给予内存空间反馈，这样最终内存会耗尽。因此，在变量使用结束后我们会销毁这个变量，并将空间还给操作系统，这样，一个变量的生命周期就结束了 作用域 我仍然使用人来作为例子，在人处于生命周期内，也就是活着的时候，我们可以做很多事情，旅游、学习，甚至时改变世界，因此我们活着时，所处的世界就是我们的作用域…… 而当我们的生命结束，便无法对这个世界再产生影响，也就是脱离了我们的作用域了。 局部变量也是这样，变量的作用域就是其所在的块内，在它的块内时，它处于生命周期中，并且可以发挥作用。 因此局部变量的作用域：其所在的块内。 全局变量就如同长生不老的神一般，世界创世之初就存在，只有这个世界消失了，它才会跟着消失。而对于全局变量来说它所处的世界就是一个工程。 因此，全局变量作用域是整个工程。 总结： 1、局部变量的生命周期：进入作用域开始，出作用域结束2、全局变量的作用域：整个工程 字符与字符串 字符 字符串 字符 ==字符==：被‘ ’括起来的一个==字母==、==数字==或者是==符号==。例：‘a’，’c’，‘#’ 这些都是字符 可我们之前说了计算机只认识0和1两个数字，那么字符在计算机中是如何存储的呢？ 我们从计算机的数据的存储方式来说： 数据在计算机上存储的时候，存储的是二进制的数，因此需要存储字符时，实际存储的是某一个数，也就是ASCII码值。 字符串 被” “括起来的==一串字符==。 例如：”hello world！“就是一个字符串。 接下来我将会使用一个代码讲述字符串一个很容易忽视的细节 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o' }; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof(arr1)); return 0;} 运行结果输出为： 6 5 通过上运行结果可看出可以看出，arr和arr1的大小是不同的。 表面上看好像上面两个数组中存放的都是 ‘h’ ’e‘ ’l‘ ’l‘ ’o’ ，但我们通过调试可以看到： arr比arr1这里多了一个’\\0‘（终止字符) 也就是说在字符串“hello”中实际在末尾还有一个’\\0‘作为字符串结束的标志。 那么就能解释在用sizeof对两个数组求大小时出现的大小不同的情况了。 除此以外还有一种情况让我们值得思考： strlen函数是用于求出字符串的长度，并且不包括’\\0‘，知道即可，目前不必深究。 那就是利用strlen函数求出arr和arr1的字符串长度，代码如下： 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o'}; printf(&quot;%d\\n&quot;, strlen(arr)); printf(&quot;%d\\n&quot;, strlen(arr1)); return 0;} 运行结果输出为： 这里又是为什么呢？明明strlen求的是字符串的长度，与’\\0‘无关了，为什么还会得出一个相差如此大的结果呢？ 这就要从strlen的实现来解释了，strlen函数是从字符串的第一个字符开始，每跳过一个一个字符计数器count就会+1，直到遇到字符串结束标志为止。而arr1在内存中的位置是随机的，无法确定arr1后面遇到的第一个’\\0‘在哪里，所以strlen（arr1）是个随机值。 如果将上面的代码改为： 12345678int main(){ char arr[] = &quot;hello&quot;; char arr1[] = { 'h','e','l','l','o','\\0'}; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof(arr1)); return 0;} 输出结果为： 6 6就符合我们的预期了！ 同时上述写法中arr和arr1是完全相同的，并无差异。","link":"/2023/01/12/C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C/"},{"title":"C语言结构体","text":"结构体的声明什么是结构 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 结构体的声明 1234struct tag{ member-list;}variable-list; 结构体的作用 我们想用一个变量描述一个人，那如何实现呢？ C语言提供给我们的基础类型中，都是只能描述某一个方面。 然而人或者其他的复杂对象是多元的，需要很多变量去描述特征，那么结构体就能做到这件事。 例如描述一个学生： 1234567typedef struct Stu{ char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号}Stu； 结构成员的类型 结构成员的类型可以是C语言提供给我们的基础类型，也可以是另一个结构体。 注意：这个结构体不能是结构体本身，否则会形成递归。 结构体变量的定义和初始化 1234567891011121314struct Point p3 = {x, y};struct Stu //类型声明{ char name[15];//名字 int age; //年龄};struct Stu s = {&quot;zhangsan&quot;, 20};//初始化struct Node{ int data; struct Point p; struct Node* next;}n1 = {10, {4,5}, NULL}; //结构体嵌套初始化struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化 初始化方式与数组有些相似，不过数组初始化时括号中元素的类型都是相同的，结构体则不受限制。 各个成员的初始化方式还是与普通类型初始化方式相同，不过是用大括号括在一起（注意顺序要对应）。 结构体成员的访问 结构体变量访问成员结构变量的成员是通过点操作符（.）访问的。点操作符接受两个操作数 例子： 12345struct Stu{ char name[20]; int age;}; 成员有name和age，那么如何访问它们呢？ 使用.操作符 例如： 123struct Stu s;strcpy(s.name, &quot;songxin&quot;);s.age = 20; 直接通过结构体变量名去访问。 结构体的指针可以访问结构体吗？ -&gt;操作符 1234567struct Stu* ps = &amp;s;//方法一：strcpy((*s).name, &quot;songxin&quot;);(*s).age = 20;//方法二：strcpy(s-&gt;name, &quot;songxin&quot;);s-&gt;age = 20; 可以理解为结构体指针指向的那个东西的某个成员ps-&gt;某成员 结构体传参函数传参方式通常有两种： 传值 传地址 结构体也不例外。 12345678910111213141516171819202122struct S{ int data[1000]; int num;};struct S s = {{1,2,3,4}, 1000};//结构体传参void print1(struct S s){ printf(&quot;%d\\n&quot;, s.num);}//结构体地址传参void print2(struct S* ps){ printf(&quot;%d\\n&quot;, ps-&gt;num);}int main(){ print1(s); //传结构体 print2(&amp;s); //传地址 return 0;} 到底哪种好一些呢？ 从两个方面看： 效率 如果将整个结构体的值传过去，如果结构体过于复杂，那么开销过于巨大 传指针，无论结构体有多么复杂，最终传指针只需要四个字节或者八个字节。 需要改变结构体值的函数 传值，那么形参只是一份原变量的拷贝，函数体内改变不会影响实际参数。 上面的 print1 和 print2 函数哪个好些？答案是：首选print2函数。原因： 函数传参的时候，参数是需要压栈的。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降. 结论： 结构体传参的时候，要传结构体的地址。","link":"/2023/01/12/C/10.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/"},{"title":"C语言实现N子棋","text":"C语言实现一个大家小时候都玩过的小游戏的进阶版本，不止是三子棋，可以根据玩家需要设定棋盘大小。的可读性，我将源码分为了三个部分，分别是源文件test.c、game.c、game.h。 test.c部分是游戏进入、开始、结束的骨干代码。 game.c是游戏的具体如何实现的代码。 game.h是所有自定义函数以及库函数的头文件包含、函数声明以及宏定义。 可以根据需要自行设定ROW和COL的值达到改变棋盘大小以及胜利条件。 头文件game.h 123456789101112131415161718192021222324#pragma once#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;#define ROW 3 //棋盘的行数#define COL 3 //棋盘的列数//game函数void game();//打印简易游戏菜单void menu();//初始化棋盘void init_board(char board[ROW][COL], int row, int col);//打印棋盘void print_board(char board[ROW][COL], int row, int col);//电脑下棋void computer_chess(char board[ROW][COL], int row, int col);//玩家下棋void player_playing_chess(char board[ROW][COL], int row, int col);//判断是否有一方获胜char judge_wins(char board[ROW][COL], int row, int col);//判断是否已经平局int is_full(char board[ROW][COL], int row, int col); 主函数test.c 123456789101112131415161718192021222324252627#include&quot;game.h&quot;int main(){ //播种由函数 rand 使用的随机数发生器 srand((unsigned int)time(NULL)); menu(); int input = 0; do { printf(&quot;请输入-&gt;\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) { case 1: game(); break; case 0: printf(&quot;退出游戏\\n&quot;); break; default: printf(&quot;输入错误：\\n&quot;); break; } } while(input); return 0;} 具体实现游戏的函数game.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&quot;game.h&quot;void game(){ char board[ROW][COL] = { 0 }; init_board(board, ROW, COL); print_board(board, ROW, COL); char ret = 0; while (1) { computer_chess(board, ROW, COL); //判断是否结束 ret = judge_wins(board, ROW, COL); print_board(board, ROW, COL); if (ret) break; player_playing_chess(board, ROW, COL); //判断是否结束 ret = judge_wins(board, ROW, COL); print_board(board, ROW, COL); if (ret) break; } //结束后打印棋盘 print_board(board, ROW, COL); //根据返回值ret判断胜利的一方 if (ret == '#') printf(&quot;玩家胜利！\\n&quot;); else if (ret == '*') printf(&quot;电脑胜利！\\n&quot;); else if (ret == 'Y') printf(&quot;平局\\n&quot;);}//菜单void menu(){ printf(&quot;***************************\\n&quot;); printf(&quot;* ****** MENU ******* *\\n&quot;); printf(&quot;* ******1.play******* *\\n&quot;); printf(&quot;* ******0.exit******* *\\n&quot;); printf(&quot;* ******************* *\\n&quot;); printf(&quot;***************************\\n&quot;);}//初始化棋盘void init_board(char board[ROW][COL],int row,int col){ int i = 0; for (i = 0; i &lt; row; ++i) { int j = 0; for (j = 0; j &lt; col; ++j) { board[i][j] = ' '; } }}//打印棋盘void print_board(char board[ROW][COL], int row, int col){ int i = 0; for (i = 0; i &lt; row; i++) { int j = 0; for (j = 0; j &lt; col; j++) { printf(&quot; %c &quot;, board[i][j]); if(j &lt; col - 1) printf(&quot;|&quot;); } printf(&quot;\\n&quot;); if (i &lt; row - 1) { for (j = 0; j &lt; col; j++) { printf(&quot;---&quot;); if (j &lt; col - 1) printf(&quot;|&quot;); } printf(&quot;\\n&quot;); } }}//玩家下棋，玩家下棋记为 #void player_playing_chess(char board[ROW][COL], int row, int col){ int i = 0; int j = 0; printf(&quot;玩家下棋\\n&quot;); printf(&quot;请输入坐标\\n&quot;); while (1) { scanf(&quot;%d %d&quot;, &amp;i, &amp;j); if (i &gt; 0 &amp;&amp; i &lt;= row &amp;&amp; j &gt; 0 &amp;&amp; j &lt;= col &amp;&amp; board[i - 1][j - 1] == ' ') { board[i - 1][j - 1] = '#'; break; } else printf(&quot;坐标非法，请重新输入：\\n&quot;); }}//电脑下棋，记为 *void computer_chess(char board[ROW][COL], int row, int col){ printf(&quot;电脑下棋\\n&quot;); while (1) { int i = rand() % row;//满足棋盘的坐标 int j = rand() % col; if (board[i][j] == ' ') { board[i][j] = '*'; break; } }}//判断是否有一方已经赢下对局char judge_wins(char board[ROW][COL], int row, int col){ int i = 0; int j = 0; char ret = 0; //检查行 for (i = 0; i &lt; row; ++i) { ret = 1; for (j = 0; j &lt; col - 1; ++j) { if (board[i][j] == board[i][j + 1] &amp;&amp; board[i][j] != ' ' ) ; else { ret = 0; break; } } if (ret) return board[i][j]; } //检查列 for (j = 0; j &lt; col; j++) { ret = 1; for (i = 0; i &lt; row - 1; i++) { if (board[i][j] == board[i + 1][j] &amp;&amp; board[i][j] != ' ') ; else { ret = 0; break; } } if (ret) return board[i][j]; } //检查对角线 ret = 1; for (i = 0,j = 0; i &lt; row - 1 &amp;&amp; j &lt; col -1; i++,j++) { if (board[i][i] == board[i + 1][i + 1] &amp;&amp; board[i][i] != ' ') ; else { ret = 0; break; } } if (ret) return board[i][i]; //检查对角线 ret = 1; for (i = 0,j = col - 1; i &lt; row - 1 &amp;&amp; j &gt; 0; i++,j--) { if (board[i][j] == board[i + 1][j - 1] &amp;&amp; board[i][j] != ' ') ; else { ret = 0; break; } } if (ret) return board[i][j]; //检查是否平局 if (is_full(board, row, col)) return 'Y'; //继续 return 0;}//检查是否棋盘是否已满int is_full(char board[ROW][COL], int row, int col){ int i = 0; int j = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { if (board[i][j] == ' ') return 0; } } return 1;}","link":"/2023/01/12/C/11.C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E3%80%90N%E5%AD%90%E6%A3%8B%E3%80%91/"},{"title":"C语言实现扫雷","text":"难点解析探索八区探索排雷位的周围八个区域。 总归情况就分三类，可探索的区域为8个，5个，3个。但这样分类实在麻烦，所以我们可以选择在创建雷盘的时候，将二维数组的维度扩大一些，使其不用考虑多种情况，而只用考虑探索周围八个雷区。 我们可以给外侧再加一层，即给二维数组行列分别加二，并且把外层全部设置为非雷区域，就可以解决这一问题。 递归展开展开周围的非雷区 递归过程：如果（x，y）位置周围八区的雷数为0，则从八个区域展开，展开的位置的 x坐标是从x-1到x+1，而 y 的位置是从y-1到y+1的范围中，因此嵌套两重循环。 进入条件：只有之前没有展开过，且坐标在雷盘内的位置才进入递归。 终止条件：如果探索的周围八个位置有雷，则停止，并让该位置显示雷的数量。 探索八区代码实现： 提醒：’*‘是未排雷的区域，’ ‘是代表已经展开过的区域。 123456789101112131415//计算排查位置处周围雷的个数int calculate(char mine[ROWS][COLS],int x,int y){ //因为雷的位置放的是字符‘1’ // 加起来之后应该分别减去‘0’，才得到雷的个数 return mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] + mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1] - 8 * '0';} 1234567891011121314151617181920212223242526272829//展开周围都没有雷的雷盘（扩展式排雷）void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//扩展函数{ //利用calculate函数判断周围是否有雷 if (calculate(mine, x, y) == 0) {//判断周围雷的个数，若为0，则需要展开 show[x][y] = ' ';//展开的位置都置为空格 int i = 0; int j = 0; //该位置可以拓展才检查周围8个位置是否能拓展 for (i = x - 1; i &lt;= x + 1; i++) { for (j = y - 1; j &lt;= y + 1; j++) { if (show[i][j] == '*' &amp;&amp; i &gt; 0 &amp;&amp; i &lt;= ROW &amp;&amp; j &gt; 0 &amp;&amp; j &lt;= COL) { //如果该位置未被扫过且在棋盘范围内则继续递归调用expand函数 //再依次进入判断周围8个位置是能被展开还是不能 expand(mine, show, i, j); } } } } else { show[x][y] = calculate(mine, x, y)+'0'; //不需要展开则显示附近雷的个数 }} 这两个函数结合起来使用便可以达到扩展展开的效果。 使用效果： 可以看到在选择（5，6）后一片非雷区被展开了，并且边缘部分的雷个数被打印在了相应位置。 由于实在找不到什么好看的符号代替’ ‘，看着可能会有点难受，欢迎评论区给出建议！ 完整源码我将代码分为了test.c、game.h、game.c三个部分。 test.c是游戏实现的主体框架。 game.h是所用到的头文件以及自定义函数声明。 game.c是游戏的具体实现模块。 除了上面的递归有些难度外，其他的都比较易懂，不再单独阐述，下面的源码中我给出了每一步的注释，解释的很清楚，相信各位一边看代码一边想会有更多的收获。 test.c123456789101112131415161718192021222324252627#include&quot;game.h&quot;int main(){ srand((unsigned)time(NULL)); int input = 0; do { menu();//菜单 printf(&quot;请输入-&gt;(1 / 0)\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) { case 1: game();//选择1就进入game break; case 0://选择0就退出 printf(&quot;退出游戏！\\n&quot;); break; default: printf(&quot;输入错误，请重新输入：\\n&quot;); break; } } while (input); return 0;} game.h1234567891011121314151617181920212223242526272829303132#pragma once#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;//时间戳函数头文件#include&lt;time.h&gt;//rand、srand函数头文件#include&lt;stdlib.h&gt;#define ROW 9//雷的区域的行数#define COL 9//雷的区域的列数#define ROWS ROW+2//数组的一维大小#define COLS COL+2//数组的二维大小#define NUM 50//雷的个数//进入游戏void game();//打印菜单void menu();//计时器void set_time();//初始化数组void init_array(char array[ROWS][COLS], int rows, int cols, char symbol);//布置雷void lay_mines(char mine[ROWS][COLS], int row, int col);//打印void show_interface(char show[ROWS][COLS], int row, int col);//排查雷void mine_detection(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);//计算雷的个数int calculate(char mine[ROWS][COLS], int x, int y);//保证第一次安全排雷int one_safe(char mine[ROWS][COLS], int x, int y);//扩展式排雷以及记录周围的雷数量void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y); game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include&quot;game.h&quot;//游戏流程void game(){ system(&quot;cls&quot;);//清屏 //创建两个数组 char mine[ROWS][COLS] = { 0 };//布置雷的数组 char show[ROWS][COLS] = { 0 };//游戏界面的显示雷个数的数组 //初始化两个数组 init_array(mine, ROWS, COLS, '0');//初始化为‘0’ init_array(show, ROWS, COLS, '*');//初始化为‘*’ //布置雷 lay_mines(mine, ROW, COL); //打印出show数组 show_interface(show, ROW, COL); //排查雷 mine_detection(mine, show, ROW, COL); set_time();}//菜单函数void menu(){ printf(&quot;***************************\\n&quot;); printf(&quot;* ****** MENU ******* *\\n&quot;); printf(&quot;* ******1.play******* *\\n&quot;); printf(&quot;* ******0.exit******* *\\n&quot;); printf(&quot;* ******************* *\\n&quot;); printf(&quot;***************************\\n&quot;);}//计时函数，void set_time(){ //打印出从程序运行到目前所用的时间 printf(&quot;本次用时：%u s\\n&quot;, clock() / CLOCKS_PER_SEC);}//初始化数组void init_array(char array[ROWS][COLS], int rows, int cols, char symbol){ int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) { for (j = 0; j &lt; cols; j++) { array[i][j] = symbol; } }}//布置地雷void lay_mines(char mine[ROWS][COLS],int row,int col){ int count = NUM;//NUM为雷的个数 while (count)//循环条件，每次count-1 { int x = rand() % row + 1; int y = rand() % col + 1; if (mine[x][y] == '0') { mine[x][y] = '1'; count--; } }}//展示游戏界面void show_interface(char show[ROWS][COLS], int row, int col){ int i = 0; int j = 0; for (i = 0; i &lt;= col; i++)//打印出列号 { printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); for (i = 0; i &lt;= col; i++) { printf(&quot;—&quot;); } printf(&quot;\\n&quot;); for (i = 1; i &lt;= row; i++) { printf(&quot;%d|&quot;, i);//打印出行号 for (j = 1; j &lt;= col; j++) { printf(&quot;%c &quot;, show[i][j]); } printf(&quot;\\n&quot;); } for (i = 0; i &lt;= col; i++) { printf(&quot;—&quot;); } printf(&quot;\\n&quot;);}//排查雷void mine_detection(char mine[ROWS][COLS],char show[ROWS][COLS], int row, int col){ int cnt = 0;//cnt为已排查出的雷的个数 int x = 0; int y = 0; while (cnt &lt; ROW * COL - NUM)//循环条件是还有雷没有排查 { int ret = 0; //输入要排查雷的坐标 printf(&quot;请输入要排查的坐标：(X,Y)\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (cnt == 0)//第一次排雷 { if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col) { //首次输入的坐标如果是雷，则将雷移动到另一个位置 one_safe(mine, x, y);//保证第一次总不是雷 //因为无论如何都不是雷，直接跳转到记录雷和扩展的函数expand goto next; } else { printf(&quot;坐标非法，请重新输入：\\n&quot;); continue; } } //确保坐标在设定的范围中 if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col) { if (mine[x][y] == '0') { next://goto跳转到这里 expand(mine, show, x, y); //打印出排查过一次后的界面 show_interface(show, ROW, COL); cnt++;//排雷成功次数加一 } else { //如果排查的位置放的是‘1’则表示该位置为炸弹 printf(&quot;很遗憾，您被炸死了!\\n&quot;); //游戏结束，打印出所有雷的位置 show_interface(mine, ROW, COL); break; } } else { printf(&quot;坐标非法，请重新输入：\\n&quot;); } } if (cnt == ROW * COL - NUM)//可排雷个数为0时 { printf(&quot;恭喜您，排雷成功！\\n&quot;); //游戏结束 show_interface(mine, ROW, COL); }}//计算排查位置处周围雷的个数int calculate(char mine[ROWS][COLS],int x,int y){ //因为雷的位置放的是字符‘1’ // 加起来之后应该分别减去‘0’，才得到雷的个数 return mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] + mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1] - 8 * '0';}//保证第一次不会踩到雷int one_safe(char mine[ROWS][COLS], int x, int y){ int count = 1; //判断第一次是否是雷 if (mine[x][y] == '1') { mine[x][y] = '0'; //将雷随机放入另一个没有雷的位置 while (count) { x = rand() % ROW + 1; y = rand() % COL + 1; if (mine[x][y] == '0') { mine[x][y] = '1'; count--; } } return 1;//是雷则返回1 } else return 0;//不是雷则返回0 //其实这里可以返回值也可以不返回，因为在我最开始写代码时，最开始的思路是： //非雷 是雷这两种情况分别进入不同的分支，不过后来又换了一种思路}//展开周围都没有雷的雷盘（扩展式排雷）void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//扩展函数，判断是否需要递归式展开。{ //利用calculate函数判断周围是否有雷 if (calculate(mine, x, y) == 0) {//判断周围雷的个数，若为0，则需要展开 show[x][y] = ' ';//展开的位置都置为空格 int i = 0; int j = 0; //该位置可以拓展才检查周围8个位置是否能拓展 for (i = x - 1; i &lt;= x + 1; i++) { for (j = y - 1; j &lt;= y + 1; j++) { if (show[i][j] == '*' &amp;&amp; i &gt; 0 &amp;&amp; i &lt;= ROW &amp;&amp; j &gt; 0 &amp;&amp; j &lt;= COL) { //如果该位置未被扫过且在棋盘范围内则继续递归调用expand函数 //再依次进入判断周围8个位置是能被展开还是不能 expand(mine, show, i, j); } } } } else { show[x][y] = calculate(mine, x, y)+'0'; //不需要展开则显示附近雷的个数 }} 一点拓展计时运用clock函数,该函数需要的头文件为 “time.h”函数原型：clock_t clock(void);功能：程序从启动到函数调用占用CPU的时间这个函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，在MSDN中称之为挂钟时间；若挂钟时间不可取，则返回-1。其中clock_t是用来保存时间的数据类型。 1234void set_time()//计时{ printf(&quot;用时:%u 秒\\n&quot;, clock() / CLOCKS_PER_SEC);} 如果觉得游戏太简单，可以通过改变ROW（行数）和COL（列数）的大小改变雷盘大小，增大NUM（雷的个数）增加游戏难度。","link":"/2023/01/12/C/12.C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E3%80%90%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E3%80%91%E6%8B%93%E5%B1%95%E7%89%88/"},{"title":"C语言数据的存储","text":"数据基本类型为什么会有不同的类型，这些类型有内存大小上的差异，那么他们还有什么差异呢？ 在内存中开辟空间的大小 读取内存空间方式的差异 1234567char //字符类型 short //短整型 int //整型 long //长整型 long long //更长整型 float // 单精度浮点型 double // 双精度浮点型 除此以外，在整型中同一种类型的数据还分为有符号和无符号型. 整型中: 12345678910111213char signed char unsigned charshort signed short unsigned shortint signed int unsigned intlong signed long unsigned long 浮点数类型： 12floatdouble 当然，还有指针类型，大致相同不再赘述。 整型在内存中的存储既然不同类型在内存中需要不同的空间，那么它们如何在内存存储的呢？ 1234567int main(){ int a = 10; int b = 5; printf(&quot;%d %d&quot;, a, b); return 0;} 0x010FFC88是a在内存中的地址，在这里我们可以看到: 0a 00 00 00 分别是四个字节，而0a就是我们找到的那一个地址，即我们通常所说的a的首地址。 在32位机器上int整型的大小为32个bit，即四个字节，这里是使用的16进制数字来表示的，每四个二进制位可以转换为一个十六进制位（每四个二进制位的权重与一个十六进制位的权重相同，所以这里可以使用8个十六进制数字来表示a的值。 首先我们先要知道： 二进制在计算机中都是以补码的形式存储的。 为什么会存在补码？ 首先，如果单纯的使用原码进行计算，由于符号位的存在，那么必定时会存在很多问题，那有没有一种二进制序列，可以不考虑符号位的存在直接进行运算的呢？ 此外，原码和补码的相互转化，都是取反加一并不需要额外的计算机硬件电路。 正数的原码和补码相同。 负数的补码和原码有着取反加一的关系。 比如 -1 原码：10000000000000000000000000000001 反码：11111111111111111111111111111110 补码：11111111111111111111111111111111 既然32bit是四个字节，而计算机中基本的内存单位也是一个字节，那么超过一个字节的数据在内存中是按何种顺序存储的呢？ 首先我们要知道有高位和低位的区别，权重高的位称为高位，反之低位。 接下来我们就可以继续了。 大端存储： 存放低位的字节在高地址处，高位的字节在低地址处。 小端存储： 存放低位的字节在低地址处，高位的字节在高地址处。 注意：大小端仅针对C语言中的内置数据类型，以宏观的角度看整个结构体，是不存在所谓的高位和低位的也就不存在字节序的问题了，成员的存储遵循大小端存储模式。 也从另一个角度说明了对结构体的访问是不存在宏观对于整个结构的单独访问，而是对它的成员的访问和读取。 再来看这张图： a == 10 十六进制：0000000a 可我们却看到好像数据在内存中不是这样存放的，可以看到0a也就是数据的低位字节是在低地址处的，它的高位字节是在内存中的高地址处的。 为什么会存在大小端存储 这是因为我们在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节是8bit。 另外，对于位数大于8位的处理器，例如16位或者32位处理器，由于寄存器的宽度大于一个字节，也就意味着在处理数据时如何安排多个字节的问题。 想测测自己目前所使用机器时如何存储数据的吗？ 从二者的差异入手，对于1 补码：00000000000000000000000000000001 如果数大端存储： 那么在内存中应该是 00 00 00 01 而如果是小端存储应该是 01 00 00 00 那么我们就从此入手，看看在其首地址处的那个字节里保存的是什么，就可以解决相应问题。 123456789101112#include&lt;string.h&gt;int main(){ int a = 1; char* p = (char*)&amp;a; if (*p == 1) printf(&quot;小端字节序\\n&quot;); else printf(&quot;大端字节序\\n&quot;); printf(&quot;%d &quot;, *p); return 0;} 浮点型存储规则12345678int main(){ int n = 9; float* pa = (float*)&amp;n; printf(&quot;%d\\n&quot;, n); printf(&quot;%f\\n&quot;, *pa); return 0;} 同样的数据同样的字节数，为什么打印出来却不同呢？ 其实，这是浮点数和整型在内存中的存储方式的差异导致的。 根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式： (-1)^S * M * 2^E (-1)^S表示符号位，当S = 0时表示正数，当S= 1S时表示负数。 M表示有效数字 大于等于1小于2 2^E表示指数位。 例如：十进制的5.0，写成二进制是101.0，类比十进制的科学计数法我们还可以写成1.01*2^2^. 按照上面规定的格式我们就可以得到： S = 0，M = 1.01，E= 2。 同上： 十进制的 -5.0，写成二进制为 -1.01 * 2^2^ ,那么只有正负号改变了，仅仅将上面的S改为1，其他的不变就可以了。 既然在表示一个浮点数需要在内存中存储这三个数据，那么这究竟在内存中是如何存放的呢？ ​ IEEE 754规定： 对于32位的浮点数，最高位的是符号位S，紧接着的8个位是指数E，剩下的23位存放的是数字的有效位。 而对于64位的浮点数，最高位仍然是符号位，不过指数位和有效数字位都所有增加，分别是11位和52位。 IEEE 754还对M和E有一些特殊规定： 前面说过，类比十进制的科学计数法，而我们都知道科学计数法的有效数字范围为[ 1，10），同样这里的有效数字M也必须满足 1 &lt;= M &lt;2,也就是说无论是什么样的数字，最终都可以写成1.xxxxxxxxx * 2 ^n^这样的形式，因此为了提高我们的精度，在内存中，我们仅仅存放有效数字中小数点后面数字，在我们需要读取时，再将其加上去，这样就为可以存储的有效位数就由23位变为了24位。 例如：1.01 * 2 ^2^. 我们在存储有效数字M的时候仅仅将 1.01 中的 01 存放，将1舍去。 64位浮点数同理。 至于指数E，情况稍微复杂 首先，E是一个无符号正数（unsigned int） 对于32 位浮点数来说，E有8位，也就意味着它的取值范围是0~255. 但是我们知道，这里的E是可以存放负数的，因此IEEE754规定，我们在内存中存入E时，必须将真实值加上一个中间数，对于8位的E，这个中间数是127，而对于64位的E这个中间值是1023. 也可以直接这样理解： 在32位浮点数中，指数的范围是 （0-127，255-127）。 例如 1.01 * 2^10^的E是10，但我们想存到内存中时，必须先加上中间数127，也就是137，然后再将137的二进制序列存入到内存中。 E的存放还可以分为三种： E为不全为1或不全为0 这时是最一般的情况，我们先通过E在内存中的计算值减去127得到指数的真实值，然后再将有效数字M加上第一位的1。 例如： 浮点数 5.0 -&gt;二进制可以表示为 1.01 * 10^2^ 指数部分先加上 中间数127 ，得到 129. 129 的二进制为 10000001. 有效数字为1.01，去掉正数部分为 01，补齐01到23位 01000000000000000000000 则其二进制序列可表示为： 0 10000001 01000000000000000000000 E为全0 这是浮点数的指数的真实值就为 1-127或者1 - 1023. 而有效数字就不再加上首位的1，这样就可以表示无限接近于 0。 E全为 1 这时，如果有效数字M全为0，则表示无穷大。 1234567int main(){ int n = 9; float* pa = (float*)&amp;n; printf(&quot;%f&quot;, *pa); return 0;} 那么我们来解决这个问题。 先来看 整型 9 的二进制序列： 00000000000000000000000000001001 我们取出它的地址后，以浮点数的存储方式去看待它，那么可以看成 0 00000000 0000000000000000001001 ​ 可以看到这里和我们的的第三种情况 E全为0相同，浮点数可以写成： V=(-1)^0 × 0.00000000000000000001001×2^(-126)=1.001×2^(-146) 很显然这是一个无限接近于0的数字，所以用十进制数字表示就是0.000000. 问题解决了~","link":"/2023/01/12/C/13.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"},{"title":"C语言指针进阶","text":"简介指针的概念 指针是个变量，用来存储地址。 指针的大小只与是64位平台还是32位平台有关，与指针类型无关。 指针类型决定了指针的解引用权限和读取方式。 指针+-正数与指针所指向类型数据的长度有关。 字符指针在指针的类型中我们知道有一种指针类型为字符指针 char* ;一般使用: 1234567int main(){ char ch = 'w'; char *pc = &amp;ch; *pc = 'w'; return 0;} 还有一种使用方式如下： 123456int main(){ const char* pstr = &quot;hello sx.&quot;;//这里是把一个字符串放到pstr指针变量里了吗？ printf(&quot;%s\\n&quot;, pstr); return 0;} const char* pstr = &quot;hello sx.&quot;;这段代码的意思实际是将”hello sx”的首地址赋值给pstr.，这样pstr就拥有了访问这个字符串的能力。但很多人会陷入一个误区：认为”hello sx”字符串被整个放到了pstr中。 像这样” “中放入字符直接写出来的字符串的我们叫做常量字符串，它存储在静态存储区，字符串的内容不能更改，并且只有在整个程序结束后，常量字符串所使用的内存空间才会被系统回收。 所以使用直接收常量字符串的指针时，通常使用const修饰。 实际pstr与常量字符串的关系： 看一道例题： 123456789101112131415161718#include &lt;stdio.h&gt;int main(){ char str1[] = &quot;hello bit.&quot;; char str2[] = &quot;hello bit.&quot;; const char *str3 = &quot;hello bit.&quot;; const char *str4 = &quot;hello bit.&quot;; if(str1 ==str2) printf(&quot;str1 and str2 are same\\n&quot;); else printf(&quot;str1 and str2 are not same\\n&quot;); if(str3 ==str4) printf(&quot;str3 and str4 are same\\n&quot;); else printf(&quot;str3 and str4 are not same\\n&quot;); return 0;} 你可能感到奇怪，字符串明明时相同的，怎么str3、str4就不同了？ 实际上： 12char arr[] = &quot;hello sx&quot;;//先创建一块空间，然后将字符串依次放入数组中。 这里str3和str4指向的是一个同一个常量字符串。C/C++会把常量字符串存储到单独的一个内存区域，当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。所以str1和str2不同，str3和str4不同。 注意：同一个程序中出现的相同常量字符串都是同一个，类似与python将常量字符串存储在内存池中。 指针数组指针数组即元素类型为指针的数组。 我们可以使用指针数组模拟一个二维数组。 12345int arr1[3] = {1,2,3};int arr2[3] = {2,3,4};int arr3[3] = {3,4,5};int* arr[3] = {arr1, arr2, arr3};如果想访问arr[i]中的第下标为j的元素，可以使用 *(*(arr + i) + j). 同样可以使用数组下标的方式 arr[i] [j]; 但这只是模拟二维数组，并不是真正的二维数组。 二维数组的空间是连续的，可是在这里一定是连续的吗？ 二维数组的每一行的大小是相同的，这里一定相同吗？ 答案是否定的，这里的arr1 、 arr2 、 arr3的地址空间是随机的，长度也并没有固定。 数组指针数组指针：意为数组的指针。 那么当然这是一个指针，它是指向数组的。 内置类型的指针： 例如 int* p, double* p,来剖析它的结构。 p被 * 修饰代表p是指针，那么指向什么类型？==》int。 下面代码哪个是数组指针？ 123int *p1[10];int (*p2)[10];//p1, p2分别是什么？ 先来看看最普通的类型。 12345int arr1[10];//arr1与[10]先结合，代表arr1是个数组，那么剩下的就是数组元素的类型。int *arr;//arr与*结合，代表arr是个指针，那么剩下的就是指针指向的类型。 p1先与[10]结合，表示p是个数组。 将p1[10]去掉剩下的就是数组的元素类型。 显然，p1这是一个指针数组，数组的每个元素是指向int的指针。 p2先与*结合，代表p2是个指针。 再与[10]结合，代表指向的是十个元素的数组，那么剩下的就是数组的元素类型了。 p2是一个指针，指向有十个元素，每个元素是int的数组。 123int (*p)[10];//解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针，指向一个数组，叫数组指针。//这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。 对数组名取地址1int arr[10]; arr和&amp;arr有什么区别呢？ arr是数组名，首元素地址。 那&amp;arr是个什么呢？ 看代码： 1234567int main(){ int arr[10] = {0}; printf(&quot;%p\\n&quot;, arr); printf(&quot;%p\\n&quot;, &amp;arr); return 0;} 两者的值是一样的，难道就一样吗？ 继续看： 123456789int main(){ int arr[10] = { 0 }; printf(&quot;arr = %p\\n&quot;, arr); printf(&quot;&amp;arr= %p\\n&quot;, &amp;arr); printf(&quot;arr+1 = %p\\n&quot;, arr+1); printf(&quot;&amp;arr+1= %p\\n&quot;, &amp;arr+1); return 0;} 都执行 + 1操作后就不同了，那么说明它们指向的类型长度是有差异的。 可以看到 &amp;arr 和 &amp;arr + 1 相差了40个字节，是arr这个数组的长度。 说明&amp;arr 指向的应该是一整个数组，因此一次跳过一个数组的长度，那么也就合理了。 数组指针的使用那数组指针是怎么使用的呢？ 既然数组指针指向的是数组，那数组指针中存放的应该是数组的地址。 上代码： 1234567#include &lt;stdio.h&gt;int main(){ int arr[10] = {1,2,3,4,5,6,7,8,9,0}; int (*p)[10] = &amp;arr;//把数组arr的地址赋值给数组指针变量p return 0;} 这样的用法多少显得我们有点不太聪明的样子，这根本无法体现数组指针的价值。 如下使用可以完美契合二维数组： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;void print_arr1(int arr[3][5], int row, int col){ int i = 0; for (i = 0; i &lt; row; i++) { int j = 0; for (j = 0; j &lt; col; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); }}void print_arr2(int(*arr)[5], int row, int col){ int i = 0; for (i = 0; i &lt; row; i++) { for (j = 0; j &lt; col; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); }}int main(){ int arr[3][5] = { 1,2,3,4,5,6,7,8,9,10 }; print_arr1(arr, 3, 5); //数组名arr，表示首元素的地址 //但是二维数组的首元素是二维数组的第一行 //所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址 //可以数组指针来接收 print_arr2(arr, 3, 5); return 0;} 二维数组的数组名是首元素的地址，而二维数组的每一个元素实际上是一个数组，那么首数组的地址就是一个数组指针，可以在二维数组传参时使用。 那么(arr + i)就代表第i + 1行的地址，解引用后就是 第 i + 1行的数组名，然后就可以通过对一维数组的访问去访问元素了。自然就可以用 arr[i] [j]的方式去访问元素。 12345int arr[5];//元素类型为5个int的数组int *parr1[10];//指针数组，10个元素，每个元素都是指向int的指针。int (*parr2)[10];//数组指针，指向元素个数5，每个元素为int的数组。int (*parr3[10])[5];////数组指针数组，有十个元素，每个元素都是一个数组指针，指向元素个数为5的整形数组。 总结:一维数组的数组名既可以代表整个数组，也可以是首元素地址，通常是后者，只有在取地址和使用sizeof操作符时数组名代表整个数组。 数组参数、指针参数一维数组传参123456789101112131415161718#include &lt;stdio.h&gt;void test(int arr[])//arr是一维数组的数组名，使用数组名接收，可以{}void test(int arr[10])//标明元素个数和不标名效果是一样的{}void test(int *arr)//可以指针接收首元素地址{}void test2(int *arr[20])//arr2是首元素地址，每个元素为一个一级指针，那么arr就是二级指针，可以{}void test2(int **arr)//与上一个相同{}int main(){ int arr[10] = {0}; int *arr2[20] = {0}; test(arr); test2(arr2);} 二维数组传参来看看这样传参是否可以？ 1234567891011121314151617181920212223void test(int arr[3][5])//使用二维数组接收二维数组，可以{}void test(int arr[][]) //不可以，没有指定列数，无法确定一行多少元素，就无法对指针进 //行运算一次跳过多少字节{}void test(int arr[][5])//可以，可以不指定行数，一定要指定列数{}//总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。//这样才方便运算。void test(int *arr)//不行，类型不匹配，二维数组名是数组指针，这里是一级指针{}void test(int* arr[5])//不行，类型不匹配{}void test(int (*arr)[5])//可以，二维数组数组名传参实际是一个数组指针{}void test(int **arr)//不行，类型不匹配，这是二级指针，无法接收数组指针{}int main(){ int arr[3][5] = {0}; test(arr);} 总结：只能省略行，不能省略列，数组在作为参数传参时实际上为指针，若没有传列数给形参，就不知道数组指针可以时指向多大的数组（一行几个元素），就无法对其进行加减操作从而访问元素。 一级指针传参123456789101112131415161718#include &lt;stdio.h&gt;void print(int* p, int sz){ int i = 0; for (i = 0; i &lt; sz; i++) { printf(&quot;%d\\n&quot;, *(p + i)); }}int main(){ int arr[10] = { 1,2,3,4,5,6,7,8,9 }; int* p = arr; int sz = sizeof(arr) / sizeof(arr[0]); //一级指针p，传给函数 print(p, sz); return 0;} 函数形参为一级指针我们可以传入哪些参数呢？ 数组名 一级指针 字符串 比如： 123456void test1(int *p){}//test1函数能接收什么参数？void test2(char* p){}//test2函数能接收什么参数？ test1可以接收 int类型的数组， int* 的指针。 test2可以接收常量字符串， 字符数组的数组名，char*的指针 二级指针传参1234567891011121314#include &lt;stdio.h&gt;void test(int** ptr){ printf(&quot;num = %d\\n&quot;, **ptr);}int main(){ int n = 10; int* p = &amp;n; int** pp = &amp;p; test(pp); test(&amp;p); return 0;} 来想象二级指针可以接收哪些类型的参数呢？ 1234567891011121314void test(char** p){}int main(){ char c = 'b'; char* pc = &amp;c; char** ppc = &amp;pc; char* arr[10]; test(&amp;pc);//这是指向char的指针 test(ppc);//可以 test(arr);//可以，arr为首元素地址，首元素为char*类型，那么它的类型就是char** return 0;} 补充： 指针数组的元素是指针，是地址，将不同的指针变量放在相邻的一块地址空间中，数组名的类型是二级指针。 12int a = 0;int** ppa = &amp;(&amp;a); 这样写对吗？ &amp;a有地址吗？ 很显然没有。 一级指针 123int* p;//整形指针char* pc;//字符指针void* pv;//空类型的指针 可以对一维数组进行传参。 二级指针 12char** p;int** p; 可以对存放一级指针的数组传参。 数组指针 1int(*p)[3]; 可以对二维数组进行传参。 指针数组 1int* p[10]; 将指向int的指针，拷贝其值放到一些相邻的地址空间存储，可以对这些新元素进行访问，达到和原指针相同的效果。 函数指针首先看一段代码： 1234567891011#include &lt;stdio.h&gt;void test(){ printf(&quot;hehe\\n&quot;);}int main(){ printf(&quot;%p\\n&quot;, test); printf(&quot;%p\\n&quot;, &amp;test); return 0;} 输出的是两个地址，这两个地址是 test 函数的地址。 既然&amp;test和test是相同的，那就可以使用test的地址去直接调用函数，当然也可以介意用，不过有些脱裤子放屁，多此一举了。 12345int (*pf)(int, int) = test;//三种调用方式pf(x,y);(*pf)(x,y);test(x,y); 那我们的函数的地址要想保存起来，怎么保存？ 下面我们看代码： 1234567void test(){ printf(&quot;hehe\\n&quot;);}//下面pfun1和pfun2哪个有能力存放test函数的地址？void (*pfun1)();void* pfun2(); 分析分析： 首先一定是指针才能存储地址，那么就一定是pfun1咯。 pfun1先和* 结合，表明它是指针，接着与()结合，表明指向的是函数，那么剩下的就是返回类型了为void。 那么pfun2是个什么呢？ pfun2先与()结合，表明它是函数，剩下的就是返回类型void*。 阅读两段有趣的代码 在定义一个变量时，例如： 12int p;去掉变量名就是其类型intint (*p)[3];去掉变量名就是其类型int(*)[3] 1234//代码1(*(void (*)())0)();//代码2void (*signal(int , void(*)(int)))(int); 代码1： 我们从0 和 *入手，搞清楚括号的位置。 可以看到void (*)()是一个函数指针类型，括号括起来实际是对0的强制类型转换，强制转换为一个函数地址，然后再解引用拿到函数，通过函数调用操作符()去调用。 void (*p)() 函数指针类型 (void (*)())0 将强制类型转换为该函数类型的地址，会将0地址那块区域当作一个存储函数的地方 解引用得到函数名 ()调用 代码2： 从标识符入手 signal和()结合，说明其为函数名 函数的参数类型分别为int, void(*)(int) 剩下的 void (*)(int)是返回类型，也是一个函数指针。 代码2的简化： 12typedef void(*pfun_t)(int);pfun_t signal(int, pfun_t); 总结：像这样的复杂类型通常从标识符入手，没有标识符就从*，[],操作符入手，逐层分析。 函数指针数组很明显函数指针数组是一个数组，它的元素类型都是函数的指针。 那要把函数的地址存到一个数组中，那这个数组就叫函数指针数组，那函数指针的数组如何定义呢？ 找个喜欢的标识符 例如 pfarr 是个数组必然先与[]结合，pfarr[] 数组元素类型是函数指针，任意写出来一个函数指针类型int (*p)() 将p替换为pfarr[],int (*pfarr[])() 结束。 函数指针数组的用途：转移表 例子：（计算器） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;int add(int a, int b){ return a + b;}int sub(int a, int b){ return a - b;}int mul(int a, int b){ return a * b;}int div(int a, int b){ return a / b;}int main(){ int x, y; int input = 1; int ret = 0; do { printf(&quot;*************************\\n&quot;); printf(&quot; 1:add 2:sub \\n&quot;); printf(&quot; 3:mul 4:div \\n&quot;); printf(&quot;*************************\\n&quot;); printf(&quot;请选择：&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) { case 1: printf(&quot;输入操作数：&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = add(x, y); printf(&quot;ret = %d\\n&quot;, ret); break; case 2: printf(&quot;输入操作数：&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = sub(x, y); printf(&quot;ret = %d\\n&quot;, ret); break; case 3: printf(&quot;输入操作数：&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = mul(x, y); printf(&quot;ret = %d\\n&quot;, ret); break; case 4: printf(&quot;输入操作数：&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = div(x, y); printf(&quot;ret = %d\\n&quot;, ret); break; case 0: printf(&quot;退出程序\\n&quot;); breark; default: printf(&quot;选择错误\\n&quot;); break; } } while (input); return 0;} 使用函数指针数组的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;int add(int a, int b){ return a + b;}int sub(int a, int b){ return a - b;}int mul(int a, int b){ return a * b;}int div(int a, int b){ return a / b;}int main(){ int x, y; int input = 1; int ret = 0; int(*p[5])(int x, int y) = { 0, add, sub, mul, div }; //转移表 while (input) { printf(&quot;*************************\\n&quot;); printf(&quot; 1:add 2:sub \\n&quot;); printf(&quot; 3:mul 4:div \\n&quot;); printf(&quot;*************************\\n&quot;); printf(&quot;请选择：&quot;); scanf(&quot;%d&quot;, &amp;input); if ((input &lt;= 4 &amp;&amp; input &gt;= 1)) { printf(&quot;输入操作数：&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = (*p[input])(x, y); } else printf(&quot;输入有误\\n&quot;); printf(&quot;ret = %d\\n&quot;, ret); } return 0;} 函数的使用变的简单实用了许多。 转移表作用： 将多个函数地址存放到一个数组中，让这些函数地址存放在一个相邻的地址空间，这样在调用函数时，就可以通过访问数组元素，达到调用函数的效果。 类型书写方式： 对于某一个类型，我们在定义该类型的变量时如何写？那么定义存放该类型的数组也是相似的。 例： 123int (*p)[3];那么创建一个该元素类型的数组直接在p后面加上[n]int(*p[n])[3]; 就定义完成了。 指向函数指针数组的指针指向函数指针数组的指针是一个指针 指针指向一个数组 ，数组的元素都是函数指针 ; 如何定义？ 12345678910111213141516#include &lt;stdio.h&gt;void test(const char* str){ printf(&quot;%s\\n&quot;, str);}int main(){ //函数指针pfun void (*pfun)(const char*) = test; //函数指针的数组pfunArr void (*pfunArr[5])(const char* str); pfunArr[0] = test; //指向函数指针数组pfunArr的指针ppfunArr void (*(*ppfunArr)[5])(const char*) = &amp;pfunArr; return 0;} 回调函数 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。 回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 作用： 12345678910111213141516171819#include &lt;stdio.h&gt;//qosrt函数的使用者得实现一个比较函数int int_cmp(const void* p1, const void* p2){ return (*(int*)p1 - *(int*)p2);}int main(){ int arr[] = { 1, 3, 5, 7, 9, 2, 4, 6, 8, 0 }; int i = 0; qsort(arr, sizeof(arr) / sizeof(arr[0]), sizeof(int), int_cmp); for (i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;); return 0;} 使用回调函数，模拟实现qsort（采用冒泡的方式）。 注意：这里第一次使用 void* 的指针，讲解 void* 的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int int_cmp(const void* p1, const void* p2){ return (*(int*)p1 - *(int*)p2);}void _swap(void* p1, void* p2, int size){ int i = 0; for (i = 0; i &lt; size; i++) { char tmp = *((char*)p1 + i); *((char*)p1 + i) = *((char*)p2 + i); *((char*)p2 + i) = tmp; }}void bubble(void* base, int count, int size, int(*cmp)(void*, void*)){ int i = 0; int j = 0; for (i = 0; i &lt; count - 1; i++) { for (j = 0; j &lt; count - i - 1; j++) { if (cmp((char*)base + j * size, (char*)base + (j + 1) * size) &gt; 0) { _swap((char*)base + j * size, (char*)base + (j + 1) * size, size); } } }}int main(){ int arr[] = { 1, 3, 5, 7, 9, 2, 4, 6, 8, 0 }; //char *arr[] = {&quot;aaaa&quot;,&quot;dddd&quot;,&quot;cccc&quot;,&quot;bbbb&quot;}; int i = 0; bubble(arr, sizeof(arr) / sizeof(arr[0]), sizeof(int), int_cmp); for (i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n&quot;); return 0;} 回调函数： 将一个函数的指针作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数，就是回调函数。 通常来说，一个函数只能完成一件事情，而利用函数回调，在不同情况下，对函数传入不同的其他函数的指针，则可以再一个函数内实现调用多个函数，完成多种功能，且如果这个函数只有一个函数指针，调用一次只实现某一特定函数功能。 函数名和函数地址作为实参传入另一个函数的话，只能用函数指针接收。 注意：传过去的函数必须与接受的函数指针所指向的类型相同（返回类型，参数类型和个数）。 void * 类型无法解引用操作。 指针技巧方法： 在书写任何一种类型的变量都是有技巧的。 书写函数返回类型，数组元素类型，指针指向类型。 先创建一个该类型的变量。 按照下列方式替代变量名 返回类型 ——用函数名(参数) 替代 数组元素类型 ——用数组名[]替代 指针指向类型——用(*p)替代 总结：定义标识符p类型 p先与[]结合，说明其为数组，剩下的就是元素类型 p先与* 结合，说明其为指针，剩下的就是指向类型。 p先与*结合再与[]结合，说明其为指针，指向数组，剩下的就是数组元素类型 写一个数组时，先写出数组格式arr[] ， 然后确定元素类型，创建一个该类型的变量，将变量名改为arr[] 写一个指针时，先写出(*p), 如果指向数组，则(*p)[]， 然后确定数组类型，创建一个该类型变量，将变量名改为 ( *p)[]。 如果指向非数组，则确定其指向类型，创建一个该类型变量，将变量名改为(*p)。","link":"/2023/01/12/C/14.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E6%8C%87%E9%92%88/"},{"title":"C语言自定义类型","text":"结构体的声明常规的结构的声明太过简单常见，不再过多阐述。 特殊声明在声明结构体的时候可以不完全的声明 1234567891011121314struct{ int i; double d; char c;}x;struct{ int i; double d; char c;}arr[10], * px, x1; 注意到上面两个结构体的声明并没有标签 也就是说我们只能在声明结构体的时候创建变量，一旦声明结束，就再也找不到这个结构体的标签，自然无法使用它创建变量。 那么还要一个问题： 上面的 x1和x一样吗？ 或者说下面这个代码非法吗？ 1px = &amp;x; 警告：编译器会把上面的两个声明当成完全不同的两个类型。所以是非法的。 结构的自引用在结构体中包含一个类型为该结构本身的成员可行吗？ 12345678//代码1struct Node{ int data; struct Node next;};//可行否？如果可以，那sizeof(struct Node)是多少？ 显然这是不行的，它会无休止的递归下去，非法。 正确打开方式： 123456//代码2struct Node{ int data; struct Node* next;}; 而结构体中包含一个自身结构体的指针就不存在这个问题了，结构体的大小是确定的，并且可以在结构体中访问和自身类型一样的结构体。 每次定义变量都要加个struct实在麻烦，我们使用typedef将代码简化一下，下面对吗？ 1234567891011121314//代码3typedef struct{ int data; Node* next;}Node;//这样写代码，可行否？//答案是不行的，在结构体内typedef还没有将这个类型重新定义一个名字，自然无法使用这个新类型。//解决方案：typedef struct Node{ int data; struct Node* next;}Node; 结构体变量的定义和初始化有结构体的声明，那么定义一个结构体再简单不过了，就和定义普通变量一样就好。 12345678910111213141516171819202122232425struct Point{ int x; int y;}p1; //声明类型的同时定义变量p1,p1是全局的struct Point p2; //定义结构体变量p2，全局的//初始化：定义变量的同时赋初值。struct Point p3 = { x ,y };//类似数组初始化struct Stu //类型声明{ char name[15];//名字 int age; //年龄};struct Stu s = { &quot;zhangsan&quot;, 20 };//初始化struct Node{ int data; struct Point p; struct Node* next;}n1 = { 10, {4,5}, NULL }; //结构体嵌套初始化struct Node n2 = { 20, {5, 6}, NULL };//结构体嵌套初始化 结构体内存对齐我们已经掌握了结构体的基本使用了。 现在我们深入讨论一个问题：计算结构体的大小。这也是一个特别热门的考点： 结构体内存对齐 试试计算下面结构体的大小 1234567891011121314151617181920212223242526272829303132//练习1struct S1{ char c1; int i; char c2;};printf(&quot;%d\\n&quot;, sizeof(struct S1));//练习2struct S2{ char c1; char c2; int i;};printf(&quot;%d\\n&quot;, sizeof(struct S2));//练习3struct S3{ double d; char c; int i;};printf(&quot;%d\\n&quot;, sizeof(struct S3));//练习4-结构体嵌套问题struct S4{ char c1; struct S3 s3; double d;};printf(&quot;%d\\n&quot;, sizeof(struct S4)); 难道对齐数只是成员变量大小的简单相加吗？ 显然不是，要考虑一些其他问题设计结构体。 考点 如何计算？ 首先得掌握结构体的对齐规则： 第一个成员在与结构体变量偏移量为0的地址处。 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 ​ 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 ​ VS中默认的值为8 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 为什么会存在内存对齐 参考 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 简单说： 结构体的内存对齐是拿空间来换取时间的做法。 那我们如何设计一个个结构体，既满足我们的使用又可以更节省空间 让小的成员尽量集中在一起 12345678910111213//例如：struct S1{ char c1; int i; char c2;};struct S2{ char c1; char c2; int i;}; 来计算一下它们的大小。 S1 = 4 + 4 + 4 = 12 S2 = 1 + 1 + 2 + 4 = 8 虽然成员一模一样但因为位置不同，大小也不同。 修改默认对齐数之前我们见过了 #pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。 通常是#pragma once，用来防止头文件的重复包含。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#pragma pack(8)//设置默认对齐数为8struct S1{ char c1; int i; char c2;};#pragma pack()//取消设置的默认对齐数，还原为默认#pragma pack(1)//设置默认对齐数为1struct S2{ char c1; int i; char c2;};#pragma pack()//取消设置的默认对齐数，还原为默认int main(){ //输出的结果是什么？ printf(&quot;%d\\n&quot;, sizeof(struct S1)); printf(&quot;%d\\n&quot;, sizeof(struct S2)); return 0;} 在对齐方式不太合理时，我们可以修改默认默认对齐数。 写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明。 offsetof 宏的实现 1#define offsetof(S,m) &amp;(((S*)0)-&gt;m) S为类型，m为成员变量名。 将0强制转换为一个S结构体的地址，那么我们只要取得成员变量的地址就是偏移量了。 结构体传参代码： 12345678910111213141516171819202122struct S{ int data[1000]; int num;};struct S s = { {1,2,3,4}, 1000 };//结构体传参void print1(struct S s){ printf(&quot;%d\\n&quot;, s.num);}//结构体地址传参void print2(struct S* ps){ printf(&quot;%d\\n&quot;, ps-&gt;num);}int main(){ print1(s); //传结构体 print2(&amp;s); //传地址 return 0;} 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。 结论：尽量选择结构体传地址。 位段什么是位段位段的声明和结构是类似的，有两个不同： 位段的成员必须是 int、unsigned int 或signed int 。 位段的成员名后边有一个冒号和一个数字。 位段山给的空间是安装需要4个字节或一个字节的方式开辟的。 位段不跨平台，注重可移植的程序慎用。 比如： 12345678struct A{ int _a : 2;//占2个bit int _b : 5;//占5个bit int _c : 10;//占10个bit int _d : 30;//占30个bit，_d会全部放入新空间与否，这是不确定的。};printf(&quot;%d&quot;, sizeof(struct A)); 并且这里的 _a, _b , _c , _d 不能超过其类型的大小，这里是int所以都不能超过32个bit。 A就是一个位段类型。 那么位段A的大小是多少？ 输出： 8 这个大小很奇怪，所以先了解一下位段的内存分配方式。 成员空间的开辟方式 位段中全为int， 所以开辟1个（int），即4个byte。 将成员依次放入。 若空间不够，再次开辟4byte 至于不够的空间是会继续使用，还是弃用，这都是不确定的，即标准未定义，在VS下，不够用的空间会直接舍弃，而将数据全放入新空间。 在VS中 将每个成员的数据放入开辟好的内存中是先放到低bit位的 当上一个开辟的空间不够下一个成员使用，则上一个空间会被浪费。 每次开辟新空间，从低地址向高地址开辟。 若数据的bit位数多余我们给他的bit位数，那么会截断。 位段的内存分配 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。 123456789101112131415161718struct S{ char a : 3; char b : 4; char c : 5; char d : 4;};int main(){ struct S s = { 0 }; s.a = 10; s.b = 12; s.c = 3; s.d = 4; //空间是如何开辟的？ return 0;} 如图： 位段跨平台问题 int 位段被当成有符号数还是无符号数是不确定的。 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。 位段的应用 总结：与结构相比，位段可以达到同样的效果，可以很好的节省空间。 位段中如果都为int， 则每次开辟一个int大小的空间， 在内存中一个int的数据也是存在大小端的存储方式，并且按照声明顺序，先使用低位，再使用高位， 若数据溢出，则截断。 枚举枚举顾名思义就是一一列举咯 在概率论中也常常会用到这种枚举思想。 比如我们现实生活中：一周的周一到周日我们可以一一列举出来，则有穷就可以枚举。 枚举类型的定义12345678910111213141516171819202122enum Day//星期{ Mon, Tues, Wed, Thur, Fri, Sat, Sun};enum Sex//性别{ MALE, FEMALE, SECRET};enum Color//颜色{ RED, GREEN, BLUE}; 以上定义的enum Day, enum Sex, enum Color都是枚举类型 {}中的是枚举类型的可能取值，也叫做枚举常量。 这些可能取值都是数值，默认从0开始逐个增加1，也可在定义的时候赋值。 123456enum Color//颜色{ RED = 1, GREEN = 2, BLUE = 4}; 如果我们没有赋值的话，那么默认值是从0 到 2. 枚举的优点我们可以使用 #define 定义常量，为什么非要使用枚举？ 枚举的优点： 增加代码的可读性和可维护性； 和#define定义的标识符比较枚举有类型检查，更加严谨； 防止了命名污染（封装）； 便于调试； 使用方便，一次可以定义多个常量； 12345678enum Color//颜色{ RED = 1, GREEN = 2, BLUE = 4};enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。clr = 5; 总结：枚举类型和#define 有相似之处，枚举变量的取值只能在枚举常量中去取，但是由于认为常量是整形，所以其大小也是一个整形，硬要给枚举变量赋值一个int的值，也不会出什么问题， 因此 int 的变量也是可以被枚举常量赋值的。 联合(共用体)联合类型的定义联合也是一种特殊的自定义类型。 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。 比如： 12345678910//联合类型的声明union Un{ char c; int i;};//联合变量的定义union Un un;//计算连个变量的大小printf(&quot;%d\\n&quot;, sizeof(un)); 联合的大小是成员大小的累加吗？ 联合的特点 联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）。 12345678910111213union Un{ int i; char c;};union Un un;// 下面输出的结果是一样的吗？printf(&quot;%d\\n&quot;, &amp;(un.i));printf(&quot;%d\\n&quot;, &amp;(un.c));//下面输出的结果是什么？un.i = 0x11223344;un.c = 0x55;printf(&quot;%x\\n&quot;, un.i); 输出： i 和 c的地址是一样的，那就意味成它们的首地址是一样的。 再来看看修改c后，i的值也变了，那这就足以说明在联合中成员是共用一块内存的。 注意这里修改c的值影响i还受到大小端字节序的问题。 判断当前机器大小端12345678910int main(){ int a = 1; char* pc = (char*)&amp;a; if (*pc == 1) printf(&quot;小端\\n&quot;); else printf(&quot;大端\\n&quot;); return 0;} 取出 a 的首地址，首地址是第一个字节，即低地址，用char* 的指针接收，访问当前字节的内容，如果数值为 1 ，就说明 首地址 存储的是低位，即低位存储在低地址处，即小端，反之大端。 联合大小的计算 联合的大小至少是最大成员的大小。 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。 比如： 12345678910111213union Un1{ char c[5]; int i;};union Un2{ short c[7]; int i;};//下面输出的结果是什么？printf(&quot;%d\\n&quot;, sizeof(union Un1));printf(&quot;%d\\n&quot;, sizeof(union Un2)); 注意：当联合中存在数组时，那么该成员的对齐数，是其元素的大小和默认对齐数的较小值，结构中也是如此。","link":"/2023/01/12/C/15.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"},{"title":"C语言文件操作","text":"为什么使用文件内存是带电存储的，也就是说一旦断电，数据都会销毁，但是硬盘是可以不带电存储的，无论是否通电，只要未损坏，我们的数据就可以一致得以保存。 我们前面学习结构体时，写了通讯录的程序，当通讯录运行起来的时候，可以给通讯录中增加、删除数据，此时数据是存放在内存中，当程序退出的时候，通讯录中的数据自然就不存在了，等下次运行通讯录程序的时候，数据又得重新录入，如果使用这样的通讯录就很难受。 我们在想既然是通讯录就应该把信息记录下来，只有我们自己选择删除数据的时候，数据才不复存在。这就涉及到了数据持久化的问题，我们一般数据持久化的方法有，把数据存放在磁盘文件、存放到数据库等方式。使用文件我们可以将数据直接存放在电脑的硬盘上，做到了数据的持久化。 程序文件 包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。 数据文件本章讨论的是数据文件。 在以前各章所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。 其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件。 文件名一个文件要有一个唯一的文件标识，以便用户识别和引用。 文件名包含3部分：文件路径+文件名主干+文件后缀 例如： c:\\code\\test.txt 为了方便起见，文件标识常被称为文件名。 文件的打开和关闭文件指针缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。 每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE. 一般都是通过一个FILE的指针来维护这个FILE结构体的变量，这样用起来更加方便。 例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明： 1234567891011struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; };typedef struct _iobuf FILE; 对于不同的编译器FILE类型包含的内容不完全一样，但大都相似。 每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关心细节。 一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。 下面我们可以创建一个FILE*的指针变量: 1FILE* pf;//指向文件信息区 定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。 文件的打开和关闭文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。 在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。 ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件 12345//打开文件FILE * fopen ( const char * filename, const char * mode );//若打开失败，则返回NULL//关闭文件int fclose ( FILE * stream ); 打开方式有如下几种： 文件使用方式 含义 如果指定文件不存在 “r”（只读） 为了输入数据，打开一个已经存在的文本文件 出错 “w”（只写） 为了输出数据，打开一个文本文件 建立一个新的文件 “a”（追加） 向文本文件尾添加数据 建立一个新的文件 “rb”（只读） 为了输入数据，打开一个二进制文件 出错 “wb”（只写） 为了输出数据，打开一个二进制文件 建立一个新的文件 “ab”（追加） 向一个二进制文件尾添加数据 出错 “r+”（读写） 为了读和写，打开一个文本文件 出错 “w+”（读写） 为了读和写，建议一个新的文件 建立一个新的文件 “a+”（读写） 打开一个文件，在文件尾进行读写 建立一个新的文件 “rb+”（读写） 为了读和写打开一个二进制文件 出错 “wb+”（读写） 为了读和写，新建一个新的二进制文件 建立一个新的文件 “ab+”（读写） 打开一个二进制文件，在文件尾进行读和写 建立一个新的文件 例子： 123456789101112131415#include &lt;stdio.h&gt;int main (){ FILE * pFile; //打开文件 pFile = fopen (&quot;myfile.txt&quot;,&quot;w&quot;); //文件操作 if (pFile!=NULL)//打开成功 { fputs (&quot;fopen example&quot;,pFile);//写入数据 //关闭文件 fclose (pFile); } return 0;} 文件的顺序读写 功能 函数名 适用于 字符输入函数 fgetc 所有输入流 字符输出函数 fputc 所有输出流 文本行输出函数 fgets 所有输入流 文本行输出函数 fputs 所有输出流 格式化输入函数 fscanf 所有输入流 格式化输出函数 fprintf 所有输出流 二进制输入 fread 文件 二进制输出 fwrite 文件 程序的输出流： 函数原型： 1234567891011121314151617181920int fgetc ( FILE * stream );int fputc ( int character, FILE * stream );char * fgets ( char * str, int num, FILE * stream );//num：要复制到 str 中的最大字符数（包括终止空字符）int fputs ( const char * str, FILE * stream );int fscanf ( FILE * stream, const char * format, ... );//使用方法和scanf相似，只不过是从文件读取，而不是标准输入流int fprintf ( FILE * stream, const char * format, ... );//使用方法和printf相似，只不过是输出到文件，而不是标准输出流size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );//ptr指向要被读数组的指针，返回成功写入的元素总数size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );//ptr指向要被写的数组的指针，返回成功读取的元素总数 文件的随机读写fssek 根据文件指针的位置和偏移量来定位文件指针。 1int fseek ( FILE * stream, long int offset, int origin ); 例子： 1234567891011#include &lt;stdio.h&gt;int main (){ FILE * pFile; pFile = fopen ( &quot;example.txt&quot; , &quot;wb&quot; ); fputs ( &quot;This is an apple.&quot; , pFile ); fseek ( pFile , 9 , SEEK_SET ); fputs ( &quot; sam&quot; , pFile ); fclose ( pFile ); return 0;} 参数origin是指定文件指针当前偏移量。 注意：文件打开方式为追加时，使用此函数无效，无论如何都从文件尾部开始追加。 ftell 返回文件指针相对于起始位置的偏移量 1long int ftell ( FILE * stream ); 例子： 12345678910111213141516int main(){ FILE* pFile; long size; pFile = fopen(&quot;example.txt&quot;, &quot;a&quot;); if (pFile == NULL) perror(&quot;Error opening file&quot;); else { fseek(pFile, 2, SEEK_END); fputs(&quot;hello&quot;, pFile); size = ftell(pFile); fclose(pFile); printf(&quot;Size of myfile.txt: %ld bytes.\\n&quot;, size); } return 0;} 牢记：返回当前文件指针相对于文件开始的偏移量,每读取一个字节就向后偏移一位。 rewind 让文件指针的位置回到文件的起始位置 例子： 123456789101112131415161718/* rewind example */#include &lt;stdio.h&gt;int main (){ int n; FILE * pFile; char buffer [27]; pFile = fopen (&quot;myfile.txt&quot;,&quot;w+&quot;); for ( n='A' ; n&lt;='Z' ; n++) fputc ( n, pFile); rewind (pFile);//使文件指针回到文件起始位置 fread (buffer,1,26,pFile); fclose (pFile); buffer[26]='\\0'; puts (buffer); return 0;} 文本文件和二进制文件根据数据的组织形式，数据文件被称为文本文件或者二进制文件。 数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。 如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。一个数据在内存中是怎么存储的呢？ 字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2013测试）。 12345678910#include &lt;stdio.h&gt;int main(){ int a = 10000; FILE* pf = fopen(&quot;test.txt&quot;, &quot;wb&quot;); fwrite(&amp;a, 4, 1, pf);//二进制的形式写到文件中 fclose(pf); pf = NULL; return 0;} 文件读取结束的判定feof牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。 文本文件读取是否结束，判断返回值是否为 EOF （ fgetc ），或者 NULL （ fgets ） 例如： fgetc 判断是否为 EOF ，正常读取时，返回读到的ASCII码值 fgets 判断返回值是否为 NULL ，正常读取时，返回存放字符串空间的起始地址。 二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。 例如： fread判断返回值是否小于实际要读的个数，如果发现读取到的完整的元素个数小于指定的个数，那么这就是最后一次读取了。 正确的使用： 文本文件： 1234567891011121314151617181920int main(){ int c; // 注意：int，非char，要求处理EOF FILE* fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); if (!fp) { perror(&quot;File opening failed&quot;); return EXIT_FAILURE; } //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF while ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环 { putchar(c); }//判断是什么原因结束的 if (ferror(fp)) puts(&quot;I/O error when reading&quot;); else if (feof(fp)) puts(&quot;End of file reached successfully&quot;); fclose(fp);} feof如果是文件到了文件结束标志，那么返回非零值，否则返回0。 二进制文件： 123456789101112131415161718192021222324enum { SIZE = 5 };int main(void){ double a[SIZE] = { 1.,2.,3.,4.,5. }; FILE* fp = fopen(&quot;test.bin&quot;, &quot;wb&quot;); // 必须用二进制模式 fwrite(a, sizeof * a, SIZE, fp); // 写 double 的数组 fclose(fp); double b[SIZE]; fp = fopen(&quot;test.bin&quot;, &quot;rb&quot;); size_t ret_code = fread(b, sizeof * b, SIZE, fp); // 读 double 的数组 if (ret_code == SIZE) { puts(&quot;Array read successfully, contents: &quot;); for (int n = 0; n &lt; SIZE; ++n) printf(&quot;%f &quot;, b[n]); putchar('\\n'); } else { // error handling if (feof(fp)) printf(&quot;Error reading test.bin: unexpected end of file\\n&quot;); else if (ferror(fp)) { perror(&quot;Error reading test.bin&quot;); } } fclose(fp);} ferror 文件读取失败，返回非零。 如果已经读取完毕，返回0。 文件缓冲区ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。 123456789101112131415int main(){ FILE* pf = fopen(&quot;test.txt&quot;, &quot;w&quot;); fputs(&quot;abcdef&quot;, pf);//先将代码放在输出缓冲区 printf(&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\\n&quot;); Sleep(10000); printf(&quot;刷新缓冲区\\n&quot;); fflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘） printf(&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\\n&quot;); Sleep(10000); fclose(pf); //注：fclose在关闭文件的时候，也会刷新缓冲区 pf = NULL; return 0;} 结论：因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文件。 这和我们平时写文件时，如果关闭时没有点保存是一个原理，文件打开的时候，实际上还没有将数据写入到文件中，而是在缓冲区暂存，而保存操作，就相当于是一次fflush用于刷新缓冲区，将数据真正写入文件。","link":"/2023/01/12/C/17.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"C语言动态内存管理","text":"为什么存在动态内存分配栈区上的内存开辟 12int val = 20;//在栈空间上开辟四个字节char arr[10] = {0};//在栈空间上开辟10个字节的连续空间 这样直接在函数体中开辟内存的方式有它的特点 开辟内存的大小是固定的。 数组在申请空间是，需要指定数组大小。 出了函数作用域变量就失效了。 但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。 动态内存函数malloc 和 free C语言提供了一个动态内存开辟的函数： 1void* malloc (size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。 既然是动态内存开辟，那么有开辟内存就一定有释放内存。 C语言提供了另一个函数free，专门用来做动态内存的释放和回收。 1void free (void* ptr); free函数用来释放动态开辟的内存。 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。 函数执行后，ptr仍指向该地址。 想要使用这两个函数，我们需要包含头文件 stdlib.h 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(){ //代码1 int num = 0; scanf(&quot;%d&quot;, &amp;num); int arr[num] = {0}; //代码2 int* ptr = NULL; ptr = (int*)malloc(num*sizeof(int)); if(NULL != ptr)//判断ptr指针是否为空 { int i = 0; for(i=0; i&lt;num; i++) { *(ptr+i) = 0； } } free(ptr);//释放ptr所指向的动态内存 ptr = NULL;//是否有必要？ return 0;} 使用方式与数组很相似。 如果ptr不置空，会有什么问题吗？ 自然你是不会犯错的，但一个工程那么源文件，假如你在已经释放过这边空间了，但又没有及时指控，ptr却仍然指向原来的地址，好比你邻居有了你家的门钥匙，这可不合理合法，因此最好释放内存后，将指向该空间的指针都及时置空。 calloc C语言还提供了一个函数 calloc，它也是用来动态内存分配的。 1void* calloc (size_t num, size_t size); 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。 与malloc相比它显然多了一个功能，不过实在用的很少，完全可以使用malloc + memset两个函数代替，不过有还是比没有好的。 来个例子： 12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ int* ret = (int*)calloc(10, sizeof(int)); if (ret) { // } free(ret); ret = NULL; return 0;} 通过内存窗口看到这里四十个字节的16进制全部都成为了0，那么free又会发生什么？ free后这里的数据又都变成了随机值。 如果需要将开辟的内存初始化为0，那么使用calloc会很方便。 realloc 试想这样一种场景，假如我们申请了40个byte，但是现在却不够用了，那么只依靠malloc和calloc函数，我们怎么做？难道是另起炉灶，再重新开辟一块空间，这样做显然太笨重了，因此C语言还提供了我们用来动态管理内存空间的函数realloc。 realloc函数的出现让动态内存管理更加灵活。 有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，我们一定会对内存的大小做灵活的调整。那realloc 函数就可以做到对动态开辟内存大小的调整。 函数原型： 1void* realloc (void* ptr, size_t size); ptr是要调整的内存的地址 size是调整后的字节数 返回值为调整内存后的首地址 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。 realloc在调整内存空间的是存在两种情况： 原有空间后有充足的空间 原有空间后没有充足的空间 会出现这两种情况的原因是动态开辟的内存空间是随机的，即可能会形成一块空间上，断断续续的被我们所使用。 情况1 当是情况1 的时候，原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址。 情况2 当是情况2的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。 由于上述的两种情况，realloc函数的使用就要注意一些。 这是我们有内存增大需求的情况，如果是减小呢？ malloc在缩小内存时，将后面多余的空间free掉。 realloc找不到合适的空间时会返回NULL。 如果ptr为NULL，那么它的功能和malloc一样。 所以记得对返回的地址进行判空操作。 常见的动态内存错误对空指针的解引用操作123456void test(){ int *p = (int *)malloc(INT_MAX/4); *p = 20;//如果p的值是NULL，就会有问题 free(p);} 解决方法：对于返回的地址要判空。 对动态开辟空间的越界访问1234567891011121314void test(){ int i = 0; int *p = (int *)malloc(10*sizeof(int)); if(NULL == p) { exit(EXIT_FAILURE); } for(i=0; i&lt;=10; i++) { *(p+i) = i;//当i是10的时候越界访问 } free(p);} 对非动态开辟内存使用free释放123456void test(){ int a = 10; int *p = &amp;a; free(p);} p指向栈区而非堆区，free不能释放不是动态内存开辟的空间。 使用free释放一块动态开辟内存的一部分123456void test(){ int *p = (int *)malloc(100); p++; free(p);//p不再指向动态内存的起始位置} 会造成内存泄漏。 对同一块内存空间多次释放123456void test(){ int *p = (int *)malloc(100); free(p); free(p);//重复释放} 重复释放会导致第二次释放出现问题，释放已经不属于我们的内存空间显然不合适。 动态开辟的空间未释放12345678910111213void test(){ int *p = (int *)malloc(100); if(NULL != p) { *p = 20; }}int main(){ test(); while(1);} 忘记释放不再使用的动态开辟的空间会造成内存泄漏 动态开辟的内存一定要释放，且对于某一组内存操作函数，由谁开辟的，结束后，就由谁释放。 例如：链表的初始化需要动态申请内存空间，那么我们在使用完链表后，在销毁链表的函数中就应释放掉这些内存。 动态开辟的空间一定要释放，并且正确释放 ，多次的内存泄露会导致内存空间被浪费，导致卡顿，直至完全卡死。 C/C++程序的内存开辟 C/C++程序内存分配的几个区域： 栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。 堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。 数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。 代码段：存放函数体（类成员函数和全局函数）的二进制代码。 有了这幅图，我们就可以更好的理解在《C语言初识》中讲的static关键字修饰局部变量的例子了。 实际上普通的局部变量是在栈区分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。 但是被static修饰的变量存放在数据段（静态区），数据段的特点是在上面创建的变量，直到程序结束才销毁，所以生命周期变长。 柔性数组 也许你从来没有听说过柔性数组（flexible array）这个概念，但是它确实是存在的。 C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。 例如： 12345typedef struct st_type{ int i; int a[0];//柔性数组成员}type_a; 有些编译器会报错无法编译可以改成： 12345typedef struct st_type{ int i; int a[];//柔性数组成员}type_a; 柔性数组的特点 结构中的柔性数组成员前面必须至少一个其他成员。 sizeof 返回的这种结构大小不包括柔性数组的内存。 包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 例如： 1234567//code1typedef struct st_type{ int i; int a[0];//柔性数组成员}type_a;printf(&quot;%d\\n&quot;, sizeof(type_a));//输出的是4 柔性数组的使用12345678910//代码1int i = 0;type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));//业务处理p-&gt;i = 100;for(i=0; i&lt;100; i++){ p-&gt;a[i] = i;}free(p); 这样柔性数组成员a，相当于获得了100个整型元素的连续空间。 柔性数组的优势我们完全可以使用一个在结构体中引入一个指针成员，达到相似的效果。 12345678910111213141516171819//代码2typedef struct st_type{ int i; int *p_a;}type_a;type_a *p = (type_a *)malloc(sizeof(type_a));p-&gt;i = 100;p-&gt;p_a = (int *)malloc(p-&gt;i*sizeof(int));//业务处理for(i=0; i&lt;100; i++){ p-&gt;p_a[i] = i;}//释放空间free(p-&gt;p_a);p-&gt;p_a = NULL;free(p);p = NULL; 这两段代码可以完成相同的功能。 但是使用柔性数组有什么好处呢？ 第一个好处是：方便内存释放 如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。 第二个好处是：这样有利于访问速度. 连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址） 阅读：C语言结构体里的成员数组和指针 | 酷 壳 - CoolShell","link":"/2023/01/12/C/16.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"C语言实现通讯录","text":"简单功能展示 增加联系人功能。 按照姓名排序功能。 保存文件，重新启动重新加载功能。 头文件contact.h123456789101112131415161718192021222324252627282930313233343536373839//文件保存版#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;errno.h&gt;#define MAXNAME 20#define MAXNUMBER 20#define MAXADDR 20#define MAXSIZE 100#define DEFAULT_SZ 3typedef struct Information{ char name[MAXNAME]; char number[MAXNUMBER]; int age; char address[MAXADDR];}Information;typedef struct Contact{ Information* data; int sz; int capacity;}Contact;void menu();void Init(Contact* addrBook);void show(Contact* addrBook);void Add(Contact* addrBook);void Del(Contact* addrBook);int Find(Contact* addrBook, char name[MAXNAME]);void Search(Contact* addrBook);void Modify(Contact* addrBook);void Destroy(Contact* addrBook);int cmp(const void* e1, const void* e2);void sort(Contact* addrBook);void Save(Contact* addBook);void reload(Contact* addrBook); 函数体源文件contact.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&quot;contact.h&quot;void menu(){ printf(&quot;***************************\\n&quot;); printf(&quot;*******1.add 2.del ****\\n&quot;); printf(&quot;*******3.search 4.modify *\\n&quot;); printf(&quot;*******5.show 0.exit****\\n&quot;); printf(&quot;******* 6.sort **********\\n&quot;);}void Init(Contact* addrBook){ Information* tmp = (Information*)malloc(sizeof(Information) * DEFAULT_SZ); if (tmp != NULL) { addrBook-&gt;data = tmp; } else { printf(&quot;%s\\n&quot;, strerror(errno)); return; } addrBook-&gt;capacity = DEFAULT_SZ; addrBook-&gt;sz = 0;}void reload(Contact* addrBook){ FILE* pf = fopen(&quot;contact.txt&quot;, &quot;rb&quot;); if (pf == NULL) { printf(&quot;%s&quot;, strerror(errno)); return; } Information* tmp = NULL; Information buf = { 0 }; while (fread(&amp;buf, sizeof(Information), 1, pf) != 0) { if (addrBook-&gt;sz == addrBook-&gt;capacity) { tmp = realloc(addrBook-&gt;data, sizeof(Information) * (addrBook-&gt;capacity + 2)); if (tmp != NULL) { addrBook-&gt;data = tmp; addrBook-&gt;capacity += 2; printf(&quot;扩容成功\\n&quot;); } else { printf(&quot;%s&quot;, strerror(errno)); return; } } addrBook-&gt;data[addrBook-&gt;sz] = buf; addrBook-&gt;sz++; } printf(&quot;加载成功\\n&quot;); fclose(pf); pf = NULL;}void show(Contact* addrBook){ printf(&quot;%-15s\\t&quot;, &quot;姓名&quot;); printf(&quot;%-15s\\t&quot;, &quot;电话&quot;); printf(&quot;%-15s\\t&quot;, &quot;年龄&quot;); printf(&quot;%-15s\\t&quot;, &quot;地址&quot;); printf(&quot;\\n&quot;); for (int i = 0; i &lt; addrBook-&gt;sz; i++) { printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[i].name); printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[i].number); printf(&quot;%-15d\\t&quot;, addrBook-&gt;data[i].age); printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[i].address); printf(&quot;\\n&quot;); }}void Add(Contact* addrBook){ if (addrBook-&gt;sz == addrBook-&gt;capacity) { Information* tmp = (Information*)realloc(addrBook-&gt;data, (addrBook-&gt;capacity + 2) * sizeof(Information)); if (tmp != NULL) { addrBook-&gt;data = tmp; } else { printf(&quot;%s\\n&quot;, strerror(errno)); return; } addrBook-&gt;capacity += 2; printf(&quot;扩容成功\\n&quot;); } printf(&quot;请输入姓名\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[addrBook-&gt;sz].name); printf(&quot;请输入电话\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[addrBook-&gt;sz].number); printf(&quot;请输入年龄\\n&quot;); scanf(&quot;%d&quot;, &amp;addrBook-&gt;data[addrBook-&gt;sz].age); printf(&quot;请输入地址\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[addrBook-&gt;sz].address); addrBook-&gt;sz++; printf(&quot;添加联系人成功\\n&quot;);}int Find(Contact* addrBook,char name[MAXNAME]){ for (int i = 0; i &lt; addrBook-&gt;sz; i++) { if (strcmp(addrBook-&gt;data[i].name, name) == 0) return i; } return -1;}void Del(Contact* addrBook){ if (addrBook-&gt;sz == 0) { printf(&quot;通讯录为空\\n&quot;); return; } char name[MAXNAME] = { 0 }; printf(&quot;请输入要删除的人的名字\\n&quot;); scanf(&quot;%s&quot;, name); int pos = Find(addrBook, name); if (pos == -1) { printf(&quot;查无此人\\n&quot;); return; } for (int i = pos; i &lt; addrBook-&gt;sz - 1; i++) { addrBook-&gt;data[i] = addrBook-&gt;data[i + 1]; } addrBook-&gt;sz--; printf(&quot;删除成功\\n&quot;);}void Search(Contact* addrBook){ if (addrBook-&gt;sz == 0) { printf(&quot;通讯录为空\\n&quot;); return; } char name[MAXNAME] = { 0 }; printf(&quot;请输入要查找的人的姓名\\n&quot;); scanf(&quot;%s&quot;, name); int pos = Find(addrBook, name); if (pos == -1) { printf(&quot;查无此人\\n&quot;); return; } printf(&quot;%-15s\\t&quot;, &quot;姓名&quot;); printf(&quot;%-15s\\t&quot;, &quot;电话&quot;); printf(&quot;%-15s\\t&quot;, &quot;年龄&quot;); printf(&quot;%-15s\\t&quot;, &quot;地址&quot;); printf(&quot;\\n&quot;); printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[pos].name); printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[pos].number); printf(&quot;%-15d\\t&quot;, addrBook-&gt;data[pos].age); printf(&quot;%-15s\\t&quot;, addrBook-&gt;data[pos].address); printf(&quot;\\n&quot;);}void Modify(Contact* addrBook){ if (addrBook-&gt;sz == 0) { printf(&quot;通讯录为空\\n&quot;); return; } char name[MAXNAME] = { 0 }; printf(&quot;请输入要修改的人的名字\\n&quot;); scanf(&quot;%s&quot;, name); int pos = Find(addrBook, name); if (pos == -1) { printf(&quot;查无此人\\n&quot;); return; } printf(&quot;请输入姓名\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[pos].name); printf(&quot;请输入电话\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[pos].number); printf(&quot;请输入年龄\\n&quot;); scanf(&quot;%d&quot;, &amp;addrBook-&gt;data[pos].age); printf(&quot;请输入地址\\n&quot;); scanf(&quot;%s&quot;, addrBook-&gt;data[pos].address); printf(&quot;修改成功\\n&quot;);}void Destroy(Contact* addrBook){ free(addrBook-&gt;data); addrBook-&gt;data = NULL; addrBook-&gt;capacity = 0; addrBook-&gt;sz = 0;}int cmp(const void* e1, const void* e2){ struct Information* a = (struct Information*)e1; struct Information* b = (struct Information*)e2; return strcmp(a-&gt;name, b-&gt;name);}void sort(Contact* addrBook){ qsort(addrBook-&gt;data, addrBook-&gt;sz, sizeof(struct Information), cmp);}void Save(Contact* addrBook){ FILE* pf = fopen(&quot;contact.txt&quot;, &quot;wb&quot;); if (pf == NULL) { printf(&quot;%s&quot;, strerror(errno)); return; } fwrite((void*)addrBook-&gt;data, sizeof(Information), addrBook-&gt;sz, pf); fclose(pf); pf = NULL;} 主函数源文件test.c1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&quot;contact.h&quot;int main(){ int input = 0; Contact addrBook; Init(&amp;addrBook); reload(&amp;addrBook); do { menu(); printf(&quot;请输入\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) { case 0: Save(&amp;addrBook); Destroy(&amp;addrBook); printf(&quot;退出\\n&quot;); break; case 1: Add(&amp;addrBook); break; case 2: Del(&amp;addrBook); break; case 3: Search(&amp;addrBook); break; case 4: Modify(&amp;addrBook); break; case 5: show(&amp;addrBook); break; case 6: sort(&amp;addrBook); break; default: printf(&quot;输入错误，请重新输入\\n&quot;); break; } } while (input); return 0;}","link":"/2023/01/12/C/19.C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E3%80%90%E9%80%9A%E8%AE%AF%E5%BD%95%E3%80%91/"},{"title":"C语言程序的编译","text":"程序的翻译环境和执行环境在ANSIC的任何一种实现中，存在两个不同的环境。 第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。 第2种是执行环境，它用于实际执行代码。 详解编译+链接翻译环境 组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。 每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。 链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。 编译的过程123456sum.cint g_val = 2016;void print(const char *str){ printf(&quot;%s\\n&quot;, str);} 12345678910test.c#include &lt;stdio.h&gt;int main(){ extern void print(char *str); extern int g_val; printf(&quot;%d\\n&quot;, g_val); print(&quot;hello bit.\\n&quot;); return 0;} 函数只有声明的时候，在test.c中是没有给 _ sum函数分配地址的，在_sum函数中定义的sum.c中才记录有 _ sum 函数的地址，在链接时，会有符号表的合并和符号表的重定位，这也是为什么即使我们没有声明函数直接调用定义在另一个源文件中的函数，也仍能够跑起来，并且只是弹出警告的原因。 接下来我们在linux下一步一步看发生了什么 预处理 运行如上简单程序。 可以看到当前目录下只有test.c文件 使用gcc -E test.c -o test.i预处理命令 并将产生的的结果放在test.i中，可以看到我们本目录下多了一个test.i文件，我们来看看其中的内容。 文件内容略长，我们仅仅看开头和结尾，开头是头文件的包含内容，包括链接库的路径等等。 结尾就是我们所写的函数了可以看到被处理的仅仅是预处理指定 #include 。 编译 使用gcc -S test.i -o test.s 编译命令 并且将结果输出到test.s文件 接下来看看这个文件是什么？ 嗯~这里已经没有那么多的文件内容了，不懂没关系，大致能看出来这是汇编指令了。 那么说明这里是将程序编译为汇编语言。 汇编 同样的执行gcc -c test.s -o test.o汇编指令 汇编完成之后就停下来，结果保存在test.o中，看到test.o已经存在了。 继续进入test.o中查看： 这下谁也看不懂了，因为汇编会将汇编语言编程机器二进制语言，而我们使用的是文本编辑器，所以都是乱码。 那么这个test.o可以直接运行吗，试一下： 没有权限，并且这被当作是一个普通文件，并不是可执行文件。 使用gcc -o test test.o命令，继续看看，我们通过test.o生成了一个test可执行文件。 执行结果： 我们的hello linux!就输出到我们的屏幕上了。 运行环境程序执行的过程： 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。 程序的执行便开始。接着便调用main函数。 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。 终止程序。正常终止main函数；也有可能是意外终止。 程序载入内存中可以简单想象为将变量数据将函数指令等，载入内存中某些特定的位置，并记录这个地址，让我们运行程序时可以根据需要访问这些地址上存储的指令或者数据。 预处理详解预处理符号12345__FILE__ //进行编译的源文件__LINE__ //文件当前的行号__DATE__ //文件被编译的日期__TIME__ //文件被编译的时间__STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义 这些预定义符号都是语言内置的。 例子： 1printf(&quot;file:%s line:%d\\n&quot;, __FILE__, __LINE__); 所在的文件，以及文件当前的行号就被打印出来了。 #define#define定义标识符例子： 123456789#define MAX 1000 //预处理过程中会将MAX替换成1000#define reg register //为 register这个关键字，创建一个简短的名字#define do_forever for(;;) //用更形象的符号来替换一种实现#define CASE break;case //在写case语句的时候自动把 break写上。// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。#define DEBUG_PRINT printf(&quot;file:%s\\tline:%d\\t \\ date:%s\\ttime:%s\\n&quot; ,\\ __FILE__,__LINE__ , \\ __DATE__,__TIME__ ) 问题来了，通常一个语句末尾会加上 ;，那么这里需要加上吗？ 比如： 12#define MAX 1000;#define MAX 1000 建议不要加上 ; ,这样容易导致问题。 例如： 1234if(condition) max = MAX;else max = 0; 我们知道MAX在预处理后会被替换为 1000；，那么就变成了下面： 12345if(condition) max = 1000; ;else max = 0; 由于else和if并不是紧挨着，而是有一条空语句，那么else就无法生效，就有语法错误。 #define 定义宏 #define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。 下面是宏的申明方式：#define name( parament-list ) stuff，其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。 注意：参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在,参数列表就会被认为是要替换的部分，参数列表就会被解释为stuff的一部分。 如下： 1#define SQUARE( x ) x * x 这个宏接收一个参数 x . 如果在上述声明之后，你把 1SQUARE( 2 ); 置于程序中，那么这个表达式会被替换为 5 * 5. 替换嘛，总是存在一些问题，通常会因为优先级的问题，导致实际结果和我们预估的不太一样。 例如： 12345678#define SQUARE(X) X * Xint main(){ int i = 2 printf(&quot;%d&quot;, SQUARE(i + 1)); return 0;} 不注意看可能就认为会输出 9 了，事实上它会在屏幕上输出 5 。 为什么? 替换文本时，参数x被替换成a + 1,所以这条语句实际上变成了：printf (“%d\\n”,a + 1 * a + 1 ); 可以看到，该表达式执行的运算的优先级与我们想的并不同，解决这个问题，在宏定义上加上两个括号就行。 1#define SQUARE(X) (X) * (X) 这样在预处理替换后，代码就如下： 12345678#define SQUARE(X) (X) * (X)int main(){ int i = 2 printf(&quot;%d&quot;, (i + 1) * (i + 1)); return 0;} 当前问题算是解决了。 这里还有一个宏定义： 1#define DOUBLE(x) (x) + (x) 定义中我们使用了括号，想避免之前的问题，但是这个宏可能会出现新的错误。 如下： 12int a = 5;printf(&quot;%d\\n&quot; ,10 * DOUBLE(a)); 我们本想用DOUBLE(a),来完成乘 2 的操作，结果再和 10 相乘，这样看来答案是 100 . 事实上这里将会打印出 55。 仍然查看替换后的代码： 12int a = 5;printf(&quot;%d\\n&quot; ,10 * (a) + (a)); 乘法的优先级高于加法，所以出现了不可预料的答案。 这个问题的解决办法是在宏定义表达式两边加上一对括号就可以了。 1#define DOUBLE( x) ( ( x ) + ( x ) ) 所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用 #define替换规则在程序中扩展#define定义符号和宏时，需要涉及几个步骤。 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。 注意： 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。 ## 和 #如何把参数插入到字符串中？ 首先我们看看这样的代码： 1234char* p = &quot;hello &quot;&quot;sx\\n&quot;;printf(&quot;hello&quot;,&quot; sx\\n&quot;);printf(p);//直接将地址作为参数，这和下面的方式是一样的,都是去访问地址上的数据printf(&quot;%s&quot;, p); 这里输出的是不是hello sx？ 答案是确定的：是。我们发现字符串输出是有自动连接的特点的。 那我们是不是可以写这样的代码？： 123#define PRINT(FORMAT, VALUE)\\ printf(&quot;the value is &quot;FORMAT&quot;\\n&quot;, VALUE);PRINT(&quot;%d&quot;, 10); 这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中。 另外一个技巧是：使用 # ，把一个宏参数变成对应的字符串。 例如： 12345int i = 10;#define PRINT(FORMAT, VALUE)\\printf(&quot;the value of &quot; #VALUE &quot;is &quot;FORMAT &quot;\\n&quot;, VALUE);...PRINT(&quot;%d&quot;, i+3);//产生了什么效果 代码中的 #VALUE 会预处理器处理为：&quot;VALUE&quot; . 最终的输出的结果应该是： 1the value of i+3 is 13 ##的作用 ##可以把位于它两边的符号合成一个符号。 它允许宏定义从分离的文本片段创建标识符。 1234#define ADD_TO_SUM(num, value) \\sum##num += value;...ADD_TO_SUM(5, 10);//作用是：给sum5增加10. 实际上执行的是： sum和num合并为一个标识符：sum5 sum5 += 10; 注意： 这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。 带副作用的宏参数当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。例如： 12x+1;//不带副作用x++;//带有副作用 MAX宏可以证明具有副作用的参数所引起的问题。 12345#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )x = 5;y = 8;z = MAX(x++, y++);printf(&quot;x=%d y=%d z=%d\\n&quot;, x, y, z);//输出的结果是什么？ 我们将代码中的宏进行替换： 1z = ( (x++) &gt; (y++) ? (x++) : (y++)); 输出： 1x=6 y=10 z=9 要避免写出这样的代码，宏是无法调试的，一旦没搞清楚，比较麻烦。 宏和函数对比宏通常被应用于执行简单的运算。 比如在两个数中找出较大的一个。 1#define MAX(a, b) ((a)&gt;(b)?(a):(b)) 那为什么不用函数来完成这个任务？ 原因有二： 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹。 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于来比较的类型。宏是类型无关的。 宏的缺点：当然和函数相比宏也有劣势的地方： 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。 宏是没法调试的。 宏由于类型无关，也就不够严谨。 宏可能会带来运算符优先级的问题，导致程容易出现错。 如果一个程序中多次重复地使用一个功能，那么还是尽量避免使用宏来实现，这样子会造成代码膨胀，尤其是代码量比较多地宏，更应避免使用，宏地最佳使用场景就是一些简单功能地实现。 如果宏比较复杂，且多次在程序中替换，那么就会有大量地重复代码，而函数永远是解决代码复用的最佳工具，宏被替换到栈帧中，就算这个宏的功能已经完成，但是由于当前栈帧仍需使用，宏的指令变会一直存在与栈帧空间中，直到栈帧被释放。 而函数在调用时会进行压栈，开辟新的栈帧空间，当它的使命完成后，就会返回上一层栈帧并自动销毁，这样的方式很好的解决了宏的缺陷，即——指令结束使命后 “ 占着茅坑不拉屎 “ 的问题。 宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。 1234567#define MALLOC(num, type)\\(type *)malloc(num * sizeof(type))...//使用MALLOC(10, int);//类型作为参数//预处理器替换之后：(int *)malloc(10 * sizeof(int)); 这确实是一个很厉害的一点，由于宏替换的性质，宏的参数可以是任何标识符，数字，或者是其他东西，有点来者不拒的感觉，但这同时也是它的缺点，没有类型检查，好比人人都有你家钥匙，指不定哪天就出问题了。 宏和函数的一个对比 属性 #define定义宏 函数 代码长度 每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长 函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码 执行速度 更快 存在函数的调用和返回的额外开销，所以相对慢一些 操作符优先级 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号。 函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。 带有副作用的参数 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果。 函数参数只在传参的时候求值一次，结果更容易控制。 参数类型 宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用于任何参数类型。 函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。 调试 宏是不方便调试的 函数是可以逐语句调试的 递归 宏是不能递归的 函数是可以递归的 宏无法递归，因为在定义宏的时候写出自身宏的时候，是无法识别的，宏只有被完整的定义之后，才被编译器当作可识别的宏。 例如： 1#define SUM(n) (n &gt; 0 ? (n + SUM(n - 1)) : 0) 这个宏还没定义完呢，就又想使用这个宏，显然不太合理。 命名约定一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。那我们平时的一个习惯是： 把宏名全部大写 函数名不要全部大写 undef 这条指令用于移除一个宏定义。 12#undef NAME//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。 例如： 123#define MAX 10#undef MAXint a = MAX; 这里的程序就出现了错误，在编译器看来，MAX是个未定义的标识符。 命令行定义许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。 例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大些，我们需要一个数组能够大些。） 12345678910111213141516#include &lt;stdio.h&gt;int main(){ int array [ARRAY_SIZE]; int i = 0; for(i = 0; i&lt; ARRAY_SIZE; i ++) { array[i] = i; } for(i = 0; i&lt; ARRAY_SIZE; i ++) { printf(&quot;%d &quot; ,array[i]); } printf(&quot;\\n&quot; ); return 0;} 编译指令： 12//linux 环境演示gcc -D ARRAY_SIZE=10 programe.c 条件编译在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。 比如说： 调试性的代码，食之无味，弃之可惜，所以我们可以选择性的编译。 1234567891011121314#include &lt;stdio.h&gt;#define __DEBUG__int main(){ int i = 0; int arr[10] = {0}; for(i=0; i&lt;10; i++) { arr[i] = i;#ifdef __DEBUG__ printf(&quot;%d\\n&quot;, arr[i]);//为了观察数组是否赋值成功。 #endif //__DEBUG__ } return 0;} 常见的条件编译指令： 12345678910111213141516171819202122232425262728293031323334353637381.#if 常量表达式 //...#endif//常量表达式由预处理器求值。如：#define __DEBUG__ 1#if __DEBUG__ //..#endif2.多个分支的条件编译#if 常量表达式 //...#elif 常量表达式 //...#else //...#endif3.判断是否被定义#if defined(symbol)#ifdef symbol #if !defined(symbol)#ifndef symbol 4.嵌套指令#if defined(OS_UNIX) #ifdef OPTION1 unix_version_option1(); #endif #ifdef OPTION2 unix_version_option2(); #endif#elif defined(OS_MSDOS) #ifdef OPTION2 msdos_version_option2(); #endif#endif 文件包含我们已经知道， #include 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方一样。 这种替换的方式很简单，预处理器先删除这条指令，并用包含文件的内容替换。这样一个源文件被包含10次，那就实际被编译10次。 头文件被包含的方式 本地头文件包含 1#include &quot;filename&quot; 查找策略：先在源文件所在根目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。 如果找不到就提示编译错误。 Linux环境的标准头文件的路径： VS环境的标准头文件的路径： 1C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include 库文件包含 1#include&lt;filename.h&gt; 查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。这样是不是可以说，对于库文件也可以使用 “ ” 的形式包含？ 答案是肯定的，可以。 但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。 嵌套文件包含 如果出现这样的场景： conmm.h和conmm.c是公共模块。add.h和add.c使用了公共模块。multi.h和multi.c使用了公共模块。test.h和test.c使用了add模块和multi模块。这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。 如何解决这个问题？ 答案：条件编译。 每个头文件的开头写： 1234#ifndef __TEST_H__#define __TEST_H__//头文件的内容#endif //__TEST_H__ 或者 1#pragma once 就可以避免头文件的重复包含 121. 头文件中的 ifndef/define/endif是干什么用的?2. #include &lt;filename.h&gt; 和 #include &quot;filename.h&quot;有什么区别? 避免头文件重复引入 一个是从标准路径下查找，若找不到则编译错误，第二个是先在当前路径下查找，若找不到，再到标准路径下查找，还是找不到则编译错误。 其他预处理指令1234#error#pragma#line#pragma pack()","link":"/2023/01/12/C/18.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E3%80%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91/"},{"title":"C语言转义字符","text":"💦字符串 字符串是什么 例：”hello world！“ 这种被双引号” “引起来的一串字符叫做字符串字面值，简称字符串。 注意：在我的上一篇文章已经讲过，字符串的结束标志是一个‘\\0’的转义字符，在字符串的末尾被省略了。 字符串的存储方式 我们都知道，一个字符是储存在变量中的。 那字符串储存在哪里呢？ 接下来介绍一下在C语言中存储字符串的两种方式，上代码： 123456789101112int main(){ char arr1[] = &quot;hehe&quot;; char arr2[] = { 'h','e','h','e' };//字符挨个连续地储存到数组中 char arr3[] = { 'h','e','h','e' ,'\\0' }; char*arr4 = &quot;hehe&quot;; //”hehe“这样的字符串在程序中其实是首字符的地址 printf(&quot;%s\\n&quot;, arr1); printf(&quot;%s\\n&quot;, arr2); printf(&quot;%s\\n&quot;, arr3); printf(&quot;%s\\n&quot;, arr4); return 0;} 输出结果如下： 可以看到arr1和arr3的输出结果是相同的，但是arr2的结果就让人看不懂了，虽然 ==”hehe”==仍在屏幕上打印出来了，但后面跟了”烫烫烫烫hehe“的乱码。 思考：出现这种情况的原因是什么呢？ 我们来调试一下代码，如下： 分析：似乎他们的不同之处也就只有arr1的末尾比arr2多了一个‘\\0’，而我们也联想到了另一个函数那就是strlen函数，在使用strlen函数时也出现了这样一个问题，strlen函数在返回arr2这样的数组的字符串长度时，总是返回的随机值。 这里就与printf打印字符串的方式有关了，printf在以%s的形式打印arr2时，不断的向后打印每一个字符在标准输出上，直到遇到’\\0’才会停止操作。 这里附上一条详细介绍printf函数的链接。如下： printf函数详解 牢记:字符串的结束标志是一个’\\0’转义字符，一定不能忽略。 💦转义字符 如果想打印出一个文件的路径，我们该写出什么样的代码？ 例：打印出 c:\\code-c++\\test.cpp 我们来尝试一下我们大概率首先想到的代码。如下： 12345int main(){ printf(&quot;%s\\n&quot;, &quot;c:\\code - c++\\test.cpp&quot;); return 0;} 接下来看看运行结果： 这似乎与我们想要的不太一样，我们来看看少了哪些东西。 思考：这里红色框框内就是没有打印出来分别的是‘\\‘和’\\t’,这似乎两者都带着一个 ==’\\ ‘== 字符，那这究竟是什么呢？ 这就不得不提到转义字符，顾名思义就是转变含义。 转义字符 释义 \\? 在书写连续多个问号时，防止他们被解析成三字母词 \\‘ 用于表示字符常量 ’ \\“ 用于表示一个字符串内部的双引号（将”的含义从双引号的一半”—&gt;单纯的 “ 符号） \\\\ 用于表示一个反斜杠，防止它被解释为一个转义字符 \\a 警告字符，蜂鸣 \\b 退格符 \\f 进纸符 \\n 换行 \\r 回车 \\t 制表符 \\v 垂直制表符 \\ddd ddd表示3个八进制的数字 \\xdd dd表示两个十六进制的数字 接下来解决两个问题： 问题一：如何在屏幕上打印一个单引号 ‘ 问题二：如何在屏幕上打印一个字符串，字符串内容是一个双引号 “ 通常在不了解转义字符的情况下，我们会写出如下代码： 123456int main(){ printf(&quot;%c&quot;, &quot;'&quot;); print(&quot;%c&quot;, &quot;&quot;&quot;); return 0;} 可以看到已经报错了这里已经报错了，错误如下图： 既然这样不行，我们结合一下上面的转义字符表再来尝试； 接着我们修改一下代码，如下： 可以看到VS报的错误已经没有了，那我们来试试是否可以编译呢？ 成功在屏幕上打印出了 =='和 &quot;==。 回到刚刚打印路径的问题： 例：打印出 c:\\code-c++\\test.cpp 分析：根据上面的表格 我们可以看到这里的 ‘\\t’ 和 ‘\\\\‘ 都是转义字符’'，因此我们如果想要在屏幕上打印出 ‘\\t’ 和 ‘\\' 就必须防止‘\\’被解释为转义字符前面的那个‘\\‘. 因此，我们利用 ‘\\\\‘ 这个转义字符的作用，在’\\t’和’\\‘前再加一个’\\‘。如下图： 显然，我们达成了目的，与我们想要的结果一致。 为了巩固这一重要却容易被忽视的知识点，我们再来做一个题： 123456int main(){ printf(&quot;%d\\n&quot;, strlen(&quot;nihao&quot;)); printf(&quot;%d\\n&quot;, strlen(&quot;c\\768code-c++\\test&quot;)); return 0;} 先来回顾strlen的功能：strlen求得的是字符串的字符个数。 答案是多少呢？ 先让我们来分析分析，除了转义字符外，其他字符都是单独存在的。 “c\\768code-c++\\test” 这个字符串中有两个 ‘\\‘ ，我们来重点看看这两个地方： 结合转义字符表： 这样一对比是不是觉得很清晰了呢？ 显然，我们可以看到 ==’\\t’ 和’\\76’== 是两个转义字符。 到了这里又有一个新的疑问： 思考：’\\768’是不是转义字符呢？ 注意，这里的8不是八进制数字，所以’\\768’不是一个转义字符 这里的\\ddd中的d只能是八进制的数字，这也是一个大家非常容易忽略的地方。 分析结束后，我们就可以开始数字符个数了！ 运行结果： 答案是15 大家数对了吗？ 小结：转义字符也是字符，大小为1个byte。 💦注释 注释方式 C语言的注释风格：/* xxxxxxxxxxx */ 缺陷:不能嵌套注释 C++风格的注释风格：// xxxxxx 特点：可以注释一行也可以注释多行","link":"/2023/01/12/C/2.%E3%80%90%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80%E3%80%91%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"},{"title":"初识C语言上","text":"💦选择与循环无论在生活中还是工作中，我们不可避免的要做出选择甚至日复一日地重复某件事情。 “人是铁饭是钢，一顿不吃饿得慌”，确实，我们每天都要重复做的一件事，那就是吃饭。 今天吃什么呢？干锅还是汤锅？这时，我们总是要做出一个选择。 思考：我们在生活中解决问题时，似乎总是离不开选择和循环，那么计算机解决一个问题是不是也是如此呢？ 下面开始介绍。 选择语句这与我们生活中很相似！ 接着我们来代码实现： 123456789101112131415161718#include&lt;stdio.h&gt;enum select //枚举关键{ Play_game,//枚举出可能的情况，其实这里 Study_hard,//可有可无的，感受更直观 };int main(){ int My_Choice = 0; printf(&quot;你会努力学习编程吗?请选择-&gt;(1.Study_hard or 0.Play_game)\\n&quot;); printf(&quot;请输入&quot;); scanf(&quot;%d&quot;, &amp;My_Choice); if (My_Choice) //选择语句 printf(&quot;成为大牛，走向人生巅峰！&quot;); else //选择语句 printf(&quot;碌碌无为&quot;); return 0;} 接着我们来做出我们的选择吧！ 这里可以看到我选择了1.Study hard,这里就在屏幕上打印出了： 成为大牛，走向人生巅峰！ 我们再回到选择语句： if(judge) {true};else {false}; 在if后面的（）里，如果判断为真，则执行true，否则执行false。 牢记：选择语句的条件判断中，0为假，非0为真！ 循环语句有些事必须一直做，比如我们日复一日地吃饭。 那么C语言如何实现循环呢？ 循环有三种： while语句 for语句 do while语句 这里我们先只看while语句 while语句相应的代码： 12345678910111213#include&lt;stdio.h&gt;int main(){ printf(&quot;开始学习！\\n&quot;); int study_time = 0;//学习天数 while (study_time &lt; 5000) { study_time++;//重复学习 } if(study_time&gt;=5000) printf(&quot;已经闭关5000天，拿到好offer&quot;); return 0;} 小结：while后面的（）里的条件如果为真（非0）就进入循环体，为假（0）就结束循环。 💦函数听到函数是不是很熟悉？但是此函数非彼函数。 C语言函数的定义： dataType functionName(){//body } dataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。 functionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。 body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由{ }包围。 如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。 （）里是函数的形式参数。 来看个例子： 思考：如何利用C语言，实现一个计算两数之和的函数？ 代码如下： 123456789101112131415#include&lt;stdio.h&gt;int ADD(int a, int b){ return a + b;}int main(){ int x = 0;//初始化 int y = 0; printf(&quot;请输入x，y\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y);//输入x，y int sum = ADD(x, y); printf(&quot;x+y=%d\\n&quot;, sum); return 0;} 运行结果： 在我输入2 ，4后，可以看到2+4的结果被打印在了屏幕上。 总结：数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部，并且可以简化代码，代码复用。 💦数组创建一个变量我们可以对其赋值并使用，但如果我们想创建许多个类型相同的变量，该怎么做呢？ 如果还是一个一个地去创建，未免太过浪费时间。 思考：可不可以在内存中申请一块连续的空间，这块空间可以存放多个数据？ 于是数组应运而生. C语言中给了数组的定义：一组相同类型元素的集合 数组的定义 1int arr[5]={1,2,3,4,5};//定义一个整型数组，最多放5个元素 数组的下标 C语言规定：数组的每个元素都有一个下标，下标是从0开始的。 使用下标访问数组。 注意：下标是从0开始的。 比如： 数组的使用 例：将数组arr的每一个元素打印在屏幕上。 1234567891011#include&lt;stdio.h&gt;int main(){ int i= 0; int arr[5] = { 4,6,8,10,12 };//初始化数组 for (i = 0; i &lt; 5;i++) { printf(&quot;a[%d]= %d\\n&quot;,i, arr[i]);//打印元素 } return 0;} 运行结果： 利用循环，数组的每个元素的值就被打印在屏幕上了。 💦操作符简单介绍，后面会着重讲 算术操作符对两个数进行运算的符号（%是取余） 1+ - * / % 例：1+2 移位操作符1&gt;&gt; &lt;&lt; 移动的是二进制位 例：将1左移一位得到多少？ 代码： 1234567#include&lt;stdio.h&gt;int main(){ char a = 1 &lt;&lt; 1; printf(&quot;%d&quot;, a); return 0;} 运行结果： 结果为2，我们来分析分析： 00000001 //这是1的二进制 左移1位后： 最右边空出来一位补0如下： 00000010 //将这个值赋值给a，也就是2 位操作符 位操作符 解释 &amp; 按位与 | 按位或 ^ 按位异或 例：将3和5两个数按位与得到多少？ 代码： 123456789#include&lt;stdio.h&gt;int main(){ char a = 3; //赋值 char b = 5; char c = a &amp; b;//将3和5按位与的结构赋值给c printf(&quot;c=%d&quot;, c); return 0;} 运行结果： c=1这是为什么呢？ 按照上面的规则分析： 3的二进制： 00000011 5的二进制： 00000101 按位与：对应二进制位置上的数字分别进行&amp;操作，然后按原位进行排列 (1 1)-&gt;1(1 0)-&gt;0(0 1)-&gt;0(0 0)-&gt;0就得到： 00000001 即为1. 按位或和按位异或也是相似的方法。 总结： 按位与：只要有一个0结果就为0，否则为1。 按位或：只要有一个1结果就为1，否则为0。 按位异或：相同为0，相异为1。 赋值操作符1= += -= *= /= &amp;= ^= |= &gt;&gt;= &lt;&lt;= 例：a+=1是怎么运算的？ 12345678910#include&lt;stdio.h&gt;int main(){ int a = 1; a += 1; printf(&quot;a+=1后a=%d\\n&quot;, a); a += 1; printf(&quot;a+=1后a=%d\\n&quot;, a); return 0;} 其实 a+=1 与 a=a+1是一样的，也就得到了上面的结果。 其他的赋值运算符也都和+=类似。 单目操作符 单目操作符：只有一个操作数。 符号 解释 ! 逻辑反操作—&gt;采用逻辑运算 - 负值 + 正值 &amp; 取地址 sizeof 操作数的类型长度（不一定是数，也可以是类型) ~ 对一个数的二进制按位取反 - - 前置、后置- - ++ 前置、后置++ * 间接访问操作符（解引用操作符） (类型) 强制类型转换 关系操作符 符号 解释 &gt; 比较大小 &gt;= &lt; &lt;= != 判断是否相等 == 逻辑操作符 逻辑运算 运算符 解释 &amp;&amp; 逻辑与 | | 逻辑或 牢记：进行逻辑运算时，只看真假。 我们知道非0为真，0为假。 与高中数学一样，”与 “必须时两个都为真，结果为真； 而 ”或“则只要其中一个为真，结果就为真。 例：求1 &amp;&amp; 0 和 1 || 0的结果。 代码： 12345678#include&lt;stdio.h&gt;int main(){ int a = (1 &amp;&amp; 0); int b = (1 || 0); printf(&quot;a=%d,b=%d&quot;, a, b); return 0;} 运行结果： 与我们所想的完全一致。 条件操作符 exp1?exp2:exp3 含义：如果exp1为真，则整个表达式结果为exp2，否则为exp3。（exp是表达式） 例：max=（a&gt;b?a:b) 逗号表达式 例：exp1,exp2,exp3,…,expN 逗号表达式也叫隔开表达式。 （exp1,exp2,exp3,…,expN）这整个表达式的结果为最后一个exp，即expN。 其他 下标引用[ ] 例：a[0]=1; 函数调用() 例：调用rand函数 rand(); 结构体成员.结构体变量名 . 成员名-&gt; 结构体变量指针-&gt;成员名 代码： 123456789101112131415161718192021#include&lt;stdio.h&gt;struct book //创建一个结构体类型{ int price; char name[20]; int number;};int main(){ struct book C = { 22,&quot;C语言&quot;,002233 };//定义一个结构体变量 struct book* pc = &amp;C; printf(&quot;直接通过变量访问成员：\\n&quot;); printf(&quot; price=%d\\n&quot;, C.price);//通过.操作符访问变量成员 printf(&quot; name=%s\\n&quot;, C.name); printf(&quot; number=%d\\n&quot;, C.number); printf(&quot;通过结构体变量的指针访问成员：\\n&quot;); printf(&quot; price=%d\\n&quot;, pc-&gt;price);//通过-&gt;操作符访问变量成员 printf(&quot; name=%s\\n&quot;, pc-&gt;name); printf(&quot; number=%d\\n&quot;, pc-&gt;number); return 0;} 运行结果： 这里就简单介绍了两种访问方式，他们之间还是有一定差异，但最终的效果是一样的。","link":"/2023/01/12/C/3.%E3%80%90%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80%E3%80%91%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"初识C语言下","text":"💦常见关键字 关键字 作用 auto 由auto修饰的自动变量 break 跳出循环和switch分支语句 case 分支语句 const 由const修饰的常变量 continue 跳过本次循环体开始下一次循环 default 默认分支语句 enum 枚举关键 extern 引入外部符号 goto 改变函数内代码的执行顺序,跳转到函数内指定的标签地方运行,goto不能跨函数代码块跳转 register 寄存器 unsigned 无符号数 struct 创建结构体类型 switch 分支语句 typedef 类型重定义 union 创建联合体 void 空 volatile 用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错 … … 关键字typedf typedef顾名思义是类型重定义，也可以理解为类型重命名。 说得再通俗一点就是给一个类型重新起个名字。比如： 12345678910#include&lt;stdio.h&gt;//将unsigned重新命名为unsin，所以unsin也是一个类型名typedef unsigned int unsind;int main(){ //观察a和b，这两个变量的类型是一样的 unsigned int a = 0; unsind b = 0; return 0;} 关键字static 在C语言中，static是用来修饰变量和函数的 修饰局部变量-称为静态局部变量。 修饰全局变量-称为静态全局变量。 修饰函数-称为静态函数。 static修饰局部变量那究竟有什么作用呢？来对比下面两个代码。 1234567891011121314151617#include&lt;stdio.h&gt;//代码1void test(){ int i = 0; i++; printf(&quot;%d &quot;, i);}int main(){ int i = 0; for (i = 0; i &lt; 10; i++) { test(); } return 0;} 运行结果： 在屏幕上输出了10个1. 123456789101112131415161718#include&lt;stdio.h&gt;//代码2void test(){ //这里将i用static修饰 static int i = 0; i++; printf(&quot;%d &quot;, i);}int main(){ int i = 0; for (i = 0; i &lt; 10; i++) { test(); } return 0;} 运行结果： 输出了从1~10的数字。 对比代码1和代码2的效果理解static修饰局部变量的意义。 代码1：在没有static修饰的局部变量 i 中，执行程序一旦离开其被创建的那个块内，就自动销毁。 代码2：static修饰的局部变量 i ,在程序运行到 i 所在的块时，不再重新创建，而是使用上一次保留的变量值，执行程序离开了块后也不会销毁，仍然保留，供下一次使用。 静态局部变量生命周期：一个工程中从第一次被创建开始，一直到最后一次被调用为止，且每次调用函数时的静态变量不再初始化。 小结：static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。 代码3： 123456789101112131415161718#include&lt;stdio.h&gt;//代码3void test(){ //这里将i用static修饰 static int i = 1; i++; printf(&quot;%d &quot;, i);}int main(){ int i = 0; for (i = 0; i &lt; 10; i++) { test(); } return 0;} 有意思的是，通过调试我们可以看到： 在程序还没执行到test函数时，只要进入了该函数的函数体，static修饰的 i 就已经为1了，就像是一进来这个块，i 就已经被创建了，而不是等到 程序走到 static int i = 1时才被创建，事实上可以认为赋值语句从来没有执行过。（如果静态变量没有初始化语句，则默认为0.） 小结：static修饰局部变量，一直存在于块内，不随着出作用域而消失，与全局变量有些相似之处 static修饰全局变量作用：改变了全局变量的作用域，让静态的全局变量只能在自己的源文件内使用，而无法在本源文件外部使用。全局变量作用域是整个工程，被static修饰后作用域就只是此源文件内部了。 上图是==global.c==源文件创建的全局变量。 工程中另一个==test.c==源文件代码： 12345678//test.c#include&lt;stdio.h&gt;extern n;int main(){ printf(&quot;%d&quot;, n); return 0;} 运行结果： 可见全局变量n已经无法使用。 static修饰外部函数 作用：改变了函数的外部链接属性。普通函数具有外部链接属性，而静态函数没有外部连接属性。也就是static修饰的函数也只能在所在的源文件内部使用。 add.c 1234int Add(int x, int y){ return x + y;} 以上为static修饰的外部函数。 代码： main.c 12345678910#include&lt;stdio.h&gt;int Add(int x, int y);int main(){ int x = 3; int y = 5; int sum = Add(x, y); printf(&quot; %d&quot;, sum); return 0;} 运行结果： 可以看到这里是已经报错了。 最后对static的三条作用做一句话总结：首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 💦#define定义常量和宏123456789101112#include&lt;stdio.h&gt;//#define定义标识符常量#define MAX 100//#define定义宏# define BIG(x,y) (x&gt;y?x:y)int main(){ int max = BIG(2, 3); printf(&quot; %d &quot;, MAX); printf(&quot; %d &quot;, max); return 0;} 宏本质是使用标识符和参数进行替换。 注意：这里与函数的使用方式比较类似，注意区分。 💦指针内存 内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的 。 为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。 为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。 如图： 变量是储存在内存中的（在内存中分配空间)，每个内存单元都有地址，所以变量也有地址。取出变量地址如下： 12345678int main(){ //创建变量 int i = 1; //&amp;是取地址操作符，&amp;i就是i的地址 printf(&quot;%p&quot;, &amp;i);//%p是以地址的方式打印 return 0;} 运行结果： 注意：地址是以16进制输出的，这里的 i 占四个字节，每个字节都有地址，取出的第一个字节的地址(较小的地址)。 指针变量顾名思义：指针就是指向某一块内存空间的。 那么有了地址，地址如何储存，需要定义指针变量。 代码： 1234567int main(){ int num = 10; int* p;//p为一个整型变量的指针 p = &amp;num;//赋值 return 0;} 通过指针间接访问变量 实例： 12345678910#include&lt;stdio.h&gt;int main(){ int num = 10; int* p = &amp;num;//通过*p找到num的空间 *p = 20; printf(&quot; num=%d &quot;, num); printf(&quot;*p=%d&quot;, *p); return 0;} 运行结果： p和num在内存中的分布： 以整型为例子，拓展在其他类型. 代码： 12345678910#include&lt;stdio.h&gt;int main(){ char ch = 'a'; char* pc = &amp;ch; *pc = 'h'; printf(&quot;ch= %c &quot;, ch); printf(&quot;*pc= %c &quot;, *pc); return 0;} 运行结果： 小结：指针指向什么类型的变量，就定义什么类型的指针去接受该变量的地址。 指针变量的大小 123456789101112#include&lt;stdio.h&gt; //指针变量的大小取决于地址的大小 //32为平台上地址的大小是32bit //64位平台上地址的大小是64bitint main(){ printf(&quot; int*大小=%d\\n&quot;, sizeof(int*)); printf(&quot; char*大小=%d\\n&quot;, sizeof(char*)); printf(&quot; double*大小=%d\\n&quot;, sizeof(double*)); printf(&quot; short*大小=%d\\n&quot;, sizeof(short*)); return 0;} 牢记：指针的大小和类型无关，只与平台有关。 小结：在32位平台上是4个byte，在64位平台上是8个byte。 数组名：指针常量指针常量 指针是形容词，常量是名词。这回是以常量为中心的一个偏正结构短语。那么，指针常量的本质是一个常量，而用指针修饰它，那么说明这个常量的值应该是一个指针，意为：指针中的常量。 通常这样声明： int* const p ; 因为const修饰的是指针p，即指针常量，在声明的时候一定要给它赋初始值。一旦赋值，以后这个常量再也不能指向别的地址。 数组名与指针常量类似 虽然指针常量的值也就是指向不能变，可是它指向的对象是可变的，因为我们并没有限制它指向的对象是常量。 下面的操作是可以的。 例： a[0] = ‘x’; // 我们并没有限制a为常量指针（指向常量的指针） 或者 c[0] = ‘x’ // 与上面的操作一致 注意：指针常量和常量指针是不同概念。 常量指针 常量是形容词，指针是名词，以指针为中心的一个偏正结构短语。这样看，常量指针本质是指针，常量修饰它，表示这个指针乃是一个指向常量的指针（变量）。简而言之：一个常量的指针。 常量指针的声明： 12int const* p;const int* p; 这两种方式效果相同。 常量指针变量该变量的指向是可变的，但是无法通过指针改变指向的内容； 123456789#include &lt;stdio.h&gt;int main(){ const int* p = NULL; int num = 0; p = &amp;num; //p的值是可以改变的 *p = 20; //无法修改*p的值，即num的值 return 0;} 上面的代码是无法通过的； 💦结构体结构体是C语言中特别重要的知识点，结构体使得C语言有能力描述复杂类型。 比如描述学生，学生包含： 名字+年龄+性别+学号 这几项信息,只用一个变量来描述显然不行。 这里只能使用结构体来描述了 例如： 12345678910111213141516171819#include&lt;stdio.h&gt;//创建结构体类型struct student{ char name[20];//名字 int age;//年龄 char sex[10];//性别 char id[10];//学号};int main(){ struct student a = { &quot;张三&quot;,20,&quot;男&quot;,&quot;2020088&quot; };//初始化结构体变量 struct student* pa = &amp;a;//将变量a的地址给结构体指针变量 //使用.操作符访问结构成员，//打印结构体信息 printf(&quot; %s %d %s %s\\n&quot;, a.name, a.age, a.sex, a.id); //-&gt;操作符，//打印结构体信息 printf(&quot; %s %d %s %s\\n&quot;, pa-&gt;name, pa-&gt;age, pa-&gt;sex, pa-&gt;id); return 0;} 运行结果： 总结：结构体是用来描述一个复杂变量的。","link":"/2023/01/12/C/4.%E3%80%90%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80%E3%80%91%EF%BC%88%E4%B8%8B%EF%BC%89/"},{"title":"C语言分支与循环","text":"💦什么是语句C语句可分为以下五类： 表达式语句 函数调用语句 控制语句 复合语句 空语句 这里介绍的是控制语句。 控制语句用于控制程序的执行流程，以实现特定的功能和结构，它们具有特定的语句定义符组成，C语言有九种控制语句。 分为三类： 分支语句：if、switch语句； 循环语句：while、for、do while语句； 转向语句：break、continue、goto、return语句； 💦分支语句(选择结构)if语句 面对选择，我们会直接想或者说：我要XXX，我不要XXX。 举个例子： 面临以下选择 好好学习—&gt;收获满满 无所事事—&gt;继续废柴 可以看到二者是不可兼得的，只能选择其中的一个。 那么对于计算机呢？ if的语法结构： 123456789101112//一般结构if(表达式) 语句1;if(表达式) 语句2;//多分支结构if(表达式1) 语句1;else if(表达式2) 语句2;else 语句3; 注意:表达式的内容只看真假，可以是一个常数，可以是一个变量。 如下图： 由图可知： 若表达式结果为真，则对应语句执行。 那么C语言中如何表示真假？ C语言中 0为假，非0为真。 如果要执行的语句不止一条，那我们还需要将要执行的语句用大括号{}括起来。 例： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;//代码1int main(){ int age = 0; scanf(&quot;%d&quot;, &amp;age); if (age &lt; 18) { printf(&quot;未成年\\n&quot;); } else if (age &gt; 18 &amp;&amp; age &lt; 60) { printf(&quot;壮年\\n&quot;); } else if (age &gt; 60) { printf(&quot;老年\\n&quot;); } return 0;}代码2int main(){ double grade_point = 0;//初始化绩点 scanf(&quot;%lf&quot;, &amp;grade_point); if (grade_point &gt;= 4.0 &amp;&amp; grade_point &lt; 5.0) { printf(&quot;优秀\\n&quot;); } else if (grade_point &lt; 4.0 &amp;&amp; grade_point &gt;= 3.0) { printf(&quot;一般\\n&quot;); } else printf(&quot;差\\n&quot;); return 0;} 一个if与一个else匹配，如果有多个if或者else语句呢？ 12345678910111213int main(){ int a = 1; int b = 2; if (a == 5) if (b == 2) printf(&quot;true&quot;); else printf(&quot;false&quot;); else printf(&quot;NULL&quot;); return 0;} 输出结果： 所以可以断定else是与第二个if匹配的。 可以看到上面代码的写法，很容易让我们产生误解，所以代码风格非常重要。 我们可以改写成以下形式： 1234567891011121314151617int main(){ int a = 1; int b = 2; if (a == 5) { if (b == 2) printf(&quot;true&quot;); else printf(&quot;false&quot;); } else { printf(&quot;false&quot;); } return 0;} 结论：else必须紧挨if后要执行的语句，且总是与最近且未匹配else的if匹配。 if语句的书写形式 1234567//代码1//函数体if (1){ return 1;}return 2; 返回值结果： ​ 1 上述代码给人模棱两可的感觉，表达不清晰，很容易产生误解。 我们来换一种写法 123456789//代码2 if (1) { return 1; } else { return 2; } 返回值结果： 1 显然，代码2的逻辑更加清晰，可读性更高。 结论：代码风格很重要，可读性和逻辑要好。 练习： 判断一个数是奇书还是偶数。 奇数：不可以被2整除的数。 偶数：可以被2整除的数。 能否被2整除就是我们的突破口，可以用此条件进行区分。 代码： 1234567891011121314int main(){ int i = 0; scanf(&quot;%d&quot;, &amp;i); if (i % 2 == 0) { printf(&quot;%d是偶数\\n&quot;, i); } else { printf(&quot;%d是奇数\\n&quot;, i); } return 0;} 输入：3 输出：3是奇数 输入：4 输出：4是偶数 分支语句（branch），如同河流的不同支流，分支少还好，但是当分支很多的情况呢？ 我们再一个一个去写就太繁琐，于是switch语句的作用就体现出来了。 switch语句 通常是多分支的，有多种情况可以选择。 例如：我们想输出今天周几。 输入1，输出周一 输入2，输出周二 输入3，输出周三 输入4，输出周四 输入5，输出周五 输入6，输出周六 输入7，输出周天 if语句实现： 12345678910111213141516171819202122int main(){ int day = 0; scanf(&quot;%d&quot;, &amp;day); if (day == 1) printf(&quot;周一&quot;); else if (day == 2) printf(&quot;周二&quot;); else if (day == 3) printf(&quot;周三&quot;); else if (day == 4) printf(&quot;周四&quot;); else if (day == 5) printf(&quot;周五&quot;); else if (day == 6) printf(&quot;周六&quot;); else if (day == 7) printf(&quot;周七&quot;); else printf(&quot;输入错误&quot;); return 0;} 我们用if else语句实现看起来实在拖拉，且形式复杂。 使用switch语句呢？ 1234567891011121314151617181920212223int main(){ int day = 0; scanf(&quot;%d&quot;, &amp;day); switch (day) { case 1: printf(&quot;周一&quot;); case 2: printf(&quot;周二&quot;); case 3: printf(&quot;周三&quot;); case 4: printf(&quot;周四&quot;); case 5: printf(&quot;周五&quot;); case 6: printf(&quot;周六&quot;); case 7: printf(&quot;周天&quot;); } return 0;} 输入：5 输出：周五周六周天 与我们想要的似乎不太一样，我只想打印初周五，但是周六周天也打印出来了，可以看到，在执行完case 5后并没有跳出switch语句，而是继续执行接下来的语句，这显然不是分支。 如果我们想要执行完一个分支后立马跳出switch语句该怎么办？ 在switch语句中的break 在switch语句中，我们没办法直接实现分支，必须依赖break与switch语句想结合，才能实现真正的分支。 123456789101112131415161718192021222324252627282930int main(){ int day = 0; scanf(&quot;%d&quot;, &amp;day); switch (day) { case 1: printf(&quot;周一&quot;); break; case 2: printf(&quot;周二&quot;); break; case 3: printf(&quot;周三&quot;); break; case 4: printf(&quot;周四&quot;); break; case 5: printf(&quot;周五&quot;); break; case 6: printf(&quot;周六&quot;); break; case 7: printf(&quot;周天&quot;); break; } return 0;} break语句的实际效果是把语句列表分成不同的分支，所有的分支都是并列的。 假如我们的需求变化，在输入1~5是输出工作日，在输入6和7后输出休息日。 思考：这还是分支吗？ 12345678910111213141516171819202122232425262728293031//代码1int main(){ int day = 0; scanf(&quot;%d&quot;, &amp;day); switch (day) { case 1: printf(&quot;工作日&quot;); break; case 2: printf(&quot;工作日&quot;); break; case 3: printf(&quot;工作日&quot;); break; case 4: printf(&quot;工作日&quot;); break; case 5: printf(&quot;工作日&quot;); break; case 6: printf(&quot;休息日&quot;); break; case 7: printf(&quot;休息日&quot;); break; } return 0;} 这样未免太麻烦了。 既然语句流会贯穿每一个case标签，那我们可以这样。 1234567891011121314151617181920int main(){ int day = 0; scanf(&quot;%d&quot;, &amp;day); switch (day) { case 1: case 2: case 3: case 4: case 5: printf(&quot;工作日&quot;); break; case 6: case 7: printf(&quot;休息日&quot;); break; } return 0;} 可以看到这仍然是分支，不过每一个分支的范围似乎不止是一个case，而是多个case组成的一个分支。 而将语句列表划分为每个分支的标志就是break。 switch语句一般形式： 1234567switch(type){ case 1: case 2: case 3: default://默认实行语句} 需要注意的几点： type只能为整数； type为多少，就跳入case type分支，按照顺序执行； case只决定从哪里进，不决定从哪里出； case后面必须是整型常量； 如果所有case都不能进入，则默认执行default，每个switch语句只能出现一个default子句； default：可以出现在switch语句中的任何位置，而且语句流会像贯穿case标签一样贯穿default子句，若想让default子句成为一个新的分支，则也需要加break。 编程好习惯： 最后一个case加上break 每个switch语句都放入一个default。 注意：break只能在switch语句和循环语句中使用，且一个break只能跳出当前的循环或者switch语句。 switch语句的嵌套 例： 123456789101112131415161718192021222324int main(){ int m = 1; int n = 2; switch (n)//case 2 { case 1: m++; case 2: n++; case 3: switch (m) { case 1: m++; case 2: n++; } default: printf(&quot;结束\\n&quot;); } printf(&quot;m=%d n=%d &quot;, m, n); return 0;} 输出：结束 ​ m=4 n=2 总结：分支语句就是将语句列表划分不同的分支，分支的大小是任意的，分支的内容也是任意的可以是一个语句，也可以是多条语句。 💦循环语句生活中我们有每天重复循环的事情，C语言中也同样存在，当我们想重复做一件事情，那该怎么处理？ C语言当然可以实现： while for do while while循环 我们已经了解了if语句： 1234if(condition){ 语句;} 当condition为真时，if后面的语句被执行，反之则不执行。 但是if后的语句只会被执行一次，假如我们想要他执行多次，那我怎么做呢？C语言给我们提供了while循环做到这件事。 12345//while语法while(condition){ 循环语句;} while循环流程图： 如何在屏幕上打印出1~10的数字？ 难道要十个printf来输出吗？显然，我们拥有while后不再需要如此麻烦。 代码： 12345678910int main(){ int i = 1; while (i &lt;= 10) { printf(&quot;%d\\n&quot;, i); i++; } return 0;} 可以看到我们只用了一个printf，但是利用while循环做到了与十个printf的效果。 简单了解while工作流程我们接着看： while中的break和continue break介绍： 1234567891011121314#include&lt;stdio.h&gt;int main(){ int i = 0; while (i &lt; 10) { if (i == 5) break; printf(&quot;%d &quot;, i); i++; } return 0;} 运行结果： 0 1 2 3 4 可以看到在i == 5时遇到了break循环就停止了。 结论：break可以永久终止当前循环。 continue介绍： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//代码1：int main(){ int i = 0; while (i &lt; 10) { if (i == 5) continue; printf(&quot;%d&quot;, i); i++; } return 0;}//代码2：int main(){ int i = 0; while (i &lt; 10) { i++; if (i == 5) continue; printf(&quot;%d &quot;, i); } return 0;} 代码1： 死循环 代码2： 输出： 1 2 3 4 6 7 8 9 看起来continue似乎不像break那么暴力直接终止循环了，但是代码2的结果却少了一个5，代码一进入了死循环。 continue的作用：终止本次循环，直接跳到下一次的循环判断位置。 总结：break永久终止循环。continue终止本次循环，进入下一次循环判断位置。 getchar函数 作用：在输入缓冲区读取一个字符、 int getchar ( void );//函数原型 putchar函数 作用：输出一个字符。 int putchar ( int character );//函数原型 输入缓冲区是什么呢？ 可以理解为一块区域用来存储我们键盘输入的数据的这么一块区域。在输入操作时，如果缓冲区有内容就直接被scanf或者getchar读走，如果缓冲区没有内容，则等待用户输入。 示例： 1234567891011#include&lt;stdio.h&gt;int main(){ int ch = 1; scanf(&quot;%d&quot;, &amp;ch); while ((ch = getchar())!=EOF)//将getchar得到的字符赋值给ch，判断是否与EOF相等 { putchar(ch); } return 0;} 输入：abc 输出：abc 利用getchar清理输入缓冲区 12345678int main(){ char arr[10] = { 0 }; scanf(&quot;%s&quot;, arr); int ch = getchar(); printf(&quot;%d&quot;, ch); return 0;} 输入： abcd 输出：10 输入：zxcv 输出：10 无论输入什么输出都是10. 这是为什么呢？明明没有输入10，却每次都会在屏幕上输出一个10。 查阅ASCII码可以看到 10所对应的是换行符，也就是说getchar读到的是我们输入结束时敲入的回车。 于是我们面对这类问题时，可以利用getchar清理输入缓冲区。 123456789int main(){ int ch = 0; while ((ch = getchar()) != '\\n')//读取到\\n时就不再读取 { ; } return 0;} 如果我们想只读取输入的某一类数据，该如何处理呢？ 12345678910111213#include&lt;stdio.h&gt;int main(){ int ch = 0; while ((ch = getchar()) != EOF) { //只打印26个字母字符 if (ch &gt; 'a' &amp;&amp; ch &lt; 'z') putchar(ch); } return 0;} 总结：利用循环我们可以节省很多时间，处理一些步骤相同的问题时，循环可以迅速解决这类问题。 for循环 既然已经有了while循环，为什么还会有for循环呢？ 我们先看一看for循环的结构： 1234for(exp1;exp2;exp3){ 循环语句;} exp1为初始化部分，用于初始化循环变量。 exp2为条件判断部分，用于判断循环执行条件。 exp3为调整部分，用于调整循环变量。 打印出0~9的数字 我们使用while和for两种循环分别实现。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(){ //代码1 while int i = 0; //初始化部分 while (i &lt; 10)//判断部分 { printf(&quot;%d &quot;, i); i++; //调整部分 } return 0;}//代码2 forint main(){ int i = 0; for (i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, i); } return 0;} 可以看到代码1的初始化部分、条件判断部分和调整部分在for循环中都可以集成到一起，看起来更加简洁，使用起来更加方便。 for循环流程图： break和continue在for循环中 作用与while基本相同，但有一些微小差异 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//break //代码1int main(){ int i = 0; for (i = 0; i &lt; 10; i++) { if (i == 5) break; printf(&quot;%d &quot;, i); } return 0;}//continue//代码2int main(){ int i = 0; for (i = 0; i &lt; 10; i++) { if (i == 5) continue; printf(&quot;%d &quot;, i); } return 0;} 代码1： 输出：0 1 2 3 4 代码2： 输出：0 1 2 3 4 6 7 8 9 与while中使用continue后死循环不同，这里在i==5时，continue被执行，直接跳入循环判断部分，并且i++，再次进入循环后 i !=5，于是程序正常进行下去。 结论：continue跳过的是循环体部分而不包括条件判断部分。 for的循环控制变量 建议： 不要再循环体内部改变循环变量，防止循环失去控制 建议循环控制变量的取值采用左闭右开区间 1234567891011#include&lt;stdio.h&gt;int main(){ int i = 0; for (i = 0; i &lt; 10; i++)//左闭右开更清爽 { i = 1; printf(&quot;%d &quot;, i); } return 0;}//最终程序死循环了 for循环的变种 123456789101112131415#include&lt;stdio.h&gt;//变种1//省略了初始化部分//条件判断部分//调整部分int main(){ int i = 0; for (;;)//没有判断条件默认恒为真 { printf(&quot;hehe\\n&quot;); } return 0;} 运行结果： 重复的打印hehe 1234567891011121314151617//变种1int main(){ int count = 0; int i = 0; int j = 0; for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10; j++) { printf(&quot;hehe\\n&quot;); count++; } } printf(&quot;%d&quot;, count); return 0;} 运行结果： 打印出了100个hehe 1234567891011121314151617181920//变种2#include&lt;stdio.h&gt;int main(){ int count = 0; int i = 0; int j = 0; for (; i &lt; 10; i++)//未初始化变量 { for (; j &lt; 10; j++)//未初始化变量 { printf(&quot;hehe\\n&quot;); count++; } } printf(&quot;%d&quot;, count); return 0;} 运行结果： 打印出了10个hehe 可以看到虽然只是小小的改变，但引起的效果却截然不同，所以省略for循环中的表达式要慎用！ 使用多个变量控制循环 123456789101112#include&lt;stdio.h&gt;int main(){ int x = 0; int y = 0; for (x = 0, y = 0; x &lt; 10 &amp;&amp; y &lt; 5; x++, y++) { printf(&quot;haha\\n&quot;); } return 0;} 运行结果： 打印出5个haha 练习 循环了多少次？ 1234567891011#include&lt;stdio.h&gt;int main(){ int i = 0; int j = 1; for (i = 0, j = 1; j = 2; j++) printf(&quot;haha\\n&quot;); return 0;} 答案：死循环 你做对了吗？ do while()循环 do while语句的用法 1234do{ 循环体语句;}while(condition) 执行流程： do while语句的特点 无论是否满地条件判断，循环体至少会被执行一次。 123456789int main(){ int i = 10; do { printf(&quot;%d &quot;, i); } while (i &lt; 10);//不满足循环条件 return 0;} 运行结果： 10 do while循环中的break和continue 1234567891011121314#include&lt;stdio.h&gt;//breakint main(){ int i = 0; do { if (i == 5) break; printf(&quot;%d &quot;, i); i++; } while (i &lt; 10); return 0;} 输出结果： 0 1 2 3 4 1234567891011121314#include&lt;stdio.h&gt;int main(){ int i = 0; do { if (i == 5) continue; printf(&quot;%d &quot;, i); i++; } while (i &lt; 10); return 0;} 运行结果： 死循环 可以看到do while中的break和continue的作用与while循环的基本一致。 练习 在有序数组中查找一个数 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//二分法int main(){ int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int left = 0;//要查找的范围内的左下标 int right = sizeof(arr) / sizeof(arr[0]) - 1;//要查找范围内的右下标 int k = 0;//要查找的数 scanf(&quot;%d&quot;, &amp;k); while (left &lt;= right) { int mid = (left + right) / 2;//中间下标 if (arr[mid] &lt; k)//判断在哪个区间 { left = mid + 1; } else if (arr[mid] &gt; k)//判断在哪个区间 { right = mid - 1; } else { printf(&quot;found it！下标为%d&quot;, mid); break; } } return 0;} 运行结果： 拥有了循环和判断，我们还可以实现一个猜数小游戏： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void menu()//菜单{ printf(&quot;***************************\\n&quot;); printf(&quot;*******1.play 2.exit*******\\n&quot;); printf(&quot;***************************\\n&quot;);}//游戏进行void game(){ int guess = 0; int i = (rand() % 100) + 1; //生成随机数1~100 //printf(&quot;%d\\n&quot;, i);测试 while (1) { printf(&quot;猜数：\\n&quot;); scanf(&quot;%d&quot;, &amp;guess); if (i &lt; guess) { printf(&quot;猜大了\\n&quot;); } else if (i &gt; guess) { printf(&quot;猜小了\\n&quot;); } else { printf(&quot;猜对了！\\n&quot;); break; } }}int main(){ srand((unsigned int)time(NULL));//设置种子值为一个变量 int input = 0; do { menu(); printf(&quot;请输入：-&gt;(1/0)&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) { case 1: game(); break; case 0: printf(&quot;退出游戏\\n&quot;); break; default: printf(&quot;请重新输入：-&gt;(1/0)\\n&quot;); break; } } while (input); return 0;} 运行： 💦goto语句C语言中提供了可以随意跳转的 goto语句和标记跳转的标号。 从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。 但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过程。 流程图： 例如：一次跳出两层或多层循环。 多层循环这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层的循环。 goto语言真正适合的场景下： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;//跳出多重循环int main(){ int i = 0; int j = 0; int k = 0; for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10; j++) { for (k = 0; k &lt; 10; k++) { ... 循环语句; goto out; ... } } } out： 语句; return 0;} goto代替循环 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ char input[10] = { 0 }; system(&quot;shutdown -s -t 60&quot;); again: printf(&quot;电脑将在1分钟内关机，如果输入：“不要关机”则取消关机\\n 请输入:&gt;&quot;); scanf(&quot;%s&quot;, input); if (0 == strcmp(input, &quot;不要关机&quot;)) { system(&quot;shutdown -a&quot;); break; } else { goto again;//跳转到again } return 0;} 总结： 在明确知道循环的次数时使用for循环 在循环体无论如何都至少会被执行一次时使用do while循环 其他情况使用while循环 goto语句尽量不使用","link":"/2023/01/12/C/5.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"title":"C语言数组","text":"一维数组的创建和初始化数组的创建数组是一组相同类型元素的集合。 数组的创建方式： 123type_t arr_name[const_n];//type_t 是指数组的元素类型//const_n 是一个常量表达式，用来指定数组的大小 数组创建的实例: 123456789//代码1int arr1[10];//代码2int count = 10;int arr2[count];//数组时候可以正常创建？//代码3char arr3[10];float arr4[1];double arr5[20]; 注：数组创建，在C99标准之前， [] 中要给一个常量才可以，不能使用变量。在C99标准支持了变长数组的概念。 数组的初始化数组的初始化是指，在创建数组的同时给数组的内容一些合理初始值（初始化）。 看代码： 123456int arr1[10] = {1,2,3};int arr2[] = {1,2,3,4};int arr3[5] = {1，2，3，4，5}；char arr4[3] = {'a',98, 'c'};char arr5[] = {'a','b','c'};char arr6[] = &quot;abcdef&quot;; 初始化值一般用大括号括起来并且用逗号隔开，并且初始化给定数组具体的初始化值，编译器会自动计算数组大小，并不需要手动指定数组的大小。 但是对于char类型的数组，稍微有些不同. 12char arr1[] = &quot;abc&quot;;char arr2[3] = {'a','b','c'}; 第一种方式：char[]类型可以直接使用字符串初始化，会自动拷贝字符串的每个字符放入到数组中并且会加上末尾隐藏的’\\0’。 第二种则是常规情况下数组的初始化方式。 一维数组的使用对于数组的使用我们之前介绍了一个操作符： [] ，下标引用操作符。它其实就数组访问的操作符。 我们来看代码： 123456789101112131415161718int main(){ int arr[10] = {0};//数组的不完全初始化 //计算数组的元素个数 int sz = sizeof(arr)/sizeof(arr[0]); //对数组内容赋值,数组是使用下标来访问的，下标从0开始。所以： int i = 0;//做下标 for(i=0; i&lt;10; i++)//这里写10，好不好？ { arr[i] = i; } //输出数组的内容 for(i=0; i&lt;10; ++i) { printf(&quot;%d &quot;, arr[i]); } return 0;} 总结: 数组是使用下标来访问的，下标是从0开始。 数组的大小可以通过计算得到。 一般情况下遍历数组我们使用左闭右开区间。 计算数组元素个数 12int arr[19];int size = sizeof(arr) / sizeof(arr[0]); 一维数组在内存中的存储接下来我们探讨数组在内存中的存储。 1234567891011int main(){ int arr[10] = { 0 }; int i = 0; int sz = sizeof(arr) / sizeof(arr[0]); for (i = 0; i &lt; sz; ++i) { printf(&quot;&amp;arr[%d] = %p\\n&quot;, i, &amp;arr[i]); } return 0;} 仔细观察输出的结果，我们知道，随着数组下标的增长，元素的地址，也在有规律的递增。 由此可以得出结论：数组在内存中是连续存放的。 注意：下标是从0开始。 二维数组的创建和初始化二维数组的创建1234//数组创建int arr[3][4];char arr[3][5];double arr[2][4]; 元素类型 + 行数 + 列数 二维数组的初始化1234//数组初始化int arr[3][4] = {1,2,3,4};int arr[3][4] = {{1,2},{4,5}};int arr[][4] = {{2,3},{4,5}};//二维数组如果有初始化，行可以省略，列不能省略 可以直接按照一维数组的方式去初始化，因为我们指定了列数，则每一行都多少个元素，第一行元素放满后会自动往第二行放元素，当前行不足的补0. 把每一行看作一个一维数组，可以分别指定每一行的元素数据，每一行的元素使用大括号括起来，每一行不足的补0. 可以不指定行数，但一定要指定列数，仅仅知道行数无法推断出二维数组的列数，但是通过二维数组的列数和元素个数可以推导出元素的行数。 行可以省略，列不能！ 二维数组的使用二维数组的使用也是通过下标的方式。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(){ int arr[3][4] = { 0 }; int i = 0; for (i = 0; i &lt; 3; i++) { int j = 0; for (j = 0; j &lt; 4; j++) { arr[i][j] = i * 4 + j; } } for (i = 0; i &lt; 3; i++) { int j = 0; for (j = 0; j &lt; 4; j++) { printf(&quot;%d &quot;, arr[i][j]); } } return 0;} 二维数组在内存中的存储一维数组在内存中是线性存储的那么二维呢？ 这里我们尝试打印出每个元素的地址。 123456789101112131415#include &lt;stdio.h&gt;int main(){ int arr[3][4]; int i = 0; for(i=0; i&lt;3; i++) { int j = 0; for(j=0; j&lt;4; j++) { printf(&quot;&amp;arr[%d][%d] = %p\\n&quot;, i, j,&amp;arr[i][j]); } } return 0;} 输出： 可以看到每个元素的地址都是相差4个字节，即一个整形的大小，很显然虽说逻辑结构叫二维数组，但是其的物理结构仍然是线性的。 因此我们可以使用另一个方式遍历二维数组 12345678910int main(){ int arr[3][4] = {0}; int* p = &amp;arr[0][0]; for(int i = 0; i &lt; 3 * 4; i++) { printf(&quot;%d &quot;, p[i]); } return 0;} 数组越界顾名思义，超出这个数组权限范围就叫数组越界。 数组的下规定是从0开始的，如果数组有n个元素，最后一个元素的下标就是n-1。所以数组的下标如果小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问。 C语言本身是不做数组下标的越界检查，编译器也不一定报错，但是编译器不报错，并不意味着程序就是正确的，通常对于数组的越界访问，编译器是抽查，像下标为 -1 ， n ， n + 1，这样的位置才会被编译器检测到，所以一定要做好自己数组越界的检查。 一维数组的越界： 1234567891011#include &lt;stdio.h&gt;int main(){ int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int i = 0; for (i = 0; i &lt;= 10; i++)//等于10时实际访问的是第11个元素，即越界了。 { printf(&quot;%d\\n&quot;, *(arr + i)); } return 0;} 当然，与一维数组一样，二维数组也存在越界问题，注意行和列的个数和下标关系。 数组作为函数参数写代码的时候我们常常需要对一个数组进行操作，会对函数进行数组的传参，那是如何进行的？ 例如：我们将一个数组排序。 123456789101112131415161718192021222324252627282930313233//错误例子void bubble_sort(int arr[]){ int sz = sizeof(arr) / sizeof(arr[0]); int i = 0; for (i = 0; i &lt; sz - 1; ++i) { int flag = 0; int j = 0; for (j = 0; j &lt; sz - 1 - i; ++j) { if (arr[j] &gt; arr[j + 1]) { flag = 1; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } if (flag == 0) //说明每一个元素都是前一个小于后一个，直接退出。 break; }}int main(){ int arr[10] = { 9,4,6,2,6,1,3,7,8 ,11 }; bubble_sort(arr,10); for (int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} 这样显然不能排序，因为形参虽然写的是数组的形式，但是本质上是一个int的指针，通过sizeof（arr）/ sizeof（arr[0]）方法计算元素个数是行不通的。 数组名是什么123456789int main(){ int arr[10] = {1,2，3,4,5}; printf(&quot;%p\\n&quot;, arr); printf(&quot;%p\\n&quot;, &amp;arr[0]); printf(&quot;%d\\n&quot;, *arr); //输出结果 return 0;} 上面三个值中arr 和 &amp;arr[0]的值是相同的，并且*arr的值与arr[0]相同。 结论：数组名是首元素地址。 如果数组名是首元素地址，那么： 12int arr[10] = {0};printf(&quot;%d\\n&quot;, sizeof(arr)); 为什么输出的结果是：40？ 补充特别说明： sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组。 &amp;数组名，取出的是数组的地址。&amp;数组名，数组名表示整个数组。 除此1,2两种情况之外，所有的数组名都表示数组首元素的地址。 当数组传参的时候，实际上只是把数组的首元素的地址传递过去了。 所以即使在函数形式参数部分写成数组的形式： int arr[] 表示的依然是一个指针： int *arr 。 那么，函数内部的 sizeof(arr) 结果是4。 知道错误的原因了，进行一下小小修改，就可以成功排序了 1234567891011121314151617181920212223242526272829303132void bubble_sort(int arr[], int sz){ int i = 0; for (i = 0; i &lt; sz - 1; ++i) { int flag = 0; int j = 0; for (j = 0; j &lt; sz - 1 - i; ++j) { if (arr[j] &gt; arr[j + 1]) { flag = 1; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } if (flag == 0) break; }}int main(){ int arr[10] = { 9,4,6,2,6,1,3,7,8 ,11 }; bubble_sort(arr,10); for (int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, arr[i]); } return 0;} 输出： 二维数组和一维数组的关系二维数组中，例如： 123456int main(){ int arr[][3] = { {1},{3},{5,6},{2,3} }; printf(&quot;%p %p %p&quot;, arr, arr[0], arr[0][0]); return 0;} 假如我们想访问第一行第一列的元素我们通常会使用arr[0] [0]去访问。 而我们访问一维数组的第一个元素通常也是 arr1[0] 都是通过下标去访问元素，如果我们将黄标的部分去掉，则剩下的就是数组名，那么也就可以认为arr[0]和arr1一样都是一个数组的名字，然后通过下标访问实现访问元素。 因此，arr[0]可以看作二维数组的第一行数组名。 输出： 可以看到三者的值是一样的 分析如下： arr是二维数组的首元素地址，而arr的每个元素都是一个数组，那么首元素的地址就是第一行数组的地址。 第一行数组的地址应该是第一行的首地址，其值等于第一个元素的地址。 arr[0]是第一行数组。 数组名是首元素地址，即第一个元素的地址。 &amp;arr[0] [0]是二维数组中第一个元素的地址。 第一个元素的地址。 当然，1 和 2.3 只是数值上的相同，其意义是不一样的，一个是指向整个数组，另一个指向一个整形。 那么arr既然是一维数组的指针，那么它的类型是什么呢？ 通常我们定义一个指针都是： 1int* p; p为变量名，*则表示p是一个指针，剩下的就是指针指向的类型（即解引用后的类型）。 我们照猫画虎试着写一写数组的指针。 12345定义变量名p*p表示为一个指针之前已经讲过，一个元素为int的数组为int []类型而p指向的就是int []那么数组指针就是 int(*p)[]; 总结：数组注意不要越界访问，数组传参时还要传入元素个数。 补充：在数组作为函数形式参数时，若用const修饰指针变量，则只能写成指针的形式。 像const int arr[] 或者 int const arr[]这里的const修饰的都是数组元素，表示数组中元素的内容不可变。 牢记：const修饰整个数组元素。 技巧： arr[]还差一个元素类型来修饰。 arr[]的每个元素类型是 const int –》const int arr[]; const修饰指针： 12345678const int* p;//修饰*pint const* p;//修饰*pint* const p;//修饰pconst int** p;//修饰**pint const ** p;//修饰**pint *const* p;//修饰*pint ** const p;//修饰p","link":"/2023/01/12/C/7.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E6%95%B0%E7%BB%84/"},{"title":"C语言函数","text":"函数是什么C语言的基本结构单位是函数[维基百科]。系统首先调用 main函数（主函数），通过函数的嵌套调用，再调用其他函数。函数可以是系统自带的函数，也可以是用户定义的函数。C语言中，不允许函数嵌套定义。 数学中我们常见到函数的概念。但是你了解C语言中的函数吗？ 维基百科中对函数的定义：子程序 在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method, subprogram, callable unit），是一个大型程序中的某部分代码， 由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。 函数的分类 库函数 自定义函数 库函数 库函数是C语言已经提供给我们可以直接去使用的函数，例如：printf()函数、scanf()函数，编程时直接调用即可。 为什么会存在库函数呢？ 在编程的过程中我们会频繁的做一些字符串的拷贝工作（strcpy）。 在编程是我们也计算，总是会计算n的k次方这样的运算（pow）。 像上面我们描述的基础功能，它们不是业务性的代码。我们在开发的过程中每个程序员都可能用的到，为了支持可移植性和提高程序的效率，所以C语言的基础库中提供了一系列类似的库函数，方便程序员进行软件开发。 下面来看一些常用的数学函数： 平方根函数sqrt(x):如sqrt(4.0)的值为2.0。 绝对值函数fabs(x)：如fabs(-3.89)的值为3.89。 幂函数pow(x)：如pow(2,3)的值为8。 指数函数exp(x):计算e^x^ 如exp(2.3)的值为9.974182。 对数函数log(x)：计算以e为底的对数。如log(e^2^)的值为2。 简单的总结，常用的库函数有： IO函数 字符串操作函数 内存操作函数 时间函数 数学函数 其他库函数 如何学会使用库函数？ 查阅文献，利用函数文档。 c++库函数 大家可以直接访问，并且这个网站是有中文版本的。 char * strcpy ( char * destination, const char * source );//函数原型 例如上面：就可以直接看到有函数名，参数以及返回类型。 注意：但是库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件。 自定义函数 库函数可不是万能的，有一些功能需要我们自己去实现，与库函数一样，自定义函数也有函数名，参数以及返回类型，不同的是这些都需要我们自己来设计，这给了程序员们很大的发挥空间。 12345678//函数的组成return_type fun_name(para1,para2,...){ statement;//语句}//return_type：函数返回类型//fun_name：函数名//para：参数 我们来举个例子： 写一个可以交换两个变量值的函数 1234567891011121314151617181920212223242526//传递值函数#include&lt;stdio.h&gt;void swap(int x, int y){ int tmp = x; x = y; y = tmp;}//传递地址函数void swap(int* px, int* py){ int tmp = *px;//创建临时变量 *px = *py; *py = tmp;}int main(){ int x = 3;//初始化值 int y = 6; printf(&quot;交换前：x=%d y=%d\\n&quot;, x, y); swap1(x, y);//swap1交换 printf(&quot;swap1:x=%d y=%d\\n&quot;, x, y); swap2(&amp;x, &amp;y);//swap2交换 printf(&quot;swap2:x=%d y=%d\\n&quot;, x, y); return 0;} 输出结果： 交换前：x=3 y=6 swap1:x=3 y=6 swap2:x=6 y=3 可以看到swap1并没有产生我们想要的效果，为什么传值后主函数的变量x，y并没有变化呢？ 下面来介绍函数的调用过程，后面会详细说明。 函数的参数实际参数 实参是在调用函数真实传递给函数的参数，实参的类型可以是： 表达式 常量 变量 函数 无论是何种类型的参数，在调用函数传参时一定要有确定的值，这里注意是传递值，不是传递变量。 形式参数 形式参数是函数名后括号内的变量，简称形参。 形参在没有调用函数时，没有自己的内存空间，只有在函数被调用时形参才在内存中被分配空间并接受传递到函数的值。 因此叫做形式参数，在函数结束调用后自动销毁，形式参数只在函数中有效。 注意：函数的形参和实参分别拥有不同的内存空间。 函数参数为数组名 数组arr传参，实际传递的并不是数组本身，仅仅传过去数组首元素的地址。 函数参数中的数组形参实际上是指针类型，所以传值时，传的是地址。实参的类型是数组，形参是指针，有着本质上的差异。 形参可以写成数组形式，也可以写成指针类型看个人喜好，不过本质都是一样的。 数组传参要传入数组大小，因为sizeof无法通过形参确定数组大小。 12int search(int* arr, int sz);int search(int arr[], int sz); 上面两种写法都是可以的。 函数的调用传值调用 函数的形参时实参的一份临时拷贝，对形参的修改不会影响实参。 传址调用 当我们需要对我们的实参进行修改时，采用传址调用，顾名思义就是将我们想要操作的变量的地址传递给形参。 这种参数传递方式可以让函数内外的变量建立关系，而起到这样作用的，正是地址，可以间接在函数内部修改函数外部变量的值。 12345678910void add(int num){ num++;}int main(){ int num = 0; add(num); return 0;} main函数中的num并不会因为add函数中num的改变而改变。 注意：一个函数只能返回一个值。 函数的嵌套和链式访问函数和函数之间是可以相互调用的，可以在一个函数中借用另一个函数的功能。 嵌套调用 嵌套调用就是在一个函数中调用另一个函数，可以根据实际应用对函数进行组合，从而达到我们的目的。 代码： 12345678910void print(){ printf(&quot;hehe&quot;); print();}int main(){ print(); return 0;} 输出结果是满屏幕的hehe 可以嵌套使用，定义不可嵌套。 链式访问 链式访问就是将一个函数的返回值作为另一个函数的参数 123456int main(){ int num = 345; printf(&quot;%d &quot;, printf(&quot;%d &quot;,num)); return 0;} 输出：345 3 这就是函数的链式访问。 printf函数的返回值是打印在屏幕上字符的个数。 函数的声明和定义函数声明 函数声明就是告诉编译器我这里有一个函数，声明包括函数的返回类型，函数名以及参数类型，并不用写上参数的名称，当然写上也没问题。 函数一定要先声明才能使用。 函数的声明一般放在头文件里。 声明：void print(); 函数定义 函数定义就是函数的具体实现过程。 代码： 12345void print(){ printf(&quot;hehe&quot;); print();} 函数递归什么是递归 函数在自己调用自己的情况就是递归。 递归作为一种技巧性很强的算法在程序设计中应用极为广泛。通常一些大型复杂问题往往可以通过递归简化，使用递归算法，可以让原问题层层转化为一个与原问题相似的一个个小问题来解决。 可以利用递归性质，是用少量代码让计算机完成大量运算。 函数调用在栈区开辟空间，每次的函数调用都会开辟不同的内存空间，彼此独立存在。 函数递归的返回值可以有两种 递归最终返回值是副作用产物，且每次返回值无关。 递归返回值是每次调用返回值叠加的产物。 递归的必要条件 存在限制条件来结束递归。 每次递归不断接近这个限制条件。 示例代码： 求n的k次方 12345678910//实现n的k次方float power_function(float n, int k){ if (k == 0) return 1; else if (k &gt; 0) return n * power_function(n, k - 1); else return (1 / n) * power_function(n, k + 1);} 递归的主要思想就是将繁化简。 递归的缺点： 重复运算多次。 123456789101112131415int cnt = 0;//全局变量，记录递归次数int fib(n){ cnt++; if (n &lt;= 2) return 1; return fib(n - 1) + fib(n - 2);}int main(){ int n = 20; int ret = fib(n); printf(&quot;ret=%d cnt=%d&quot;, ret,cnt); return 0;} 输出：ret=6765 cnt=13529 可以看到简简单单几行代码，运算次数却如此之多。 注意： 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。 总结：函数的功能最好比较单一，最好只有一个功能，达到高内聚低耦合。","link":"/2023/01/12/C/6.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E5%87%BD%E6%95%B0/"},{"title":"C语言操作符","text":"操作符分类 算术操作符 移位操作符 位操作符 赋值操作符 单目操作符 关系操作符 逻辑操作符 条件操作符 逗号表达式 下标引用、函数调用和结构成员 算术操作符1+ - * / % % 为取余也叫模，它的操作数只能是整数，而其他的操作符的操作数既可以为整数也可以为浮点数。 操作数有浮点数时，则进行算术转换进行浮点数运算。 移位操作符12左移操作符 &lt;&lt; 右移操作符 &gt;&gt; 移位操作符对应的是在计算机种的存储形式：补码 （因此移位操作符的操作数仅仅只能是整数。） 左移操作符 对相应的二进制数进行操作。 规则：高位舍去，低位补零。 拓展 左移意味着每一个二进制位的权重会增加1 例如：整形char 假设一个char类型的数据为 6 那么它的二进制表示为 123 00000110 //6左移一位后： 00001100 //12 显然任何二进制数都可以表示为： $Σ|\\sum\\limits_{i=0}^{n}$​ k * 2^i^ (k为0或者1) 那么左移一位后，在没有高位溢出的情况下，每一位的权重都增加了1 那么做简单变形： $Σ|\\sum\\limits_{i=1}^{n+1}$ k * 2^i^ 根据分配律可得：$Σ|\\sum\\limits_{i=0}^{n}$​ (k * 2^i^ ) * 2 即乘2操作; 注意：仅仅是在无溢出的情况下 右移操作符移位规则： 算数右移 左边用符号位填充，右边舍弃。 逻辑右移 左边用0填充，右边舍弃。 一般来说我们只针对逻辑右移来讨论： 与左移不同的是，右移操作符在移位的过程中会经常低位非零而被舍弃的情况。 例如：将3右移1位 1234//逻辑右移000000113 &gt;&gt; 100000001 假设 char a = n (n为任何数) 我们准备将 a 右移 k 个位置，可以将其分解为 k 次向右移动一个位置（二进制位） 那么每次分为两种情况 最低位为1 最低位为0 最低位为1，即先舍去最低位，那么对应到二进制数则可通过 -1操作来完成，然后在移位。 最低位为0，那么则直接移位，不涉及舍弃有效数问题 通过归纳总结： 可以得到 右移操作： 如果操作数为奇数 则先 -1 ，再右移。 如果为偶数，则直接右移。 通过左移操作的推到同理可得，右移可以是 除以2的操作，即与除以2的结果取整等效。 则右移与整除相同，都是结果取整。 如果是对负数进行移位操作呢？ 在数据未溢出的情况下，结论是相同的。 左移 &lt;==&gt; 乘2 右移 &lt;==&gt; 除以2（整除） 思考：如果对-1，进行右移 n 位那么结果如何？ 12311111111111111111111111111111111 //右移1位11111111111111111111111111111111 可以看到是未变化的，通过上面得出的结论： 实际上 -1 右移可看作如下步骤： -1为奇数，因此先-1得到-2； 进行除以2的操作得到 -1 重复上述过程。 注意：对于移位运算符，移动负数位是标准为定义的。 位操作符12345 &amp; 按位与 | 按位或 ^ 按位异或 注意：操作数必须为整数 位操作符可以做很多有趣的事情。 对于位操作，我们通常只用进行某一位上对应的二进制值，来获得规律； 异或记住口诀： 相同为0， 相异为1. 可以试想两个个极端情况： 一个数二进制全为0 两个数二进制相同 其中一个数全为0的情况： 0 ^ 1 -&gt; 1 0 ^ 0 -&gt; 0 非零数的每一个二进制都没变 那么可以轻松得出异或的值还是等于另一个非零的值 两个数完全一样的情况： 0 ^ 0 -&gt; 0 1 ^ 1 -&gt; 0 无论如何，最终二进制位全为0， 即两个相同值异或会得到 0 。 利用这个特性： 思考：如何不使用第三个变量交换两个变量的值。 通常我们会写出如下代码： 123456void swap(int* num1, int* num2){ int tmp = *num1; *num1 = *num2; *num2 = tmp;} 但是这是不符合题意的，但通过位运算，我们可以做到。 123456void swap(int* n1, int* n2){ *n1 = *n1 ^ *n2; *n2 = *n1 ^ *n2; *n1 = *n1 ^ *n2;} 拿a和b来举例： 设未经过任何修改的a，b的值分别等于_a, _b的值 12345678910int main(){ int a = 10; int b = 20; a = a ^ b; //(1) b = a ^ b; //(2) a = a ^ b; //(3) printf(&quot;a = %d b = %d\\n&quot;, a, b); return 0;} 经过(1)后，a的值实际上是 _a ^ _b 经过(2)后，b的值实际上是 _a ^ _b ^ _b == _a 经过(3)后，a的值实际上是 _a ^ _b ^ _a == _b 显然目的已经达成。 思考：如何统计一个数它的二进制位的1 的个数 试想，如果有一种操作可以每次消除掉一个二进制的1，消除n次，那么这个n就为1的个数 12345678910int numof1(int k){ int cnt = 0; while (k) { k = k &amp; (k - 1);//消除二进制最后一位1 ++cnt; } return cnt;} 赋值操作符 += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^= 很简单，=不再是数学种的判断，而是赋值。 而像这样 += 的复合操作符，可以写成： 例如： a = a + b &lt;==&gt; a += b; 1234567int main(){ int a = 10; a += 20; printf(&quot;%d\\n&quot;, a); return 0;} 单目操作符12345678910! 逻辑反操作- 负值+ 正值&amp; 取地址sizeof 操作数的类型长度（以字节为单位）~ 对一个数的二进制按位取反-- 前置、后置--++ 前置、后置++* 间接访问操作符(解引用操作符)(类型) 强制类型转换 12345678int main(){ int a = 10; printf(&quot;%d&quot;, a++); a = 10; printf(&quot;%d&quot;, ++a); return 0;} 前置和后置++++a称作前置加加，a++称作后置加加。 简单记忆： 前置先++再使用，后置先使用再++。 实质上这里的前后置++在C++中是可以通过函数重载来完成的，前置++返回的是加1后的值，而后置++是返回的加一前的值的一份拷贝。 sizeofsizeof实际也是操作符，类型为size_t，可以是计算类型的大小，也可以是变量。 注意：sizeof(表达式)，表达式种的值不会真的去执行，可以看作sizeof是去推导表达式的最终类型，而不会去执行表达式的内容。 12345678int main(){ int a = 10; a += 1.1; printf(&quot;%d\\n&quot;, sizeof(a += 1)); printf(&quot;%d&quot;, a); return 0;} 思考：int a = 10; a += 1.1;最终a的值为多少？类型呢？ a += 1.1; &lt;==&gt; a = a + 1.1; a + 1.1实际上会进行算数转换，a会产生一个类型为double临时拷贝，因此计算结果是 double的11.1，但是在赋值给a时，进行隐式类型转换为int类型，得到11,赋值给a。 前置 – 和后置 – 同理。 如何验证呢？ 1234567int main(){ int a = 10; printf(&quot;字节数：%d\\n&quot;, sizeof(a += 1.1)); printf(&quot;a:%d&quot;, a); return 0;} 1234567int main(){ int a = 10; printf(&quot;字节数：%d\\n&quot;, sizeof(a + 1.1)); printf(&quot;a:%d&quot;, a); return 0;} 可以看到，这里验证了上面所说的情况。 a的值并没有变，并且 a + 1.1的结果时double类型占有8个字节。 数组 和 sizeof数组名普遍被认为是一个指针，可情况实际如此吗？ 123456int main(){ int arr[10] = { 0 }; printf(&quot;%d&quot;, sizeof(arr)); return 0;} 如果arr是个指针，那么输出应该为 4 或者 8 输出： 输出结果是40，显然不是我们预想的。 实际上，数组名是一个数组类型。 例如：int arr[10] = {0}; 那么arr的类型实际上是 int[10]; 我们通过typedef来验证一下： 1234567891011typedef struct A{ int a;}Type[10];int main(){ Type a; printf(&quot;%d&quot;, sizeof(Type)); return 0;} 输出为：40 这里的Type就是基于struct A[10]复合类型所定义出的一个新类型。 它的类型和我们struct A arr[10]创建出来的数组是同一个类型，与Type arr等效。 可以看出这里的arr实际上是Type类型，即struct A [10]类型。 所以，虽然通常情况下我们把数组名当作指针来使用，但实际上它的类型并不是指针。 目前我们经常接触到的只有两个场景是将数组名当作一个数组类型而不是指针。 sizeof(arr) &amp;arr 其他的情况我们视作其为指针是没问题的。 123456789101112void test(int arr[10]){ printf(&quot;传参后：%d\\n&quot;, sizeof(arr));}int main(){ int arr[10] = { 0 }; printf(&quot;传参前：%d\\n&quot;, sizeof(arr)); test(arr); return 0;} 怎么数组名作为实参传递至函数大小就不同了呢？ 虽然我们的形参形式写的是 int arr[10],但是其本质是int*类型，试想如果函数传参拷贝每次都传一整个数组，那太浪费资源了，因此数组名传参，实际上形参是一个指针，指向数组首元素。 这也印证了上面所说的两种情况下，数组名是数组类型外，其他时候都视作为指针。 关系操作符123456&gt;&gt;=&lt;&lt;=!= 用于测试“不相等”== 用于测试“相等” 这些关系运算符比较简单，没什么可讲的，但是我们要注意一些运算符使用时候的陷阱。 注意： 在编程的过程中== 和=不小心写错，导致的错误。 逻辑操作符12&amp;&amp; 逻辑与|| 逻辑或 牢记： &amp;&amp; 只要有一个为假，结果就为假。 ||只要有一个为真，结果就为真。 并且一旦可以推断出结果真假，就不再执行后面的逻辑表达式。（短路） 1234567891011int main(){ int a = 0, b = 2, c = 3; int i = 0; i = a++ &amp;&amp; b++ &amp;&amp; ++c; （1） printf(&quot;i==%d a==%d c==%d d==%d\\n&quot;, i, a, b, c); a = 0, b = 2, c = 3; i = a++ || b++ || ++c; （2） printf(&quot;i==%d a==%d c==%d d==%d\\n&quot;, i, a, b, c); return 0;} 两组测试c的值并不同，实际上是因为在（1）中，a++的值为假，就不在继续执行后续表达式。 而d的值相同，则是在（2）中b++的值已经为真了，因此不再继续执行后续表达式。 三目操作符1exp1 ? exp2 : exp3 例如： 123456int main(){ int a = 0; int ret = a == 0 ? 10 : 100; printf(&quot;%d&quot;, ret);} 简言之就是如果exp1为真则执行exp2，否则执行exp3. 等效于： 123456789int main(){ int a = 0; if (a == 0) ret = 10; else ret = 100; return 0;} 我们可以利用三目操作符写出简洁的取两数较大值的代码： 1int ret = a &lt; b ? b : a; 逗号表达式1exp1, exp2, exp3, …expN 1234567int main(){ int a = 1; int b = 2; int c = (a &gt; b, a = b + 10, a, b = a + 1);//逗号表达式 return 0;} c的值为13 逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。 下标引用、函数调用和结构成员 []下标引用操作符 其为双目操作符，操作数为一个整形索引值和一个数组名或指针。 123456int main(){ int arr[10] = { 0 }; arr[9]; return 0;} arr[9] == *(arr+9)== *(9 + arr) == 9[arr]; 很奇怪的写法，但确实存在。 ( ) 函数调用操作符接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。 12345678910int Add(int n1, int n2){ return n1 + n2;}int main(){ int a = 1, b = 2; Add(a, b); return 0;} 操作数为Add和n1，n2. 访问一个结构的成员. 结构体.成员名-&gt; 结构体指针-&gt;成员名 12345678910111213141516171819202122232425struct Stu{ char name[10]; int age; char sex[5]; double score;};void set_age1(struct Stu stu){ stu.age = 18;}void set_age2(struct Stu* pStu){ pStu-&gt;age = 18;//结构成员访问}int main(){ struct Stu stu; struct Stu* pStu = &amp;stu;//结构成员访问 stu.age = 20;//结构成员访问 set_age1(stu); pStu-&gt;age = 20;//结构成员访问 set_age2(pStu); return 0;} 表达式求值表达式求值的顺序一部分是由操作符的优先级和结合性决定。同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。 隐式类型转换C的整型算术运算总是至少以缺省整型类型的精度来进行的。 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。 为什么有整形提升？ 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。 12345678int main(){ char a, b = 2, c = 3; printf(&quot;%d\\n&quot;, sizeof(b + c)); a = b + c; printf(&quot;%d&quot;, sizeof(a)); return 0;} 输出： 4 1 b + c的大小为4个字节，即int的大小，而a为char。 过程：b和c的值被提升为普通整型，然后再执行加法运算，得到结果后将被截断为char存储到a。 如何进行整型提升 整形提升是按照变量的数据类型的符号位来提升的 有符号数 整型提升高位补充符号位 正数 高位补0 负数 高位补1 无符号数 ​ 高位直接补0 1234567891011121314151617//负数的整形提升char c1 = -1;变量c1的二进制位(补码)中只有8个比特位：1111111因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为1提升之后的结果是：11111111111111111111111111111111//正数的整形提升char c2 = 1;变量c2的二进制位(补码)中只有8个比特位：00000001因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为0提升之后的结果是：00000000000000000000000000000001//无符号整形提升，高位补0 例子： 12345678910111213int main(){ char a = 0xb6; short b = 0xb600; int c = 0xb6000000; if (a == 0xb6) printf(&quot;a&quot;); if (b == 0xb600) printf(&quot;b&quot;); if (c == 0xb6000000) printf(&quot;c&quot;); return 0;} 先转换为二进制位： a：1011 0110 整形提升–》1111 1111 1111 1111 1111 1111 1011 0110 b：1011 0110 0000 0000 整型提升–》1111 1111 1111 1111 1011 0110 0000 0000 c：1011 0110 0000 0000 0000 0000 0000 0000 无需整形提升。 a,b整形提升之后,变成了负数,所以表达式 a == 0xb6 , b == 0xb600 的结果是假,但是c不发生整形提升,则表达式 c==0xb6000000 的结果是真. 因此整型提升后：a != 0xb6, b != 0xb600 只要参与运算就会尝试整型提升。 判断赋值等一切操作都被当做运算。 12345678int main(){ char c = 1; printf(&quot;%u\\n&quot;, sizeof(c)); printf(&quot;%u\\n&quot;, sizeof(+c)); printf(&quot;%u\\n&quot;, sizeof(-c)); return 0;} 输出： 1 4 4 因为+c和-c也被认为是执行了运算。 c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字节. 表达式 -c 也会发生整形提升,所以 sizeof(-c) 是4个字节,但是 sizeof(c) ,就是1个字节. 算术转换如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。 1234567long doubledoublefloatunsigned long intlong intunsigned intint 一般来说按照上表从下至上进行转换（向精度更高的类型去转换） 如：1 + 1.1 则这里的1会被转换成double类型。 但是算术转换要合理，要不然会有一些潜在的问题。 12float f = 3.14;//赋值也是一种运算int num = f;//隐式转换，会有精度丢失 其实像这样的转换是不太合理但又不可避免的，通常会伴随着精度的丢失，相当于强制转换为了精度较低的类型。 1234567891011121314int main(){ size_t a = 0; int b = -1; if (b &lt; a) { printf(&quot;&lt;&quot;); } else { printf(&quot;&gt;&quot;); } return 0;} 输出： &gt; -1 &gt; 0，这显然不是这道题的解释。 注意到 a为无符号整形，判断 b &lt; a时 a会算术转换为 size_t； -1的补码为全1，而当其被当作无符号整形时就是一个非常大的数，然后再与0进行比较。 其实在整形家族的类型转换中，无非就是符号位的不同识别方式，以及各种截断，而浮点数类型想要和整形互相转换，那么由于存储的方式的巨大差异，编译器就不仅仅是截断或者改变识别方式那么简单了，而是涉及一些复杂的处理，当然我们不必关心。 操作符的属性复杂表达式的求值有三个影响的因素。 操作符的优先级 操作符的结合性（优先级相同，决定从左向右运算还是从右向左） 是否控制求值顺序。（&amp;&amp; ， || ， ？ ：，以及逗号表达式） 两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。 先看优先级，只有相邻的操作符间才能通过优先级确定计算顺序。 操作符优先级 优先级不建议背，可以使用括号解决优先级顺序问题。 123//表达式的求值部分由操作符的优先级决定。//表达式1a*b + c*d + e*f 计算上表达式时，由于 * 比+的优先级高，只能保证* 的计算是比+早，但是优先级并不能决定第三个*比第一个+早执行。 所以表达式的执行顺序可能是： 1234567891011a*bc*da*b + c*de*fa*b + c*d + e*f或者：a*bc*de*fa*b + c*da*b + c*d + e*f 12//表达式2c + --c; 注释：同上，操作符的优先级只能决定自减–的运算在+的运算的前面，但是我们并没有办法得知，+操作符的左操作数的获取在右操作数取值之前还是之后，所以结果是不可预测的，是有歧义的。 12345678//代码3-非法表达式int main(){ int i = 10; i = i-- - --i * (i = -3) * i++ + ++i; printf(&quot;i = %d\\n&quot;, i); return 0;} 表达式3在不同编译器中测试结果：非法表达式程序的结果. 12345678910111213//代码4int fun(){ static int count = 1; return ++count;}int main(){ int answer; answer = fun() - fun() * fun(); printf(&quot;%d\\n&quot;, answer);//输出多少？ return 0;} 虽然在大多数的编译器上求得结果都是相同的。 但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，再算减法。 函数的调用先后顺序无法通过操作符的优先级确定,也就是说操作数的确定顺序和操作符优先级无关。 12345678910//代码5#include &lt;stdio.h&gt;int main(){ int i = 1; int ret = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, ret); printf(&quot;%d\\n&quot;, i); return 0;} 看看同样的代码产生了不同的结果，这是为什么？ 简单看一下汇编代码， 就可以分析清楚. 这段代码中的第一个 + 在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级和结合性是无法决定第一个 + 和第三个前置 ++ 的先后顺序。 总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。","link":"/2023/01/12/C/8.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"C语言指针","text":"指针是什么 指针是什么？ 指针理解的2个要点： 指针是内存中一个最小单元的编号，也就是地址； 平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量； 指针就是地址，指向某一块内存空间。 我们有一个变量在栈中被创建，如果我们想找到它有几种方式呢？ 通过变量名去访问 通过地址访问 这一个个编号就是虚拟内存地址，相当于将内存分为以一个字节为基本单位的很多单元体，通过对这些单元体的编号，我们就可以在任何位置找到一个对应的编号。 像不像我们现实中的地址门牌号？ 指针变量 我们可以通过&amp;（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个变量就是指针变量。 12345678int main(){ int a = 10;//在内存栈中开辟一块空间 int *p = &amp;a;//这里我们对变量a，取出它的地址，可以使用&amp;操作符。 //a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量 //中，p就是一个之指针变量。 return 0;} 指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。 那这里的问题是： 一个小的单元到底是多大？（1个字节) 如何编址？ 经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。 对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压）就是（1或者0）； 这样每个地址就可以用32个二进制位表示。每个二进制位有两种情况。 那么32根地址线产生的地址就会是：2^32^ 每个地址标识一个字节，那我们就可以给 （2^32Byte = 2^32/1024KB = 2^32^ / 1024/1024MB = 2^32/1024/1024/1024GB = 4GB） 4G的空闲进行编址。 这里我们就明白： 在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以 一个指针变量的大小就应该是4个字节。 那如果在64位机器上，如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地址。 总结： 指针是用来存放地址的，地址是唯一标示一块地址空间的。 指针的大小在32位平台是4个字节，在64位平台是8个字节。 指针和指针类型先看看基本类型： 12345678910整形intcharshortlonglonglong浮点型doublefloat 那么指针指向不同的类型，是不是就代表着指针类型的不同呢？ 可以确定的说：当然。 如下代码： 12int a = 0;int* p = &amp;a; p就是一个指针变量，指向一个int类型的数据。 根据a的类型的不同，p的类型也要做出相应的调正。 我们知道p就是一个指针变量，那它的类型是怎样的呢？ 我们给指针变量相应的类型。 123456char *pc = NULL;int *pi = NULL;short *ps = NULL;long *pl = NULL;float *pf = NULL;double *pd = NULL; 可以看到任何任何类型的指针的变量前都有一个 * ， 大致模样是 type + * + 变量名 char* 类型的指针是为了存放 char 类型变量的地址。 short* 类型的指针是为了存放 short 类型变量的地址。 int* 类型的指针是为了存放 int 类型变量的地址。 指针可以根据指向不同的类型来分类，那么它们作用上有什么不同？ 通常来说，想通过地址访问变量，不同变量的存储方式，大小都不同，那么指针去访问的时候的权限以及解引用访问方式是不是应该也不同。 123456int i;double d;//假如它们的首地址相同int* p1 = &amp;i;double *p2 = &amp;d;p1 == p2; int 和 double的类型长度不同，那么通过解引用方式取得 i 和 d的值的时候，所访问的字节长度也不同。 12345678910111213//演示实例int main(){ int n = 10; char *pc = (char*)&amp;n; int *pi = &amp;n; printf(&quot;%p\\n&quot;, &amp;n); printf(&quot;%p\\n&quot;, pc); printf(&quot;%p\\n&quot;, pc+1); printf(&quot;%p\\n&quot;, pi); printf(&quot;%p\\n&quot;, pi+1); return 0;} 输出： 可以看到指针类型决定了指针加一或者减一时跳过几个字节。 指针的解引用 123456789int main(){ int n = 0x11223344; char* pc = (char*)&amp;n; int* pi = &amp;n; *pc = 0; (1) *pi = 0; (2) return 0;} 上图为(1)被执行 下图为(2)被执行 指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。比如： char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。 野指针成因 指针未初始化 123456int main(){ int* p; int a = *p; return 0;} 会报错：使用了未初始化的局部变量。 指针越界访问 1234567891011int main(){ int arr[10] = { 0 }; int* p = arr; int i = 0; for (i = 0; i &lt;= 11; i++) { *(p++) = i;//当指针指向的范围超出数组arr的范围时，p就是野指针 } return 0;} 如何规避野指针的使用 指针初始化； 注意指针的越界； 指针使用后及时置NULL； 函数体中不应返回局部变量的地址； 检查指针的有效性； 12345678910111213#include &lt;stdio.h&gt;int main(){ int *p = NULL; //.... int a = 10; p = &amp;a; if(p != NULL) { *p = 20; } return 0;} 指针运算 指针 + 整数 指针 - 整数 指针 - 指针 指针 +- 整数 指针的值增加（减少） = 指向的类型的字节数 * 整数。 指针 - 指针 结果等于：两个指针相差的字节数 / 指向类型的字节数。 指针的关系运算 就是普通的地址值的比较。 值得注意的是，在对数组的操作中: 标准规定： 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。 指针和数组看代码: 12345678#include &lt;stdio.h&gt;int main(){ int arr[10] = {1,2,3,4,5,6,7,8,9,0}; printf(&quot;%p\\n&quot;, arr); printf(&quot;%p\\n&quot;, &amp;arr[0]); return 0;} 数组名和数组首元素的地址的值是一样的。 但是注意类型是不同的，只是在数值上相等。 我们既然可以知道数组元素的指针，那么自然可以实现对其元素地址的逐一访问。 1234567891011int main(){ int arr[] = {1,2,3,4,5,6,7,8,9,0}; int *p = arr; //指针存放数组首元素的地址 int sz = sizeof(arr)/sizeof(arr[0]); for(i=0; i&lt;sz; i++) { printf(&quot;&amp;arr[%d] = %p &lt;====&gt; p+%d = %p\\n&quot;, i, &amp;arr[i], i, p+i); } return 0;} 输出： 可以看到&amp;arr[i] == (arr + i )。 既然连地址都可以逐一访问了，那么地址上所存储的数据自然可以轻松获得： 123456789101112int main(){ int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 }; int *p = arr; //指针存放数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]); int i = 0; for (i = 0; i&lt;sz; i++) { printf(&quot;%d &quot;, *(p + i)); } return 0;} 二级指针指针是存储变量地址的变量，那么自然指针变量也是需要一块内存空间来存储它的值。 如果我们想得到指针变量的地址，只能对指针变量&amp;操作。 如果我们也想找一个变量用来存储指针变量的值，那么这个变量的类型是什么？ 这就是二级指针。 1234567int main(){ int num = 10; int* pa = &amp;num; int** ppa = &amp;pa; return 0;} 那么可以通过二级指针获取int变量的值吗？ 是的，我们既然二级指针记录了一级指针的值，就可以取得一级指针值，而一级指针的值又是int变量的地址，层层递进解引用，便可以获取int变量的值。 12*ppa = pa;**ppa = *pa = num 指针数组元素类型为整形集合的数组叫什么？ 答案是整形数组，那么理所应当，元素类型为指针的数组就叫指针数组了。 我们创建一个整型数组或者字符数组如下： 12int arr1[10];char arr2[10]; 数组名可以看作一个变量名，[10]代表这是个数组中有十个元素，那么剩下的就是元素类型。 我们创建一个有是个元素，每个元素为int*指针的数组： 我们创建一个int*变量是如何创建的？ 确定变量名 确定变量的类型 在变量名前加上类型名 那么数组也是差不多的。 12345678首先写出想要的数组名arr;arr是个数组，并且有十个元素，我们加上[10];arr[10];元素类型是什么？ int*int* arr[10]; 整形数组在内存中的存储 指针数组呢？ 可以看到，每个元素都是一个指针，指向一块特定的内存空间。 思考：指针数组的元素可以是数组名吗？ 答案是的，除了对数组名进行sizeof和&amp;操作的两种情况外，其他时候的数组名，一律当作指针来使用。","link":"/2023/01/12/C/9.%E3%80%90C%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3%E3%80%91%E6%8C%87%E9%92%88/"},{"title":"操作系统","text":"计算机的诞生传统的技术发展 技术进步是要花钱的，钱从哪里来？那么只有国家给，但是国家却无法从中获利，技术没有稳定的资金来源，因此技术进步是受阻并且缓慢的。 技术商业化 技术人员：搞技术。 搞技术需要资金，那么商业化的公司投资，获得其技术的授权和专利。 于是产生了intel，apple等公司用技术孵化出民用级的产品，于是将技术变现卖给老百姓。 操作系统发展为什么诞生了操作系统？ 在计算机被发明之初，只是一堆硬件，其使用成本是非常高的，通常只能是专业的科学家。 有人开始研发计算机上的软件，于是由肯汤普森使用汇编语言编写的Unix诞生，开始进入高校和各种实验室。 丹尼斯里奇和肯汤普森又使用C语言编写了Unix，与此同时： 授权了IBM等公司使用，至此大型公司也开始使用计算机。 微软等公司相继诞生，计算机开始进入普通家庭。 linux诞生，开源并不断有工程师给出改进方案。 操作系统是什么要知道操作系统是什么，就要先清楚两个问题： 为什么要有操作系统？ ​ 答：单纯的硬件操作效率地下，难度大。 操作系统和硬件的关系？ ​ 移动端 （手机、平板）和桌面端设备，OS图示： 更为详细的： 用户层：包括图形化界面，各种应用程序，各种库。 OS kernel：对上给用户提供良好高效的运行环境，对下管理好下层的软硬件资源，管理各种资源，包括： 进程管理 文件管理 内存管理 驱动管理 驱动层：一般，每一个硬件都有厂商提供的驱动，一些基础的硬件（鼠标，键盘，显示器）驱动由OS自动安装，对上提供访问硬件的接口，帮上层实现对硬件的基本访问，对下可以操作硬件。 硬件层：我们熟悉的硬件有CPU，显卡，显示器，鼠标，硬盘等等。 总结：OS是一款软件，是用于对软硬件资源进行管理的软件，是上层用户和下层硬件的媒介。 例如：显示器是我们使用时感知最明显的硬件，而如果我们想在显示器上使用printf或者cout向显示器上打印，本质就是像硬件写入数据，而对硬件写入数据的具体过程不需要我们关心，我们只需要告诉操作系统我们的需求，操作系统会完成对硬件的访问和操作，这样就大大提高了效率。 简单概括内核 内核主要目的是为了应用程序提供一个稳定良好的运行程序，其要干的五件事情： 内存管理 虚拟文件 系统进程调度 网络接口 进程间通信 从编程的角度看： Linux内核就是一个调用库，应用程序通过调用Linux提供的API函数来实现操作，Linux内核通过与驱动通信实现对硬件的有效管理。 驱动程序 驱动程序属于内核的一部分，是内核的扩展组件，用来帮助内核实现硬件的连接和操控，不包含驱动的内核也叫内核。内核通过提供统一的驱动操作接口供用户层使用，驱动就是在这层统一的接口下实现硬件的操控的中间层。 操作系统 操作系统，在内核的基础上有延伸，包括了提供基础服务的系统组件。操作系统是用户和硬件之间的一层媒介程序，为上提供编程接口，为下调用资源，管理驱动，以使用硬件。不管是Linux还是Windows或者安卓、iOS，它的主要功能有两点： 有效管理硬件。 方便用户操作。 驱动与操作系统的关系： 驱动程序实现了操作系统对硬件的有效管理，是操作系统管理硬件的一个途径。","link":"/2023/01/12/Linux/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"开源是什么","text":"开源是什么？开源方式是在开源社区内进行思考和协作的一种形式。 这一理念基于知识自由和核心原则：透明、协作、交付、包容和社区。 社区的思想交流和软件开发推动了以下行业的创新、科学和技术进步：教育、政府、法律、医疗保健和制造业。 这场运动为全球社区创造了一种通过源代码协作、共享和协助实现 个人及团体目标的方式。 开源的历史就是互联网的历史早在 20 世纪 50 年代和 60 年代，开发早期互联网技术和电信网络协议的研究人员就十分倚仗开放的协作式研究环境。现代互联网的根基—阿帕网（ARPANET）十分推崇同行评审和开放反馈流程。用户组互相共享源代码，相互扶持，构建创新。而论坛则能够促进对话，并为开放通信与协作制定标准。到 20 世纪 90 年代早期互联网诞生之时，协作、同行评审、通信和开放性的价值就已写入了它的底蕴之中。 开源开发模式的工作原理？开源开发模式是开源社区项目用于开发开源软件的过程。然后，软件以开源许可证发行，因此任何人都可以查看或修改源代码。 许多开源项目托管在 GitHub 上，您可以在此访问存储库或参加社区项目。常用开源项目包括 Linux®、Ansible 和 Kubernetes。 红帽使用开源软件开发模式创建企业开源产品和解决方案。红帽开发人员积极参与了数百个跨 IT 堆栈的开源项目。 红帽以社区构建的开源软件为起点，这些软件能够部分或完全满足客户的需求。红帽依托这些开源项目，强化安全防护，修补漏洞，以及添加新的企业功能。然后将这些改进回馈给最初的项目，造福整个社区。 客户在使用红帽软件时，会提供反馈，提交错误报告，并在需求发生变化时，请求获得其他功能。客户的反馈也指引着红帽的发展方向。 Linux 与开源Linux 是一款基于 GNU 通用公共许可证（GPL）发布的免费开源操作系统（OS）。Linux 也成为全球范围内规模最大的开源软件项目。 Linux 操作系统基于 Unix 的原则和设计创建，作为一个免费的开源系统，代替 MINIX 操作系统。 由于 Linux 是基于限制软件用途的开源许可证发布的，只要符合相应的许可条件，任何人都可以运行、研究、修改和重新分发源代码，甚至还可以销售修改后代码的副本。 自由软件、闭源软件和开源软件之间的区别是什么？开源软件是协作式软件，依靠社区生产和同行评审来相互使用、更改和共享源代码。 开发人员分享洞察、构想和代码，共同和单独创建更多创新的软件解决方案 这种可扩展且灵活的软件可确保任何拥有源代码 的人都能将其修改、增强和重新分发，从而提高可复用性和可访问性。 开源软件基于对等生产和大规模协作的基本原则，从而为 最终用户创造更可持续的软件开发体验。 闭源软件 (CSS) 是不向公众分发的专有软件。 这类软件进行了加密，因此仅创建该代码的原始作者有权合法复制、修改、更新和编辑源代码。 闭源软件会限制最终用户对应用可以执行的操作，防止用户修改、共享、复制或重新发布源代码。 在很长一段时间里，开源软件都被贴上了”自由软件”的标签。1983 年，Richard Stallman 通过 GNU 计划正式发起自由软件运动。自由软件运动强调用户的自由权利：自由查看源代码、自由修改、自由再分发，让用户能够自由获取源代码，并且自由地使用。 自由软件旗帜鲜明地反对专有软件或”闭源”软件。闭源软件的源代码则有着重重防护。只有源代码所有者才拥有该代码的合法访问权。更改和复制闭源代码是违法行为，用户只能付费按既定方式使用软件，无法修改另作他用，也无法与社区共享。 但是，”自由软件（free software）”的名称造成了大量困惑。自由软件只表示您可以按照自己的方式自由使用，但不一定意味着您就能免费拥有它。社区曾经对此的解释是：”它指的是言论自由的自由，而不是免费啤酒的免费”。Christine Peterson 是”开源”一词的发明者，为了解决这一问题，她曾试图用‘开源’来取代‘自由软件’：”早期称呼‘自由软件’不适用，并不是因为含有政治意义，而是会误导新手去过多关注于价格。所以我们需要一个关注于关键的源代码，而且不会让新用户混淆概念的术语。” Peterson 向一个工作组提出用”开源”一词来取代”自由软件”，该工作组的任务，是将开源软件实践引入更广阔的市场。工作组希望全世界了解，如果软件共享，如果软件具有协作性、开放性且可修改，软件就会更加完善。这样，软件可以发挥更多、更好的用途，可以更灵活，成本可以更低，寿命可以更长，也没有供应商锁定。 Eric Raymond 是该工作组的成员之一，1997 年，他在影响广泛的《大教堂与市集》一文中发表了大致相同的观点。1998 年，部分出于对该文章的回应，Netscape Communications Corporation 开源了 Mozilla 项目，将源代码作为自由软件发布。该代码的开源形式后来成为了 Mozilla Firefox 和 Thunderbird 的基础。 Netscape 对开源软件的支持，也为社区增加了更多压力，不得不思考如何重点关注自由软件运动的实际业务应用。而这也加深了开源和自由软件之间的分歧：”开源”成了一个描述自由软件的方法、生产和业务层面的词。而”自由软件”则仍是一个话语符号，根植于用户自由的概念，强调着这些问题的哲学意涵。 1998 年初，开放源代码促进会（OSI）成立， 规范了开源一词，并为其赋予行业范围内的常见定义。从 20 世纪 90 年代末到 21 世纪初期，企业仍对开源运动持谨慎和怀疑态度，但如今，该运动已从软件生产的边缘逐渐转而成为今天的行业标准。 开源的价值是什么？人们弃专有而选择开源的原因有很多，但最常见的原因包括： 同行评审：由于源代码可自由访问，而且开源社区非常活跃，因此同行程序员会积极检查和改进开源代码。它就如同充满活力和生机的代码，而不是固步自封、停滞不前。 透明性：想要准确了解哪些类型的数据移动到哪里，或代码中发生了哪些类型的变化？开源允许您自行检查和跟踪，不必依赖供应商承诺。 可靠性：专有代码只靠单个作者或控制该代码的公司来更新、修复和保持正常工作。开源代码的存在时间可以超越其原作者，因为活跃的开源社区会不断进行更新。开放标准和同行评审可以确保开源代码经常得到适当的测试。 灵活性：由于开源代码注重修改，因此您可以使用它来解决您的业务或社区面临的独特问题。您不再只能用一种特定方式使用代码，您可以依托社区帮助和同行评审帮助您实施新解决方案。 更低成本：因为开源，所以代码本身是免费的，当您使用红帽等公司时，您只用为支持、安全强化和管理互操作性帮助等服务买单。 无供应商锁定：赋予用户自由，意味着您可以随时随地使用开源代码，用于任何目的。 开放式协作：活跃的开源社区，让您不再囿于方寸天地，而是能获得超越兴趣小组或者一个公司的帮助、资源和观点。 参考文章： 全面解析：什么是开源？开源的意义是什么？| 红帽","link":"/2023/01/12/Linux/0.%E5%BC%80%E6%BA%90%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"搭建Linux环境","text":"Linux在学习编程的过程中非常重要，要学习Linux那就得先搭建Linux环境，本文将介绍如何在云服务器上搭建环境。 Linux环境的搭建方式主要有三种： 直接安装在物理机上，但是由于Linux桌面使用起来非常不友好，不推荐这种方式； 使用虚拟机软件，将Linux搭建在虚拟机上。但是由于当前的虚拟机软件多多少少存在一些bug，会导致环境上出现各种莫名其妙的问题，爱折腾的朋友可以尝试； 使用云服务器，目前比较主流的与服务器厂商有阿里云、腾讯云、华为云，可以直接去厂商买一个云服务器； 云服务器的优点： 使用云服务器不仅环境搭建简单, 避免折腾, 同时还有一个最大的好处, 部署在云服务器上的项目可以直接被外网访问到, 这个时候就和一个公司发布一个正式的网站没有任何区别. 也就能让我们自己写的程序真的去给别人去使用. 购买云服务器我们以腾讯云为例，不同的厂商不会有太大差别。 登录官网腾讯云 - 产业智变 云启未来 ； 可以先看看官网的活动，几个云服务器厂商都常年搞活动，价格还蛮便宜的 根据自身需求选择规格购买云服务器； 选择centos7.6，比较稳定适合学习； 第一次购买可能需要实名，填自己的信息就ok； 付款即可； 回到官网，进入控制台，进入云服务器； 进入下面我们刚刚购买成功的的示例； 至此我们就可以看到我们的云服务器的基本信息了，复制公网ip，一会儿我们用得上。 设置root密码，点击重置密码，密码建议设置复杂一些，否则容易被黑客入侵； 接下来就可以登陆到我们的服务器了，腾讯云提供了在控制台一键免密登录，但是不够方便，因此下文我们将继续介绍使用SSH远程登陆。 小结: 在这个环节我们最重要的是得到三个信息: 服务器的外网 IP 服务器的管理员账户（Centos默认root） 管理员账户密码（控制台设置的密码） 通过这些信息我们就可以使用Xshell远程登陆了。 使用Xshell远程登陆到云服务器Linux有很多桌面发行版，为什么我们不使用呢？主要是以后我们也用不到啊，况且有了图形化界面你还会使用命令吗？ 下载安装XshellXshell是一个远程终端软件，可以通过SSH协议远程登陆我们的云服务器。 Xshell官网：XSHELL - NetSarang Website 软件需要付费使用，不过它提供了免费的版本供非商业用途的使用。 查看云服务器的公网ip就是我们刚刚复制的那个ip地址。 使用Xshell远程登陆主机 打开Xshell，第一次使用界面和下面一致（我远程登陆过可能有些地方不同）； 左上角点击新建，蓝框内的填好后，其他的不要动，点击连接； 输入用户名，centos默认为root，以在腾讯云官网的设置的为准； 输入密码，腾讯云服务器控制台重置的密码，点击确认； 之后我们就可以通过Xshell连接到我们的云主机了。","link":"/2023/01/12/Linux/3.%E6%90%AD%E5%BB%BALinux%E7%8E%AF%E5%A2%83/"},{"title":"关于Linux","text":"Linux背景介绍本门课程学习Linux系统编程，你可能要问Linux从哪里来？它是怎么发展的？在这里简要介绍Linux的发展史。要说Linux，还得从UNIX说起。 Unix 最早是由 AT&amp;T® 贝尔实验室在 1969 年开发，是一种专有但可许可的产品。 在接下来的 10 年里，Unix 开发了多个版本，包括 V6，该版本是面向贝尔实验室以外提供的第一个版本。 由于新语言的性质，这个代码很快就引起了学术界的注意。 加州大学伯克利分校开始开发自己的 Unix 系统，很快就开发了一个名为 Berkley Software Distribution（BSD 许可证）的学术版本。 与此同时，AT&amp;T 将其 Unix 版本演进为 System V。这两个版本最终合并成为统一的第七版 Unix，然后进一步演进为：Sun Solaris、FreeBSD、NetBSD 和 OpenBSD。 1984 年，Richard Stallman 创建了一个名为 GNU (GNU’s Not Unix) 的自由 Unix 克隆。 此版本是开放的，可根据需要自由使用、修改和重新分发。 1991 年，Linus Torvalds 创建了名为”Linux”或 Linux 内核的操作系统内核。 通过与 FSF 和 BSD 组件相结合，Linux 成为一个完整的操作系统；现在它可在多个架构上运行，并已被老牌 Unix 供应商采用或支持。 UNIX发展的历史 1968年，一些来自通用电器公司、贝尔实验室和麻省理工学院的研究人员开发了一个名叫Multics的特殊操作系统。Multics在多任务文件管理和用户连接中综合了许多新概念。 1969－1970年，AT&amp;T的贝尔实验室研究人员Ken Tompson和Dennis Ritchie，在采用很多Multics特点的基础上开发了UINX系统。它运行在小型机上，满足了系统对科研环境的要求。从产生开始，UNIX就是一个有价值的、高效的、多用户和多任务的操作系统。 UNIX从满足个人的设计需求开始，逐步成长为由许多不同开发商所支持的标准软件产品。 第一个UNIX版本是免费给许多知名大学的计算机系使用的。 1972年，贝尔实验室开始发放商业版本，并且给不同的用户授权使用这个系统，使用者之一是加州大学伯克莱分校的计算机系。伯克莱给系统增加了许多新的特点，后来成为了标准。 1975年伯克莱由下属部门BSD发行了自己的UNIX版本。UNIX的BSD版本成为AT&amp;T贝尔实验室版本的主要竞争者，而其它的独立开发出的UNIX版本也开始萌生。 1980年微软公司开发了叫做Xenix的UNIX PC版本。AT&amp;T发行了第一个商业版本。名叫System Ⅲ，后来被成为对商用软件产品良好支持的System Ⅴ所替代。 同时UNIX的BSD版本不断发展，在70年代末期，BSD UNIX成为了国防部的高科技研究机构科研项目的基础。其结果，伯克莱发行了一个叫做BSD Release 4.2的有效版本。 它包括了高级的文件管理器和基于TCP/IP网络协议的网络特点。现在TCP/IP被Internet所使用。BSD Release4.2被许多厂商所采用，例如SUN Microsystem。 UNIX不同版本的出现导致了UNIX标准的需要，软件开发商不知道他们的程序运行在哪些版本上比较合适。 到80年代中期，两个竞争的标准出现了，一个是基于AT&amp;T的UNIX版本，另一个是BSD版本。在今天的书店里你能发现分别适用于这两个版本的不同的UNIX的书，一些是System V，另一些集中在BSD UNIX。 AT&amp;T建立了一个叫UNIX系统实验室的新组织，它的作用就是综合UNIX的不同版本，集中开发一个标准系统。 1991年，UNIX综合实验室综合了System V Release3，SUN OS和Xenix的所有特点，发行了System V Release4。为了与System V Release 4 竞争，一些其它公司，如IBM和惠普Open Software Foundation（OSF）去产生自己的UNIX标准版本，继而出现了两个标准商业版本OSF版本和System Release 4。 1993年，AT&amp;T把它的UNIX转卖给Novell公司。UNIX系统实验室成为了Novell的UNIX系统小组的一部分。Novell发行了基于System V Release 4的自己的UNIX版本UNIXWare，它可以和Novell公司的Netware系统相联。SUN公司已经把System V Release 4 融进了它的SUN OS，发行了Solaris。两个相互竞争的UNIX使用的图形用户界面（一个叫Motif，另一个叫Openlook），已经合并为一个新的工作平台标准，叫做通用平台环境（CDE）。 Linux发展历史 1991年10月5日，赫尔辛基大学的一名研究生Linus Benedict Torvalds在一个Usenet新闻组（comp.os.minix）中宣布他编制出了一种类似UNIX的小操作系统，叫Linux。新的操作系统是受到另一个UNIX的小操作系统——Minix的启发，该系统是由一名叫Andrew S Tanenbaum的教师开发的。读者也许猜想所发布的这个系统应该是Linux的0.01版本，实际上不是这样。真正的Linux 0.01版本并没有被发布，原因是0.01版本不实用。Linus仅仅在第一个Linux的FTP站点（ftp://nic.funet.fi）上提供过这个版本的的源代码。 Torvalds于10月5日发布的这个Linux版本被称为0.02版，它能够运行GNU Bourne Again Shell(bash)和GNU的C编译程序（gcc）以及为数不多的其它语言。Torvalds绝对没有想到他设想的一种能够针对高级业余爱好者和黑客们的操作系统已经产生，这就是人们所称的Linux。 Linux发布时的版本是0.02，后来又有0.03版，然后又跳到0.10版。因为世界各地越来越多的程序员都开始开发Linux，它已经达到0.95版。这就意味着正是公布1.0版本的时间已经为期不远了。正式的1.0版本是在1994年公布的。 开源 Linux是一种自由和开放源代码的类UNIX操作系统，该操作系统的内核由林纳斯托瓦兹在1991年首次发布，之后，在加上用户空间的应用程序之后，就成为了Linux操作系统。严格来讲，Linux只是操作系统内核本身，但通常采用“Linux内核”来表达该意思。而Linux则常用来指基于Linux内核的完整操作系统，它包括GUI组件和许多其他实用工具。 GNU通用公共许可协议（GNU General Public License，简称GNU GPL或GPL），是一个广泛被使用的自由软件许可协议条款，最初由理查德斯托曼为GNU计划而撰写，GPL给予了计算机程序自由软件的定义， 任何基于GPL软件开发衍生的产品在发布时必须采用GPL许可证方式，且必须公开源代码。 Linux是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU通用公共许可证，任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。随着Linux操作系统飞速发展，各种集成在Linux上的开源软件和实用工具也得到了应用和普及，因此，Linux也成为了开源软件的代名词。 应用场景 Linux在服务器领域的发展 ​ 随着开源软件在世界范围内影响力日益增强，Linux服务器操作系统在整个服务器操作系统市场格局中占据了越来越多的市场份额，已经形成了大规模市场应 用的局面。并且保持着快速的增长率。尤其在政府、金融、农业、交通、电信等国家关键领域。此外，考虑到Linux的快速成长性以及国家相关政策的扶持力 度，Linux服务器产品一定能够冲击更大的服务器市场。据权威部门统计，目前Linux在服务器领域已经占据75%的市场份额，同时，Linux在服务器市场的迅 速崛起，已经引起全球IT产业的高度关注，并以强劲的势头成为服务器操作系统领域中的中坚力量。 Linux在桌面领域的发展 ​ 近年来，特别在国内市场，Linux桌面操作系统的发展趋势非常迅猛。国内如中标麒麟Linux、红旗Linux、深度Linux等系统软件厂商都推出的Linux桌面操作 系统，目前已经在政府、企业、OEM等领域得到了广泛应用。另外SUSE、Ubuntu也相继推出了基于Linux的桌面系统，特别是Ubuntu Linux，已经积累了大 量社区用户。但是，从系统的整体功能、性能来看，Linux桌面系统与Windows系列相比还有一定的差距，主要表现在系统易用性、系统管理、软硬件兼容 性、软件的丰富程度等方面。 Linux在移动嵌入式领域的发展 ​ Linux的低成本、强大的定制功能以及良好的移植性能，使得Linux在嵌入式系统方面也得到广泛应用，目前Linux以广泛应用于手机、平板电脑、路由器、电 视和电子游戏机等领域。在移动设备上广泛使用的Android操作系统就是创建在Linux内核之上的。目前，Android已经成为全球最流行的智能手机操作系统， 据2015年权威部门最新统计，Android操作系统的全球市场份额已达84.6%。此外，思科在网络防火墙和路由器也使用了定制的Linux，阿里云也开发了一套 基于Linux的操作系统“YunOS”，可用于智能手机、平板电脑和网络电视；常见的数字视频录像机、舞台灯光控制系统等都在逐渐采用定制版本的Linux来实 现，而这一切均归功与Linux与开源的力量。 Linux在云计算/大数据领域的发展 ​ 互联网产业的迅猛发展，促使云计算、大数据产业的形成并快速发展，云计算、大数据作为一个基于开源软件的平台，Linux占据了核心优势；据Linux基金会 的研究，86%的企业已经使用Linux操作系统进行云计算、大数据平台的构建，目前，Linux已开始取代Unix成为最受青睐的云计算、大数据平台操作系统。 发行版本 Debian Debian运行起来极其稳定，这使得它非常适合用于服务器。 debian这款操作系统无疑并不适合新手用户，而是适合系统管理员和高级用户。 Ubuntu Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应用，在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。Ubuntu是新手用户肯定爱不释手的一款操作系统。红帽企业级Linux 这是第一款面向商业市场的Linux发行版。它有服务器版本，支持众多处理器架构，包括x86和x86_64。红帽公司通过课程红帽认证系统管理员/红帽认证工程师（RHCSA/RHCE），对系统管理员进行培训和认证。 CentOS CentOS是一款企业级Linux发行版，它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱，又能领略红帽企业级Linux；对他们来说，CentOS值得一试。此外，CentOS的外观和行为似乎与母发行版红帽企业级Linux如出一辙。 CentOS使用YUM来管理软件包。 Fedora 小巧的Fedora适合那些人：想尝试最先进的技术，等不及程序的稳定版出来。其实，Fedora就是红帽公司的一个测试平台；产品在成为企业级发行版之前，在该平台上进行开发和测试。Fedora是一款非常好的发行版，有庞大的用户论坛，软件库中还有为数不少的软件包。 Kali Linux Kali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。Kali的前身是Backtrack。用于Debian的所有Binary软件包都可以安装到Kali Linux上，而Kali的魅力或威力就来自于此。此外，支持Debian的用户论坛为Kali加分不少。Kali随带许多的渗透测试工具，无论是Wifi、数据库还是其他任何工具，都设计成立马可以使用。Kali使用APT来管理软件包。毫无疑问，Kali Linux是一款渗透测试工具，或者是文明黑客（我不想谈论恶意黑客）青睐的操作系统。 为什么使用Centos你会发现非常多的商业公司部署在生产环境上的服务器都是使用的CentOS系统，CentOS是从RHEL源代码编译的社区重新发布版。如此多的发行版本，为何我们使用Centos？ 稳定的系统 Centos 是另一个商业 Red Hat Enterprise Server 操作系统的派生，当然也是基于 Linux 的。Linux 内核的源代码是以标准规范的32 位(在64 位CPU上是64 位)的计算机来做的最佳化设计，可确保其系统的稳定性。正因为Linux 的稳定，才使得一些安装 Linux 的主机像Unix 机一样常年不关而不曾宕机。试想你的windows系统能常年不关机吗？ 完善的网络功能 Linux 内置了很丰富的免费网络服务器软件、数据库和网页的开发工具，如Apache、Sendmail、VSFtp、SSH、MySQL、PHP和JSP 等。近年来，越来越多的企业看到了Linux 的这些强大的功能，利用Linux 担任全方位的网络服务器。 简约 CentOS去除很多与服务器功能无关的应用，系统简单但非常稳定，命令行操作可以方便管理系统和应用，并且有帮助文档和社区的支持。虽然不单独提供商业支持，但往往可以在Redhat中找到一丝线索。 历史原因 Linux在国内大范围普及在九十年代后期，最早的都是RedHat Linux，国内一些大范围应用Linux的大集团企业，比如银行系统、国家电网，它们直到现在都是用RedHat。Centos作为百分百的Redhat血统因此而比较火，国内互联网公司建立之初也大部分是由那些大企业出来的技术人员搞起来的，他们肯定都比较熟悉红帽体系。还有一个原因是Centos更新比较保守稳定，作为服务器系统来说太多更新会带来风险，这也是一个因素。","link":"/2023/01/12/Linux/2.%E5%85%B3%E4%BA%8ELinux/"},{"title":"Linux指令","text":"指令操作既然指令操作使用成本高，那么为什么要学指令操作呢？现在已经有了那么精致便捷的图形化界面，为什么还要用麻烦的指令操作呢？相信这是很多朋友刚刚接触linux时都会发出的疑问。 这要从操作系统的历程说起，图形化界面不是操作系统一诞生就有的，所有的操作系统，一开始的时候都只支持指令操作，图形化界面的诞生是为了用户更方便、便捷而设计出来的，没错这确实是让我们使用计算机的成本变低了，但却让我们忽略了图形化界面之下的原理。 当然，指令操作对于非专业技术人员不是必须的，甚至对于专业技术人员也不是必需，但是对于学习OS原理，指令操作是必要的，这对于OS的学习者来说意义非凡。 通过一些专业人员的操作可以看到，顶尖技术的大佬们貌似很少使用鼠标，而是五指游走在键盘上就可以完成许多操作，并且非常快速。的确，鼠标是后来出现的，在图形化界面出现之前都是依靠指令完成对计算机的操作。 然而图形化界面的操作实际上还是指令操作，经过层层包装，通过视觉传达给我们，让我们感觉更直观、清晰，而不是再是一行行的指令生硬地呈现在我们面前。不过，也正是图形化界面是指令操作套了一层“外壳”，离OS也就更远，因此学习OS原理，学习指令是更好的选择，指令距离OS更近，便于我们更好的掌握OS。 创建用户首先用root用户登陆系统，但一般不建议在root下使用，可以新建一个用户。 123456789# 查看系统信息uname -auname -r# 新建用户adduser sx # 设置密码passwd sx# 删除用户userdel -r sx Linux基本指令下面介绍一些基本的指令，粗体的选项是最常用的，属于要记忆的。 ls 指令语法： ls [选项] [目录或文件] 功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。 常用选项： -a 列出目录下的所有文件，包括以 . 开头的隐藏文件。 -d 将目录象文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录 -i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件 -k 以 k 字节的形式表示文件的大小。ls –alk 指定文件 -l 列出文件的详细属性信息。 -n 用数字的 UID,GID 代替名称。 （介绍 UID， GID） -F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表 示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别） -r 对目录反向排序。 -t 以时间排序。 -s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下最大的文件） -R 列出所有子目录下的文件。(递归) -1 一行只输出一个文件。 1ls -al 一个问题：空目录是否占据磁盘空间？ 在我们熟悉的Win10上，当我们查看目录（文件夹）属性时，如果是空目录，大小显示的是0kb，可真的如此吗？ 相信你也注意到了，这个显示给我们的0kb就是其属性信息，我们想要获取信息，那也必须得有地方保存其信息，属性信息的数据就保存在磁盘中。目录下的确是空的，但是即使是空目录，也会保存着其属性信息，例如：大小，创建时间，修改时间等等。 所以，答案是肯定的，空目录的文件属性信息也是数据，被保存在磁盘中，占据磁盘空间。 任何文件有两部分组成： 文件内容 文件属性 无论是学过的文件操作还是将要学习的文件操作，无非就是两类操作： 对文件内容进行操作 对文件属性进行操作 使用ls - a命令时，可以看到在任意目录下，都存在着两个隐藏文件 ： . 当前目录 .. 上级目录 ..可以让我们进入上级目录，. 当前路径有什么用呢？ 通常对于可执行程序，例如a.out，我们想要执行它就必须输入./a.out才可以。 pwd命令语法: pwd 功能：显示用户当前所在的目录路径 pwd的用法很简单，就是打印出当前路径，并且没有选项。 唯一需要注意的是Linux下的路径分隔符是/，而Windows下的路径分隔符是\\。 cd 指令Linux系统中，磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件。 语法: cd 目录路径 功能：改变工作目录。将当前工作目录改变到指定的目录下。 举例： 12345cd .. # 返回上级目录cd /home/litao/linux/ # 绝对路径cd ../day02/ # 相对路径cd ~ # 进入当前用户家目录，即用户登录时的初始目录cd - # 返回上一个访问的目录 说到cd 命令就一定要说几个概念： /根目录：整个目录树的根目录。 绝对路径：某个目录相对于/根目录的路径。 相对路径：某个目录相对于当前目录的路径。 要改变工作目录，那么就需要对新目录进行定位，有两种方式：1. 绝对路径 2. 相对路径。 Linux目录结构本质是一棵多叉树，通过二叉树的性质可以类比出多叉树的性质，那就是每一个节点的绝对路径是唯一的（每个节点都有唯一的父节点）。 相对路径就不存在这种说法了，因为对于不同的工作目录，相同的目录相对于当前目录的路径都是不同的。 例如，有如下目录结构： /home/sx/test1/test2 无论是home、sx、test1、test2中哪一个目录，它们相对于根目录的路径都是唯一的、确定的。 当我们想用相对路径对test2进行定位，如果在test1目录下，其相对路径为./test2，如果在sx目录下，其相对路径为./test1/test2，就和物理学当中的参考系一样，参考系的选取的不同会影响研究对象的坐标，即使研究对象的位置并没有发生改变。 不只是linux如此，只要是目录树其本质都是一棵多叉树。 如果是日常使用，推荐使用相对路径，方便快捷。 如果是进行添加配置文件之类的，推荐使用绝对路径，不会出错。 目录树的性质： Linux入口目录是/根目录，使用cd ..回退到/根目录的时候，就不能再进行回退了。 目录树多叉树结构，那么每个子节点，既可以是一个目录（放有新的根目录或者普通文件，递归定义），也可以是普通文件。 目录树的叶子节点，一定是一个普通文件或者空目录。 touch指令语法:touch [选项]… 文件… 功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件。 常用选项： -a 或–time=atime或–time=access或–time=use只更改存取时间。 -c 或–no-create 不建立任何文档。 -d 使用指定的日期时间，而非现在的时间。 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。 -m 或–time=mtime或–time=modify 只更改变动时间。 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。 -t 使用指定的日期时间，而非现在的时间&gt; touch指令目前只需要了解其一个用法，即创建一个普通文件（普通文件一定是目录树结构的叶子节点）。 1touch test.c mkdir指令（重要）语法：mkdir [选项] dirname… 功能：在当前目录下创建一个名为 “dirname”的目录 常用选项： -p, 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录 12mkdir sx # 创建一个目录mkdir -p sx/code/2022/8_18 # 创建一串路径 rmdir指令 &amp; rm 指令（重要)rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。 语法：rmdir [-p] [dirName] 适用对象：具有当前目录操作权限的所有使用者 功能：删除空目录 常用选项： -p 删除一串路径中的空目录，如果当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除，否则会报错。 1rmdir -p /home/sx/code/2022 # 如果2022目录为空，则删除，删除后如果其父目录code也变成空目录，就删除code，递归地进行删除 rm命令可以同时删除文件或目录 语法：rm [-f-i-r-v] [dirName/dir] 适用对象：所有使用者 功能：删除文件或目录 常用选项： -f 即使文件属性为只读(即写保护)，亦直接强制删除 -i 删除前逐一询问确认 -r 删除目录及其下所有文件 1rm -rf code # 强制递归地删除code目录 man指令（重要）Linux的命令有很多参数，我们不可能全记住，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令是: man 语法: man [选项] 命令 常用选项： -k 根据关键字搜索联机帮助 num 只在第num章节找 -a 显示所有匹配的手册页而不是仅显示第一个匹配的手册页，比如 man printf 它缺省从第一章开始搜索，找到就停止，若使用a选项，他会继续往后面搜索，直到所有章节都搜索完毕。 解释一下,面手册分为9章： 1 是标准命令（未指定选项时默认为1） 2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件) 3 是库函数,如printf,fread4是特殊文件,也就是/dev下的各种设备文件 4 是Special devices （设备说明） 5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 6 是给游戏留的,由各个游戏自己定义 7 是杂项，包括附件还有一些变量,比如向environ这种全局变量在这里就有说明 8 是系统管理用的命令,这些命令只能由root使用,如ifconfig 9 是其他（Linux特定的）， 用来存放内核例行程序的文档。 若无法使用man指令 报错：No manual entry for xxx in section x 尝试root下： 1yum install -y man-pages cp指令（重要）语法：cp [选项] 源文件或目录 目标文件或目录 功能: 复制文件或目录 说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录,则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息，这时，源文件只能有一个。如果目的地和源都不是目录而是普通文件，则会拷贝源文件地内容到目的地文件。 用法: 视cp命令中第二个参数类型的不同（目标文件是已存在的目录还是已存在目录下的目标文件），cp命令将拷贝一个新文件并命名或将其拷贝到另一个目录下。 当第二个参数类型不是已存在的目录而是已存在目录下的文件（可以存在也可不存在的文件）时，cp命令完成拷贝文件后命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录拷贝后命名为给定的目标文件名。 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，cp命令将各参数指定的源文件均拷贝至目标目录下。 常用选项： -f 或 –force 强行复制文件或目录， 不论目的文件或目录是否已经存在 -i 或 –interactive 覆盖文件之前先询问用户 -r 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理 -R 或 –recursive递归处理，将指定目录下的文件及子目录一并处理 默认cp命令不能拷贝目录，如果需要拷贝目录，应该加上选项 -r。 cp不能复制到当前源文件目录下。 更详细的： 当源文件是普通文件时 如果目标文件是已存在的目录，则会拷贝到该目标目录下 如果目标文件是不存在的文件，则会拷贝到目标文件的上级目录重命名为指定文件名的新普通文件 如果目标文件是已存在普通文件，则会拷贝源文件内容到目标文件 当源文件是目录时 如果目标文件是已存在的目录，则会拷贝到该目标目录下 如果目标文件是不存在的目录，则会拷贝到目标目录的上一级目录命名为一个指定名称的新目录。 注意：如果目标路径不存在，必须上一级路径是存在的才能正常拷贝。 mv指令（重要）mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 语法: mv [选项] 源文件或目录 目标文件或目录 功能: 视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。 当第二个参数类型不是已存在的目录而是已存在目录下的文件（可以存在也可不存在的文件）时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录下。 常用选项： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖。 -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ 1234567891011将rm改造成mvvim ~/.bashrc #修改这个文件mkdir -p ~/.trashalias rm=trashalias ur=undelfileundelfile() {mv -i ~/.trash/\\$@ ./}trash() {mv $@ ~/.trash/} 通常用于剪贴文件和重命名文件。 更详细的： 当源文件是普通文件时 如果目标文件是已存在的目录，则会移动到该目标目录下 如果目标文件是不存在的文件，则会移动到目标文件的上一级目录重命名为一个指定文件名的新普通文件 如果目标文件是已存在普通文件，则会移动源文件并重命名为指定为文件名覆盖目标文件 当源文件是目录时 如果目标文件是已存在的目录，则会移动到该目标目录下 如果目标文件是不存在的目录，则会移动到目标目录的上一级目录重命名为一个指定名称的新目录。 注意：如果目标路径不存在，必须上一级路径是存在的才能正常mv。 cat&amp;tac语法：cat [选项] [文件] 功能： 查看（打印）目标文件的内容 常用选项： -b 对非空输出行编号 -n 对输出的所有行编号 -s 不输出多行空行 tac用法和cat一样，功能是反向打印文件内容。 cat不适合查看大文本文件 cat会默认（不指定文件名时）从键盘（标准输入）读入 more指令语法：more [选项] [文件] 功能：more命令，功能类似 cat 常用选项： -n 对输出的所有行编号 q 退出more 回车下翻文本 123456[atong@LiWenTong ~]$ ls -l / | moretotal 162drwxr-xr-x 2 root root 4096 Apr 25 05:39 bindrwxr-xr-x 4 root root 1024 Apr 25 04:11bootdrwxr-xr-x 9 root root 3820 May 4 23:20 devdrwxr-xr-x 84 root root 4096 May 5 00:37 etc less指令（重要） less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。 less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻，只能往后面看。 但若使用了 less 时，就可以使用 [pageup] [pagedown] [上] [下] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！可用于日志查看。 除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜，因此与more相比，更推荐使用less。 语法： less [参数] 文件 功能：less与more类似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。 选项： -i 忽略搜索时的大小写 -N 显示每行的行号 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） q:quit 重定向输出重定向 把本来应该输出到显示器上的内容，将他输出到文件中。 1echo &quot;hello sx&quot; &gt; hello.txt 输出重定向会清空原始文件，进行输出重定向。 追加重定向 同上 1echo &quot;hello sx&quot; &gt;&gt; hello.txt 不会清空原始内容，追加重定向在原始文件结尾追加写入。 输入重定向 把本来应该从你键盘上文件中读取数据的方式，改成从指定文件中读取。 1cat &lt; hello.txt 以上输入重定向功能上和cat hello.txt一样。 Ctrl + C/Zctrl+c和ctrl+z都是中断命令,但是他们的作用却不一样. ctrl+c是强制中断程序的执行，进程已经终止。 ctrl + z 可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行，但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态，用户可以使用fg/bg操作继续前台或后台的任务。 jobs 查看当前在后台运行的任务 fg 将后台中的命令调至前台继续运行 bg 将一个在后台暂停的命令，变成继续执行 （仍在后台执行） 12345678910111213141516[sx@VM-4-9-centos test]$ cat # cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。^Z # ctrl 中断任务[1]+ Stopped cat[sx@VM-4-9-centos test]$ cat # cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。^Z # ctrl 中断任务[2]+ Stopped cat[sx@VM-4-9-centos test]$ jobs # 查看当前在后台运行的任务[1]- Stopped cat[2]+ Stopped cat[sx@VM-4-9-centos test]$ fg 2 # fg 将后台任务进程调至前台继续运行cat^C # 中止任务[sx@VM-4-9-centos test]$ fg 1 # fg 将后台任务进程调至前台继续运行cat^C # 中止任务[sx@VM-4-9-centos test]$ jobs # 查看当前终端放入后台的工作 可以看到，当前终端有两个后台工作：第一个和第二个都是 cat 命令，第一个工作号为 1，状态是暂停，标志是”-“；第二个工作号为 2，状态是暂停，标志是”+”。”+”号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作。”-“号代表倒数第二个放入后台的工作，而第三个以后的工作就没有”+-“标志了。 一旦当前的默认工作处理完成，则带减号的工作就会自动成为新的默认工作，换句话说，不管此时有多少正在运行的工作，任何时间都会有且仅有一个带加号的工作和一个带减号的工作。 小Tips：所以阻碍你命令行操作，无脑Ctrl + C。 linux下皆文件一切外设（键盘、网卡……除了CPU和内存），都被当作文件。 优点：看待事物的方式变得简单，处理事务的方式变得单一。 head指令head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 语法： head [参数]… [文件]… 功能： head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 选项： -n ,&lt; n &gt;为要显示的行数 tail指令tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容. 语法： tail[必要参数] [选择参数] [文件] 功能： 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 选项： -f 循环读取-n ,&lt; n &gt;为要显示的行数 管道来解决一个问题，我们如何打印出一个有100000行文本文件的1000-1020行？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748有一个文件共有100000行内容，请取出第1000到1020行内容# 方法1 临时文件[sx@VM-4-9-centos test]$ cnt=1; while [ $cnt -le 100000 ]; do echo &quot;hello sx $cnt&quot;; let cnt++; done &gt; test.txt[sx@VM-4-9-centos test]$ head -1020 test.txt &gt; tmp[sx@VM-4-9-centos test]$ tail -20 tmphello sx 1001hello sx 1002hello sx 1003hello sx 1004hello sx 1005hello sx 1006hello sx 1007hello sx 1008hello sx 1009hello sx 1010hello sx 1011hello sx 1012hello sx 1013hello sx 1014hello sx 1015hello sx 1016hello sx 1017hello sx 1018hello sx 1019hello sx 1020# 方法2 管道[sx@VM-4-9-centos test]$ head -1020 test.txt | tail -20hello sx 1001hello sx 1002hello sx 1003hello sx 1004hello sx 1005hello sx 1006hello sx 1007hello sx 1008hello sx 1009hello sx 1010hello sx 1011hello sx 1012hello sx 1013hello sx 1014hello sx 1015hello sx 1016hello sx 1017hello sx 1018hello sx 1019hello sx 1020 管道：级联多个命令，来完成流水线式的数据处理工作。 可以想一下方法一的精髓是什么？ 是不是就是用被head -1020处理过的数据，存储到tmp文件里，从而使得能让tail -20去处理加工已经被 head -1020处理过的数据，达到二次加工的目的呢？ 方法一的两次加工的媒介是临时文件tmp，那方法二的媒介是不是应该也差不多呢，结果是当然的。不过没关系我们目前仅理解应用后面再理解其原理。 时间相关的指令date显示 date 指定格式显示时间： date +%Y:%m:%d date 用法：date [OPTION]… [+FORMAT] 1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下 %H : 小时(00..23) %M : 分钟(00..59) %S : 秒(00..61) %X : 相当于 %H:%M:%S %d : 日 (01..31) %m : 月份 (01..12) %Y : 完整年份 (0000..9999) %F : 相当于 %Y-%m-%d 2.在设定时间方面 date -s //设置当前时间，只有root权限才能设置，其他只能查看。 date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00 date -s 01:01:01 //设置具体时间，不会对日期做更改 date -s “01:01:01 2008-05-23″ //这样可以设置全部时间 date -s “01:01:01 20080523″ //这样可以设置全部时间 date -s “2008-05-23 01:01:01″ //这样可以设置全部时间 date -s “20080523 01:01:01″ //这样可以设置全部时间 3.时间戳 时间戳通常是日志的一部分，日志记录了程序运行过程中何时发生了何事，是排查程序错误的好帮手。 时间-&gt;时间戳：date +%s 4.转换时间戳 时间戳-&gt;时间：date -d@1508749502 可以自定义格式： 1234[sx@VM-4-9-centos test]$ date -d@10Thu Jan 1 08:00:10 CST 1970[sx@VM-4-9-centos test]$ date +%Y-%m-%d -d@101970-01-01 Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。 Cal指令cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。 命令格式： cal [参数] [月份] [年份] 功能： 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份 常用选项： -3 显示系统前一个月，当前月，下一个月的月历 -j 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数） -y 显示当前年份的日历 1cal -y 2018 # 查看2018年的日历 find指令（灰常重要） -name Linux下find命令在目录结构中搜索文件，并执行指定的操作。 Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。 即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 语法： find pathname -options 功能： 用于在文件树种查找文件，并作出相应的处理（可能访问磁盘） 常用选项： -name 按照文件名查找文件。 1find /home/usr -name test.c # 在/home/usr目录下找所以名为test.c的文件 grep指令linux grep命令详解 - ggjucheng - 博客园 语法： grep [选项] 搜寻的字符串 文件 功能： 在文件中搜索字符串，将找到的行打印出来（行文本过滤工具） 说明：匹配行文本中的关键字，如果一行中有匹配的，这整行都保留。 常用选项： -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 ‘搜寻的字符串’ 内容的那些行 zip/unzip指令：语法： zip 压缩文件.zip 目录或文件 功能： 将目录或文件压缩成zip格式 常用选项： -r 递归处理，将指定目录下的所有文件和子目录一并处理 1234# 将test2目录压缩：zip test2.zip test2/*# 解压到tmp目录：unzip test2.zip -d /tmp *是通配符，可代指所以文件。 若不适用-d选项，则默认解压缩到当前工作目录。 优点： 节约本地磁盘空间 开发人员开发出的软件项目不止一个文件，因此要打包压缩，并且可以在部署项目时加快上传和下载速网络传输速度 将需要的文件打包，可以保证包的完整性（不完整解压时会error） 压缩的过程： 打包 压缩 tar指令（重要）：打包/解包，不打开它，直接看内容tar [-cxtzjvf] 文件与目录 …. 参数： -c ：建立一个压缩文件的参数指令(create 的意思)； -x ：解开一个压缩文件的参数指令！ -t ：查看 tarfile 里面的文件！ -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？ -j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？ -v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！ -f ：目标（使用）档名，请留意，在 f 之后要立即接档名喔！不要再加参数！ -C ： 解压到指定目录 1234567891011[sx@VM-4-9-centos test]$ lspakage test.txt[sx@VM-4-9-centos test]$ tar czf test.tgz pakage # 组合命令可不带-[sx@VM-4-9-centos test]$ lspakage test.tgz test.txt[sx@VM-4-9-centos test]$ mv pakage ../[sx@VM-4-9-centos test]$ lstest.tgz test.txt[sx@VM-4-9-centos test]$ tar xzf test.tgz -C ./ # 解压缩到指定目录（默认解压到工作目录）[sx@VM-4-9-centos test]$ lspakage test.tgz test.txt tar命令会对目录下所有文件和子目录一并处理。 解压缩命令会基本使用即可，不需要深入研究，没有那个必要。 默认情况下，几乎所有工具都会默认解压缩至工作目录。 linux下支持的压缩包 linux几乎支持所有种类的压缩包，所有互联网公司后台都是linux系统，开发人员开发的软件，将来都是要部署到linux系统上得，开发出的软件被打包在一起并压缩，因此部署在linux上时就一定得先上传这些压缩包到linux平台，不同的开发平台可能压缩工具和算法都不同，例如Windows，MacOS等等，要将不同环境下开发的项目部署在linux，那就必须能够正确解压这些不同种类压缩包。 bc指令bc命令可以很方便的进行浮点运算（不常用） 123456789[sx@VM-4-9-centos pakage]$ bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty'. 1+123*927 uname –r指令：语法：uname [选项] 功能： uname用来获取电脑和操作系统的相关信息。 补充说明：uname可显示linux主机所用的操作系统的版本、硬件的名称等基本信息。 常用选项： -a或–all 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称 -r或–release 显示操作系统的发行编号。 1234[sx@VM-4-9-centos test]$ uname -aLinux VM-4-9-centos 3.10.0-1160.66.1.el7.x86_64 #1 SMP Wed May 18 16:02:34 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux[sx@VM-4-9-centos test]$ uname -r3.10.0-1160.66.1.el7.x86_64 x86_32就是32位平台，简称x86 x86_64就是64位平台，简称x64 重要的几个热键[Tab],[ctrl]-c, [ctrl]-d [Tab]按键—具有『命令补全』和『档案补齐』的功能（一下不行就两下） [Ctrl]-C按键—让当前的程序『停掉』 [Ctrl]-D按键—快速推出账户，通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit [Ctrl]-R按键—搜索历史命令 关机语法：shutdown [选项] ** 常见选项：** -h ： 将系统的服务停掉后，立即关机。 -r ： 在将系统的服务停掉之后就重新启动 -t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思 以下命令作为扩展:◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last； ◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln； ◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、crontab； ◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup； ◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who； ◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。","link":"/2023/01/12/Linux/4.Linux%E5%88%9D%E8%AF%86%E6%8C%87%E4%BB%A4/"},{"title":"Shell命令及权限理解","text":"Shell及权限理解本文将介绍Shell是什么以及Linux中的权限。 可以想一想在我们使用计算机的过程中，我们使用图形化界面或者命令行操作与计算机进行交互，是直接与内核进行交互吗？如果是那内核的接口开放出来想一想会有哪些问题呢？ shell命令以及运行原理Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。如何理解？为什么不能直接使用kernel？ 从技术角度，Shell的最简单定义：命令行解释器（command Interpreter）主要包含： 将使用者的命令翻译给核心（kernel）处理。 内核处理命令后，将内核的处理结果翻译给使用者。 对比windows GUI，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）。 Windows中，shell就是图形化界面操作，在Linux中，shell就是命令行操作。 shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果返回给shell，通过shell解析返回给用户。 帮助理解：如果说你是一个闷骚且害羞的程序员，那shell就像媒婆，操作系统内核就是你们村头漂亮的且有让你心动的MM小花。你看上了小花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲，所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花，而我们找到媒婆姓王，所以我们叫她王婆，它对应我们常使用的bash。 作用： 降低OS的操作成本（最大意义） 保护kernel，不将OS kernel直接暴露给用户。 centos 7 常用的命令行解释器（shell）叫做bash。 shell是这一类命令行解释器程序的总称，而bash是其中的一员。 Linux权限的概念Linux下有两种用户：超级用户（root）、普通用户。 超级用户（root）：可以再linux系统下做任何事情，不受限制，只有一个。 普通用户：在linux下做有限的事情，权限受到约束，可以由很多个。 超级用户的命令提示符是“#”，普通用户的命令提示符是“$”。 查看当前用户：whoami root拥有超级权限，不受规则约束，权限仅仅约束普通用户。 切换用户 命令：su - [用户名] / su [用户名] 功能：切换用户。 例如，要从root用户切换到普通用户user，则使用 su user。 要从普通用户user切换到root用户则使用 su root（root可以省略），此时系统会提示输入root用户密码的口令。 su - [用户名]会打开登录shell，su [用户名]会打开非登录shell。 su -也可以切换至root，但是与su root却有区别，使用su root没有登录提示符，而su -有登陆提示符。 先来明白两个概念： 登录shell和非登录shell 登录shell：是需要用户名、密码登录后才能进入的shell（或者通过”–login”选项生成的shell）。 非登录shell：当然就不需要输入用户名和密码即可打开的Shell，例如：直接命令“bash”就是打开一个新的非登录shell，在Gnome或KDE中打开一个终端（terminal）窗口程序也是一个非登录shell。 执行exit命令，退出一个shell（登录或非登录shell都可以退出） 执行logout命令，退出登录shell（不能退出非登录shell）。 看看下面： 使用 su - 1234567891011Last login: Sat Aug 20 20:33:41 2022 from 60.255.33.159[sx@VM-4-9-centos ~]$ whoamisx[sx@VM-4-9-centos ~]$ su -# 登录rootPassword: Last login: Sat Aug 20 20:34:07 CST 2022 on pts/0[root@VM-4-9-centos ~]# whoamiroot[root@VM-4-9-centos ~]# logout[sx@VM-4-9-centos ~]$ whoamisx 使用 su root 123456789Last login: Sat Aug 20 20:38:30 2022 from 60.255.33.159[sx@VM-4-9-centos ~]$ whoamisx[sx@VM-4-9-centos ~]$ su rootPassword: [root@VM-4-9-centos sx]# whoamiroot[root@VM-4-9-centos sx]# logoutbash: logout: not login shell: use `exit' 可以看到打开非登录shell时不会有登陆提示符，因此无法使用logout登出shell，而exit无论是登录shell还是非登录shell都可以退出。 小Tips： root用户密码和普通用户密码不要设置为同一个！ 从root用户可以切换至任何用户，一定要防止root用户泄露！ 从普通用户切换至另一个用户，需要的是要切换的用户的密码。 什么是权限权限 = 人 + 事务属性 在现实生活中，法律规定了哪些人能做什么事情，哪些人不能做什么事情，所以说判断一个人是否具备相应权限不仅仅是由人决定，还与具体做什么事情有关。 举个例子：我能不能在水吧吃顿饭？就涉及到两方面问题： 我能进去这个水吧吗？ 水吧有饭给我吃吗？ 如果都满足，那么才说明我可以在水吧吃顿饭，也就是说我有在水吧吃饭的这个权限。 linux下的权限 我们之前说过linux下皆文件，那么用户对linux进行操作，其实都是对文件进行操作，在对文件操作的过程中，就涉及到用户权限的问题，也就是用户对于文件是否具有相应权限。 这个权限问题就和上面我能不能在水吧吃顿饭的问题是一样的。 linux用户是否对某个文件具有相应权限，其实是： 用户能否对这个文件执行相应操作 文件是否具有用户想要对文件操作的属性 判断一个用户对于某个文件是否具有相应权限，也必须满足两个条件，只要有一个不满足，那么此用户就不具备相应权限。 Linux权限管理首先我们想想，在linux中权限的管理是通过用户还是通过文件来管理的？ 类比到现实世界，法律能不能将每一个人对每一件事的行为准则都规范一下并写到书里呢？显然是不现实的的，全世界那么多人，那得多麻烦？通常法律是将人身份进行分类，对某一件事物上根据人的身份类别不同对人加以不同的约束，然后针对每个事物规定 某身份的人对某事物能做什么。 举个例子：医院看病，军人优先，这就是一种权限。那么可以看到在医院看病这件事上，军人有优先的属性，那是不是军人对于所有事物都有此优先权限呢？那显然不是的，只有规定了军人优先的事物，军人才会对该事物有优先权。军人这个身份仅仅是在某些或者某一个事物上具有相应权限。并且军人这个身份不是一成不变的，对于不同的事物同一个人有不同的身份，就比如一个军人可以是母亲的儿子，妻子的丈夫，等等身份。 其实linux也是如此，它无法具体到每个用户对每个文件的权限（文件可太多了，用户也理论上可以无限多），也是通过对用户进行身份分类，再通过身份判断是否对一个文件具备相应权限，同一个用户对于不同的文件也可以拥有不同的身份，针对每一个文件规定 某文件某身份的人能有有什么权限。 一个文件访问者的分类（相对于文件的身份） 文件和文件目录的所有者：u—User（owner） 文件和文件目录的所有者所在的组的用户：g—Group 其它用户：o—Others （除了owner和group之外的） 一个问题：linux中的用户有root和普通用户，那这里又冒出来user、group、others这些，那么【root、普通用户】和【owner、group、others】它们之间相互冲突吗？ 答案是否定的，它们不会冲突，反而会有相互补充的作用。因为【owner、group、others】是相对于一个文件来说它有这样的用户分类（根据身份分类），而【root、普通用户】并不是针对某个文件，而是此计算机的使用者。是为了方便对文件权限的管理，才引申出【owner、group、others】这样的用户分类。 设想下，如果如果没有【owner、group、others】这样的相对于一个文件的用户分类的概念，那当我们想呈现一个文件的权限信息时，是不是就要显示出对每一个用户（【root、普通用户】）的权限呢？这样做显然太麻烦了，如果用户很多，在修改权限时也非常的麻烦。因此为了解决这个问题，在呈现一个文件的权限信息时，就新增了一个抽象用户概念【owner、group、others】。这样我们就不需要将每一个用户的权限信息逐一呈现出来了。 下图即为【owner、group、others】充当“代理人”的过程，可以表示什么人对该文件有什么权限。 可以看到无论你多少个用户，使用这个机制，对于一个文件来说，需要管理的仅仅就只有“三个用户”而已，当然这里的“用户”不是具体的用户，而更像是一种身份，相对于文件的身份！当我们想改变某个用户对这个文件的权限，只需要修改此用户相对于这个文件的身份即可，linux提供了将用户修改为owner和group的方法，虽然没有直接提供修改为other的方法，但是修改owner和group实际也就是对other进行了修改。 下图为直接呈现出用户和文件之间权限的过程，这样的方法如果user比较少，那么也没什么问题，可如果用户非常多，那这样的方式显然不利于我们的权限管理。 文件类型和访问权限（事物属性）使用ls -l命令查看文件属性 123456[sx@VM-4-9-centos test]$ lstest.tgz test.txt[sx@VM-4-9-centos test]$ ls -ltotal 1460-rw-rw-r-- 1 sx sx 193 Aug 20 16:01 test.tgz-rw-rw-r-- 1 sx sx 1488895 Aug 19 18:10 test.txt Linux系统不是以文件名后缀区分文件类型的（但Linux上的有些软件会区分后缀），而是如下图： 为什么linux中有所属组我们在做开发时，不是一个人而是一个团队进行协作，也就是我们所写的代码不是只能被代码的编辑者（owner）看到的，而是我们这个团队的所属成员都能看到，也就是具有相应的读权限。 举个例子： 有A、B两个团队他们开发一个功能相似的软件，最终选择两个团队中较优秀的那一个。这两个团队都在同一个服务器上开发，但由于两个团队是竞争关系，因此他们都不希望对对方能够看到自己的源码。 于是： A团队中的a写了一份代码Atesta.cpp B团队中的b写了一份代码Btestb.cpp 因此a可以读写Atesta.cpp，b可以读写Btestb.cpp，但是由于他们不想被另一个团队查看，因此Atesta.cpp和Btestb.cpp文件other身份都是没有读权限的。 既然是团队协作协作开发，那必然会涉及到要查看团队中其他成员的代码。假如A团队中的另一个成员想要查看a写的Atesta.cpp，但是A团队其他成员相对于Atesta.cpp文件的身份就是other，是没有该文件的读权限的，这不就出问题了吗？因此为了能够让除owner身份之外的人，也能有该文件一定的权限，就产生了所属组并赋予新的权限值和other区分。 如果linux中没有所属组这个概念，而other又都没有读权限，那是不是这个A中的a写的代码和B中b写的代码都只能被他们自己看见呢？这显然不太合理。 文件类型 1234567d：文件夹：也叫目录文件-：普通文件：文本文件，源代码，可执行程序，第三方静态库l：软链接（类似Windows的快捷方式），链接文件b：块设备文件（例如硬盘、光驱等）p：管道文件c：字符设备文件（例如屏幕等串口设备）s：套接口文件 基本权限 i.读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限 ii.写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限 iii.执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限 iv.“—”表示不具有该项权限 文件权限值的表示方法字符表示法 八进制数值表示方法 可以看到，【owner、group、others】对于某个文件的权限可分为三组。 一个“身份”（owner、group、other）对文件的权限分为一组，每一组中的每个位置权限含义都是确定的，分别表示 读、写、执行的权限，每一组对文件的权限都是由三个位置的状态表示的，而这每个位置都只有是和否两种状态，因此考虑用二进制表示。 第一个位置：r 或 - 第二个位置：w 或 - 第三个位置：x 或 - 我们使用二进制数进行替换，当位置为–的时候表示为0，位置不为–时表示为1，那么有三个位置，由三个二进制位就可以表示出每一种权限组合，那就是2^3^=8种，因此可以将二进制数转化为八进制数来表示权限。 这样通过3个八进制数就可以表示出三种身份的人对于某个文件的权限。 文件访问权限相关设置方法chmod 功能：设置文件的访问权限 格式：chmod [参数] 权限 文件名 常用选项： R -&gt; 递归修改目录文件的权限 说明：只有文件的拥有者和root才可以改变文件的权限 ①chmod命令权限值得格式 用户表示符+-=权限字符 +:向权限范围增加权限代号所表示的权限 -:向权限范围取消权限代号所表示的权限 =:向权限范围赋予权限代号所表示的权限 用户符号： u：拥有者 g：拥有者同组用 o：其它用户 a：所有用户 12345chmod u+w /home/abc.txtchmod o-x /home/abc.txtchmod g-r /home/abc.txtchmod u-r,g-r dirchmod a=rwx test.txt # 所有人权限都会变成rwx ②三位8进制数字 12chmod 664 /home/abc.txtchmod 640 /home/abc.txt chown 功能：修改文件的拥有者 格式：chown [参数] 用户名 文件名 实例： 123chown user f1chown -R user filegroup1chown user myfile.txt 注意： 普通用户，即使是此文件得拥有者，也无法修改文件的拥有者，道理也很简单，我们将东西自己的东西送给别人的时候这是一个双向的过程，你和被赠与者都需要同意，这件事情才是合法的。修改文件拥有者需要使用sudo以root身份执行该命令。 root拥有超级权限，不受规则约束，权限仅仅约束普通用户。 chgrp 功能：修改文件或目录的所属组 格式：chgrp [参数] 用户组名 文件名 常用选项：-R 递归修改文件或目录的所属组 实例： 1chown user myfile.txt # 报错同上，需要sudo提升权限 umask 为何我们创建的目录的默认权限是775而普通文件是664？（不同系统可能有差异） 这就要说到掩码了。 功能： 查看或修改文件掩码 理论上： 新建文件夹默认权限=0666 新建目录默认权限=0777 但是默认权限不 != 最终权限 但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还受到umask的影响。假设默认权限是mask，则实际创建的出来的文件权限是: mask &amp; (~umask) 或者 ((mask ^ umask) &amp; umask) ^ (mask ^ umask) ，一定注意运算先后顺序。 格式：umask 权限值 说明：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为0022，普通用户默认为0002。 实例： 123umask 755umask //查看umask 044//设置 123450 1 0 1 umask1 0 0 1 mask 最终结果1 0 0 0 linux中最终权限 = 默认权限“去掉” umask中存在的权限，凡是在掩码中出现的权限都不应该在最终权限中出现！ 结论：对文件的权限进行操作，这其实就是从人和文件属性这两方面进行操作，一方面我们修改文件面对不同身份【owner、group、other】时的属性，一方面我们修改用户相对于文件的身份，这样就能既简单又快捷的对用户对文件的权限进行管理了。 小问题： 想一想能不能用一个二进制数去表示一个用户对每一个文件的权限呢？ 答案是不行的！文件可太多了，那得多少个二进制位！如果这样设计，我们也很难找到我们想要操作的那个文件权限对应的二进制位（们），这样做权限管理将会是一件很复杂的事情。 目录的权限其实今天这个问题我们讲不透，简单说说吧。 我们都知道，linux下皆文件，目录也是文件。文件=文件内容+文件属性 那么进入一个目录需要什么权限？（面试题） 答案是x。至于为何是x，我目前认为目录是一个可执行程序（链接文件），用于进入目标目录文件。 12345678910[sx@VM-4-9-centos test]$ mkdir dir[sx@VM-4-9-centos test]$ lltotal 8drwxrwxr-x 2 sx sx 4096 Sep 2 22:07 dir[sx@VM-4-9-centos test]$ chmod 660 dir[sx@VM-4-9-centos test]$ lltotal 8drw-rw---- 2 sx sx 4096 Sep 2 22:07 dir[sx@VM-4-9-centos test]$ cd dir-bash: cd: dir: Permission denied 如果没有目录的r权限，允许进入，允许到目录下创建文件，但无法查看目录文件列表（目录内容） 123456789[sx@VM-4-9-centos test]$ lltotal 8drwxrwxr-x 2 sx sx 4096 Sep 2 22:09 dir[sx@VM-4-9-centos test]$ chmod u-r,g-r dir[sx@VM-4-9-centos test]$ lltotal 8d-wx-wxr-x 2 sx sx 4096 Sep 2 22:09 dir[sx@VM-4-9-centos test]$ ls dirls: cannot open directory dir: Permission denied 如果没有目录的w权限，允许进入，能查看目录文件列表（目录内容），不能创建文件和删除文件，并且如果目录下有文件的话，此目录也是无法删除的，因为删除目录就会删除目录下文件，但无w权限无法删除目录下文件。 123456789101112[sx@VM-4-9-centos test]$ chmod u-w,g-w dir[sx@VM-4-9-centos test]$ lltotal 8dr-xr-xr-x 2 sx sx 4096 Sep 2 22:20 dir[sx@VM-4-9-centos test]$ cd dir[sx@VM-4-9-centos dir]$ lstest.c[sx@VM-4-9-centos dir]$ rm -f test.crm: cannot remove ‘test.c’: Permission denied[sx@VM-4-9-centos dir]$ cd ..[sx@VM-4-9-centos test]$ rm -rf dirrm: cannot remove ‘dir/test.c’: Permission denied 如果同时没有w和r权限，允许进入，但是不允许创建（删除）和查看目录下的文件列表（注意：不是文件内容！！！文件的内容，是否可以查看，由文件本身的权限决定！！） 目录内容：保存的部分文件属性，例如文件名。 如果没有目录的r权限，那么能不能进入访问目录下的文件呢？（目录下文件有访问权限） 12345678910[sx@VM-4-9-centos test]$ lltotal 8d-wx-wxr-x 2 sx sx 4096 Sep 2 22:20 dir[sx@VM-4-9-centos test]$ cd dir[sx@VM-4-9-centos dir]$ llls: cannot open directory .: Permission denied[sx@VM-4-9-centos dir]$ cat test.c[sx@VM-4-9-centos dir]$ vim test.c[sx@VM-4-9-centos dir]$ lsls: cannot open directory .: Permission denied 这里貌似没问题，但是通常来说要想来说访问目录下的文件，就应该先能查看目录有哪些文件，目录无r权限，但这里通过我们的记忆记住了目录下文件名而去访问了该目录下的文件，这其实是有问题的，但系统可能允许我们这样做，明确的说这是bug。出现这种情况的原因可能是文件名和文件编号是有映射关系的，有可能被系统缓存了。 这也能看出目录内容并不是简单的保存着文件名，文件名和文件编号有映射关系。","link":"/2023/01/12/Linux/5.shell%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%83%E9%99%90%E7%90%86%E8%A7%A3/"},{"title":"Centos更新git","text":"本文讲述如何升级 centos 系统的 git 版本。高版本 git 增加了一些好用的功能，比如”git pull 支持指定项目目录”等。本文以 centos6/7 为例讲解。 升级centos6/7的git版本 安装 git 仓库 1234567# 如果是 CentOS 6 系统就安装这个吧yum install http://opensource.wandisco.com/centos/6/git/x86_64/wandisco-git-release-6-1.noarch.rpm# 如果是 CentOS 7 系统就安装下面两个之一吧yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm# 或者yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm 安装新版本git ​ yum install git 升级 centos7 的 git 版本 卸载旧版本 git yum remove git 安装 git 仓库 1rpm -ivh http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm 安装 高版本 git ​ yum install git -y 完整安装过程如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[root@VM-4-9-centos ~]# rpm -ivh http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpmRetrieving http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpmwarning: /var/tmp/rpm-tmp.bg3oRZ: Header V4 DSA/SHA1 Signature, key ID 3bbf077a: NOKEYPreparing... ################################# [100%]Updating / installing... 1:wandisco-git-release-7-1 ################################# [100%][root@VM-4-9-centos ~]# yum install git -yLoaded plugins: fastestmirror, langpacksRepository epel is listed more than once in the configurationLoading mirror speeds from cached hostfileWANdisco-git | 2.9 kB 00:00:00 WANdisco-git/7/x86_64/primary_db | 153 kB 00:00:01 Resolving Dependencies--&gt; Running transaction check---&gt; Package git.x86_64 0:2.31.1-1.WANdisco.469 will be installed--&gt; Processing Dependency: perl-Git = 2.31.1-1.WANdisco.469 for package: git-2.31.1-1.WANdisco.469.x86_64--&gt; Processing Dependency: perl(Git) for package: git-2.31.1-1.WANdisco.469.x86_64--&gt; Processing Dependency: perl(Digest::SHA) for package: git-2.31.1-1.WANdisco.469.x86_64--&gt; Processing Dependency: perl(Git::I18N) for package: git-2.31.1-1.WANdisco.469.x86_64--&gt; Running transaction check---&gt; Package perl-Digest-SHA.x86_64 1:5.85-4.el7 will be installed--&gt; Processing Dependency: perl(Digest::base) for package: 1:perl-Digest-SHA-5.85-4.el7.x86_64---&gt; Package perl-Git.noarch 0:2.31.1-1.WANdisco.469 will be installed--&gt; Running transaction check---&gt; Package perl-Digest.noarch 0:1.17-245.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================================================Installing: git x86_64 2.31.1-1.WANdisco.469 WANdisco-git 8.7 MInstalling for dependencies: perl-Digest noarch 1.17-245.el7 os 23 k perl-Digest-SHA x86_64 1:5.85-4.el7 os 58 k perl-Git noarch 2.31.1-1.WANdisco.469 WANdisco-git 23 kTransaction Summary=====================================================================================================================================================================Install 1 Package (+3 Dependent packages)Total download size: 8.8 MInstalled size: 41 MDownloading packages:(1/4): perl-Digest-1.17-245.el7.noarch.rpm | 23 kB 00:00:00 (2/4): perl-Digest-SHA-5.85-4.el7.x86_64.rpm | 58 kB 00:00:00 warning: /var/cache/yum/x86_64/7/WANdisco-git/packages/perl-Git-2.31.1-1.WANdisco.469.noarch.rpm: Header V4 DSA/SHA1 Signature, key ID 3bbf077a: NOKEY --:--:-- ETA Public key for perl-Git-2.31.1-1.WANdisco.469.noarch.rpm is not installed(3/4): perl-Git-2.31.1-1.WANdisco.469.noarch.rpm | 23 kB 00:00:00 (4/4): git-2.31.1-1.WANdisco.469.x86_64.rpm | 8.7 MB 00:00:03 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------Total 2.6 MB/s | 8.8 MB 00:00:03 Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-WANdiscoImporting GPG key 0x3BBF077A: Userid : &quot;WANdisco (http://WANdisco.com - We Make Software Happen...) &lt;software-key@wandisco.com&gt;&quot; Fingerprint: 69c1 be83 da54 cbed 6889 72f8 e9f0 e922 3bbf 077a From : /etc/pki/rpm-gpg/RPM-GPG-KEY-WANdiscoRunning transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum. Installing : perl-Digest-1.17-245.el7.noarch 1/4 Installing : 1:perl-Digest-SHA-5.85-4.el7.x86_64 2/4 Installing : git-2.31.1-1.WANdisco.469.x86_64 3/4 Installing : perl-Git-2.31.1-1.WANdisco.469.noarch 4/4 Verifying : perl-Git-2.31.1-1.WANdisco.469.noarch 1/4 Verifying : perl-Digest-1.17-245.el7.noarch 2/4 Verifying : 1:perl-Digest-SHA-5.85-4.el7.x86_64 3/4 Verifying : git-2.31.1-1.WANdisco.469.x86_64 4/4 Installed: git.x86_64 0:2.31.1-1.WANdisco.469 Dependency Installed: perl-Digest.noarch 0:1.17-245.el7 perl-Digest-SHA.x86_64 1:5.85-4.el7 perl-Git.noarch 0:2.31.1-1.WANdisco.469 Complete![root@VM-4-9-centos ~]# git --versiongit version 2.31.1 参考文章： centos 6.x/7.x 使用 yum 升级 git 版本 (opens new window)。","link":"/2023/01/12/Linux/Centos7.6%E6%9B%B4%E6%96%B0git/"},{"title":"Centos7.6安装vim配置","text":"简介帮助对vim配置方法不熟悉的新手封装的一键式vim环境安装包. 主要针对终端vim用户, 适合远程ssh连接Linux服务器进行开发的场景(例如使用阿里云服务器或者腾讯云服务器等). 特点 安装速度快(使用码云而不是github作为源). 网络畅通情况下, 几分钟内完成 vim 插件安装. 无需编译直接使用 YouCompleteMe(直接下载预编译好的 ycm_core.so). 一键式安装. 真正做到一键式安装. 不光能一键式安装 Vim 配置, 同时也会安装依赖的程序(包括 git, neovim, ctags等) 支持环境目前只支持 Centos7 x86_64. 安装方法在 shell 中执行指令(想在哪个用户下让vim配置生效, 就在哪个用户下执行这个指令. 强烈 “不推荐” 直接在 root 下执行): 1curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh &amp;&amp; bash ./install.sh 需要按照提示输入 root 密码. 您的 root 密码不会被上传, 请放心输入. 卸载方法在安装了 VimForCpp 的用户下执行: 1bash ~/.VimForCpp/uninstall.sh","link":"/2023/01/12/Linux/Centos7.6%E5%AE%89%E8%A3%85vim%E9%85%8D%E7%BD%AE/"},{"title":"Centos7.x将Python2升级到Python3.x","text":"查看Python版本1python -V 更新yum源1yum update 安装依赖12yum install yum-utilsyum-builddep python3 下载python1wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz 安装Python相关依赖1yum -y install zlib-devel bzip2-devel openssl-devel ncursesdevelsqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 安装c，c++已经安装可跳过此步骤。 1yum -y install gcc g++ 创建安装目录1mkdir /usr/local/python3 解压1tar xf Python-3.8.5.tgz 编译12345cd Python-3.8.5/# 配置安装目录./configure --prefix=/usr/local/python3# 编译make 安装1make install 创建软链接123ln -s /usr/local/python3/bin/python3 /usr/bin/python# 注意这样是修改Python3为默认，那么这样还需要修改yum配置，后面会提到ln -s /usr/local/python3/bin/pip3 /usr/bin/pip 完成12python3 -Vpip3 -V 更改yum配置(非必要)取决于你是否将python3设置为了默认，如果是可以执行下面操作。 因为yum要用到python2.x，否则会导致yum不能正常使用（不管安装 python3的那个版本，都必须要做的） 1234vim /usr/bin/yum 把 #! /usr/bin/python 修改为 #! /usr/bin/python2vim /usr/libexec/urlgrabber-ext-down 把 #! /usr/bin/python 修改为 #! /usr/bin/python2","link":"/2023/01/12/Linux/Centos7.x%E5%B0%86Python2%E5%8D%87%E7%BA%A7%E5%88%B0Python3/"},{"title":"Centos7.x安装Python3","text":"安装相应的编译工具建议在root下操作，会方便很多，一定要安装，否则编译安装会报错。 1234yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-develyum install -y libffi-develyum install zlib* -y 1yum install yum-utils 下载安装包1wget https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tar.xz 解压1tar -xvJf Python-3.9.12.tar.xz 创建编译安装目录1mkdir /usr/local/python3 安装12345cd Python-3.7.2./configure --prefix=/usr/local/python3 --enable-optimizations --with-ssl#第一个指定安装的路径,不指定的话,安装过程中可能软件所需要的文件复制到其他不同目录,删除软件很不方便,复制软件也不方便.#第二个可以提高python10%-20%代码运行速度.make &amp;&amp; make install 在python3.8后，使用enable-optimizations 这个参数在服务器使用的是低版本的gcc时会报错，不过好像是个概率事件，不一定会成功。有三个处理方法： 可以先升级gcc 不加–enable-optimizations 参考链接：https://stackoverflow.com/questions/41405728/what-does-enable-optimizations-do-while-compiling-python 创建软链接相当于windows环境变量，如下写不会默认还是Python2.7，不需要修改yum配置。 1234ln -sf /usr/local/python3/bin/python3.7 /usr/local/bin/python3# 软链接至/bin/python3方便写脚本ln -s /usr/local/python3/bin/python3.7 /bin/python3ln -sf /usr/local/python3/bin/pip3 /usr/local/bin/pip3 如果建立时提示如下报错信息： 1ln: failed to create symbolic link '/usr/bin/python3': File exists 解决方法： ln -sf 即参数多加个f即可 1ln -sf /usr/local/python3/bin/python3.9 /bin/python3 验证是否成功12python3 -Vpip3 -V 报错处理错误1. 1Could not import runpy module 需要安装依赖 121. 可以先升级gcc2. 不加--enable-optimizations 错误2. 1ModuleNotFoundError: No module named '_ctypes' 需要安装依赖 1yum -y install libffi-devel 这两个错误需要的依赖已经添加到一开始的依赖安装上去了。 参考文章 安装pipenv在centos中使用python3.7或以上版本,进行pip install 命令容易报错 123pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available.Could not fetch URL https:*******: There was a problem confirming the ssl certificate: Can't connect to HTTPS URL because the SSL module is not available. - skipping 在./configure过程中，如果没有加上–with-ssl参数时，默认安装的软件涉及到ssl的功能不可用，刚好pip3过程需要ssl模块，而由于没有指定，所以该功能不可用。解决办法是重新对python3进行编译安装，用一下过程来实现编译安装: 123cd Python-3.7.2./configure --with-sslmake &amp;&amp; make install 即可正常使用pip安装.这个也在安装python的时候指定了. 修改pip安装源修改系统pip安装源在家目录下新建.pip文件夹,进入文件夹新建文件pip.conf之后写入相应镜像网站地址 12345678cd ~mkdir .pipcd .pipvim pip.conf#进入后添加以下内容,保存退出.[global]index-url = https://mirrors.aliyun.com/pypi/simple 修改pipenv安装源在自己的虚拟环境中找到Pipfile文件,将其中的url = “https://pypi.org/simple&quot;修改为你需要的国内镜像,如https://mirrors.aliyun.com/pypi/simple/ 1234567891011121314[root@localhost myproject]# vim Pipfile [[source]]name = &quot;pypi&quot;url = &quot;https://pypi.org/simple&quot; # 改为url = &quot;https://mirrors.aliyun.com/pypi/simple/&quot;verify_ssl = true[dev-packages] #这里是开发环境专属包,使用pipenv install --dev package来安装专属开发环境的包[packages] # 全部环境的通用包,安装在这里.[requires]python_version = &quot;3.7&quot;","link":"/2023/01/12/Linux/Centos7.x%E5%AE%89%E8%A3%85Python3%EF%BC%88%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%89/"},{"title":"Centos升级gcc","text":"不建议贸然升级，时间是比较久的并且容易出现一系列问题。 升级GCC版本到11.1GCC11终于发正式版了, 4月底官方终于发了11.1正式版. 对于我们来说, 项目实际使用基于C++17的协程已经有段时间, stackless在没有compiler额外生成代码Buff的加持下, Stack变量的人肉处理, 花括号对代码的隔离, 还是会导致一些额外的工作量, 便利性上不那么完美. 既然GCC11.1已经发了, 我们之前的GCC8.3也在正常工作中, 升级成本比我们想象的低, 那新版到来, 又能解决项目的一些实际痛点, 升级的动力自然就比较足了. 下载GCC11.1源码 GCC的源码仓库地址为: https://github.com/gcc-mirror/gcc ,在浏览器打开这个网址后，不要急于下载，先选择gcc的版本，如下图所示： 如上图所示找到GCC11.1,并点击 “releases/gcc-11.1.0”完成仓库的切换, 然后直接在网页上下载zip包, 自行上传至服务器后解压. 1unzip gcc-releases-gcc-11.1.0.zip 也可以通过直接git clone的方式来拉取对应的gcc源码, 进入自己的home目录执行如下命令: 1git clone --branch releases/gcc-11.1.0 https://github.com/gcc-mirror/gcc.git 两种方式效果一样, 获取到源代码后, 将当前目录切换到GCC源码根目录, 进入下一步. 源码目录如下图所示: 安装依赖库 新的GCC源码内置了依赖库的获取脚本, GCC所依赖的mpfr, gmp, mpc, isl都可以使用内置脚本直接获取, 比老版本简单非常多, 在GCC目录下, 执行: 1./contrib/download_prerequisites 此命名会自动下载GCC编译需要的几个依赖库. 配置和编译 前文也提到了, 我们需要同时保留老版本的GCC, 所以配置项里需要指定安装的目录, 配置命令如下 : 1./configure --prefix=/usr/local/gcc-11.1.0 --enable-bootstrap --enable-languages=c,c++ --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib 我们仅会使用GCC做C与C++的编译, 所以此处语言也仅选择了这两者. 配置完成后, 我们进入编译安装阶段. 此处可以直接打开并行编译执行make命令, 比如笔者机器是2核的, 此处直接将并发数设置为4进行编译, 实测效果不错. 1make -j4 记得一定要root权限, 不然可能会因为权限不足安装失败. 12sudo -smake install 这时整个gcc的安装过程已经成功执行完成, 按如下方法测试GCC是否正确安装: 1/usr/local/gcc-11.1.0/bin/gcc --version 得到上图的输出, 则GCC11.1已经成功安装. CMake中的使用, ABI兼容问题 请参考 升级GCC到8.3 中的相关部分. LD_LIBRARY_PATH的问题 如果代码没有全部切换到11.1, 那我们还需要额外的一步操作才能让gcc11.1编译出的程序正常的运行: 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gcc-11.1.0/lib64 可以直接将本行追加到/.bashrc, 避免每次都单独写shell脚本追加该项. 注意更改/.bashrc后记得重新连接终端, 让修改生效. 如果同时也添加了gcc-8.3.0, 注意gcc-11.1.0的export要在8.3.0之前, 否则还是会报LD相关的问题. GDB的问题GCC11.1开始, 要求使用支持C++11的编译器进行编译, 可能是由于这个改变, 生成的App可以正常运行, 但不能挂接GDB, 表现是用GDB启动生成的App就直接Crash, 报Segment Fault. 我们需要升级GDB到较新的版本, 就能解决该问题(具体出错的原因没有细查). 升级方法很简单: 到GNU官网下载比较新的GDB源码包并解压并编译安装, 笔者使用的shell是: 123456wget http://ftp.gnu.org/gnu/gdb/gdb-10.2.tar.gztar -zxf gdb-10.2.tar.gzcd gdb-10.2./configuremake -j4sudo make install 默认安装的路径是/usr/local/bin, 并不会覆盖老的GDB(老的在/usr/bin/下), 所以使用VSCode或者自行运行的时候, 需要正确指定一下GDB的版本, 检查GDB的版本 小结 至此我们已经完成了GCC11.1的安装和相关环境的适配, 就笔者项目而言, 近期主要会用到的特性如下: C++20的coroutine concept(预计可以比较好的简化反射相关的代码) modules 参考文章： 升级GCC版本到11.1 - 云+社区 - 腾讯云","link":"/2023/01/12/Linux/Centos7%E5%8D%87%E7%BA%A7gcc/"},{"title":"Hexo-Butterfly主题配置","text":"主题安装 稳定版【建议】 在你的 Hexo 根目录里 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 测试版 测试版可能存在 bug，追求稳定的请安装稳定版 如果想要安装比较新的 dev 分支，可以 1git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 升级方法：在主题目录下，运行 git pull 应用主题修改 Hexo 根目录下的 _config.yml，把主题改为butterfly 1theme: butterfly 安装插件如果你没有 pug 以及 stylus 的渲染器，请下载安装： 1npm install hexo-renderer-pug hexo-renderer-stylus --save 升级建议为了减少升级主题后带来的不便，请使用以下方法（建议，可以不做）。 在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复制到 _config.butterfly.yml 去。( 注意: 复製的是主题的 _config.yml ,而不是 hexo 的 _config.yml) 注意：不要把主题目录的_config.yml 删掉 注意： 以后只需要在 _config.butterfly.yml进行配置就行。如果使用了 _config.butterfly.yml， 配置主题的 _config.yml 将不会有效果。 Hexo会自动合并主题中的_config.yml和 _config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。 语言修改站点配置文件 _config.yml 默认语言是 en 主题支持三种语言 default(en) zh-CN (简体中文) zh-TW (繁体中文) 网站资料修改网站各种资料，例如标题、副标题和邮箱等个人资料，请修改博客根目录的_config.yml 导航菜单123456789Home: / || fas fa-homeArchives: /archives/ || fas fa-archiveTags: /tags/ || fas fa-tagsCategories: /categories/ || fas fa-folder-openList||fas fa-list: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-videoLink: /link/ || fas fa-linkAbout: /about/ || fas fa-heart 必须是 /xxx/，后面||分开，然后写图标名。 如果不希望显示图标，图标名可不写。 默认子目录是展开的，如果你想要隐藏，在子目录里添加 hide 。 123List||fas fa-list||hide: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-video 注意：导航的文字可自行修改。 例如： 1234567891011menu: 首页: / || fas fa-home 时间轴: /archives/ || fas fa-archive 标籤: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open 清单||fa fa-heartbeat: 音乐: /music/ || fas fa-music 照片: /Gallery/ || fas fa-images 电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link 关于: /about/ || fas fa-heart 代码 代码块中的所有功能只适用于 Hexo 自带的代码渲染 如果使用第三方的渲染器，不一定会有效 代码高亮主题Butterfly 支持6种代码高亮样式： darker pale night light ocean mac mac light 修改 主题配置文件 1highlight_theme: mac 代码复制主题支持代码复制功能 修改 主题配置文件 1highlight_copy: true 代码框展开/关闭在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击&gt;可展开代码 true 全部代码框不展开，需点击&gt;打开 false 代码框展开，有&gt;点击按钮 none 不显示&gt;按钮 修改 主题配置文件 1highlight_shrink: true #代码框不展开，需点击 '&gt;' 打开 你也可以在post/page页对应的markdown文件front-matter添加highlight_shrink来独立配置。 当主题配置文件中的 highlight_shrink 设为true时，可在front-matter添加highlight_shrink: false来单独配置文章展开代码框。 当主题配置文件中的 highlight_shrink 设为false时，可在front-matter添加highlight_shrink: true来单独配置文章收缩代码框。 代码换行在默认情况下，Hexo 在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。 修改 主题配置文件 1code_word_wrap: true 如果你是使用 highlight 渲染，需要找到你站点的 Hexo 配置文件_config.yml，将line_number改成false: 12345highlight: enable: true line_number: false # &lt;- 改这里 auto_detect: false tab_replace: 设置code_word_wrap之后代码框内比较长的部分会自动换行，而不会有横向滚动条出现。 代码高度限制 3.7.0 及以上支持 可配置代码高度限制，超出的部分会隐藏，并显示展开按钮。 1highlight_height_limit: false # unit: px 注意： 单位是 px，直接添加数字，如 200 实际限制高度为 highlight_height_limit + 30 px ，多增加 30px 限制，目的是避免代码高度只超出highlight_height_limit 一点时，出现展开按钮，展开没内容。 不适用于隐藏后的代码块（ css 设置 display: none） 社交图标Butterfly支持 font-awesome v6图标. 书写格式 图标名：url || 描述性文字 123social: fab fa-github: https://github.com/sxfinn || Github fas fa-envelope: mailto:sxnicoa@gmail.com || Email 主页文章节选(自动节选和文章页description)因为主题UI的关係，主页文章节选只支持自动节选和文章页description。 在butterfly里，有四种可供选择 description： 只显示description both： 优先选择description，如果没有配置description，则显示自动节选的内容 auto_excerpt：只显示自动节选 false： 不显示文章内容 修改 主题配置文件 123index_post_content: method: 3 length: 500 # if you set method to 2 or 3, the length need to config description在front-matter里添加 顶部图配置中的值： 配置 解释 index_img 主页的 top_img default_top_img 默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img archive_img 归档页面的 top_img tag_img tag 子页面 的 默认 top_img tag_per_img tag 子页面的 top_img，可配置每个 tag 的 top_img category_img category 子页面 的 默认 top_img category_per_img category 子页面的 top_img，可配置每个 category 的 top_img 其它页面 （tags/categories/自建页面）和 文章页 的 top_img ，请到对应的 md 页面设置front-matter中的top_img 以上所有的 top_img 可配置以下值 3.2.0 以下版本的配置只支持 留空，true 和 false - 显示默认的顔色 img链接 - 显示所配置的图片 配置的值 效果 留空 显示默认的top_img（如有），否则显示默认的顔色（文章页top_img留空的话，会显示 cover 的值） img链接 图片的链接，显示所配置的图片 顔色(HEX值 - #0000FFRGB值 - rgb(0,0,255)顔色单词 - orange渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)） 对应的顔色 transparent 透明 false 不显示 top_img tag_per_img 和 category_per_img 是 3.2.0 新增的内容，可对 tag 和 category 进行单独的配置 并不推荐为每个 tag 和每个 category 都配置不同的顶部图，因为配置太多会拖慢生成速度 1234567tag_per_img： aplayer: https://xxxxxx.png android: ddddddd.png category_per_img： 随想: hdhdh.png 推荐: ddjdjdjd.png 文章置顶【推荐】hexo-generator-index从 2.0.0 开始，已经支持文章置顶功能。你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。 文章封面文章的markdown文档上,在Front-matter添加cover,并填上要显示的图片地址。如果不配置cover,可以设置显示默认的cover. 如果不想在首页显示cover,可以设置为false 修改 主题配置文件 12345678910cover: # 是否显示文章封面 index_enable: true aside_enable: true archives_enable: true # 封面显示的位置 # 三个值可配置 left , right , both position: both # 当没有设置cover时，默认的封面显示 default_cover: 当配置多张图片时,会随机选择一张作为cover.此时写法应为 1234default_cover: - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png 文章页相关设置文章meta显示这个选项是用来显示文章的相关信息的。 修改 主题配置文件 12345678910111213post_meta: page: date_type: both # created or updated or both 主页文章日期是创建日或者更新日或都显示 date_format: relative # date/relative 显示日期还是相对日期 categories: true # true or false 主页是否显示分类 tags: true # true or false 主页是否显示标籤 label: true # true or false 显示描述性文字 post: date_type: both # created or updated or both 文章页日期是创建日或者更新日或都显示 date_format: relative # date/relative 显示日期还是相对日期 categories: true # true or false 文章页是否显示分类 tags: true # true or false 文章页是否显示标籤 label: true # true or false 显示描述性文字 文章版权为你的博客文章展示文章版权和许可协议。 修改 主题配置文件 123456post_copyright: enable: true decode: false author_href: license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 由于Hexo 4.1开始，默认对网址进行解码，以至于如果是中文网址，会被解码，可设置decode: true来显示中文网址。 如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置 1copyright: false 从3.0.0开始，支持对单独文章设置版权信息，可以在文章Front-matter单独设置 1234copyright_author: xxxxcopyright_author_href: https://xxxxxx.comcopyright_url: https://xxxxxx.comcopyright_info: 此文章版权归xxxxx所有，如有转载，请註明来自原作者 文章打赏在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置。 对于没有提供二维码的，可配置一张软件的icon图片，然后在link上添加相应的打赏链接。用户点击图片就会跳转到链接去。 link可以不写，会默认为图片的链接。 修改 主题配置文件 123456789reward: enable: true QR_code: - img: /img/wechat.jpg link: text: 微信 - img: /img/alipay.jpg link: text: 支付宝 TOC在文章页，会有一个目录，用于显示TOC。 修改 主题配置文件 123456toc: post: true page: false number: true expand: false style_simple: false # for post 属性 解释 post 文章页是否显示 TOC page 普通页面是否显示 TOC number 是否显示章节数 expand 是否展开TOC style_simple 简介模式啊（侧边栏只显示TOC，只对文章页有效） 为特定的文章配置在你的文章md文件的头部，加入toc_number和toc，并配置true或者false即可。 主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为準。否则，以主题配置文件中的配置为准 相关文章相关文章推荐的原理是根据文章tags的比重来推荐 修改 主题配置文件 1234related_post: enable: true limit: 6 # 显示推荐文章数目 date_type: created # or created or updated 文章日期显示创建日或者更新日 文章锚点开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题ID进行替换(注意: 每替换一次，会留下一个歷史记录。所以如果一篇文章有很多锚点的话，网页的歷史记录会很多。) 修改 主题配置文件 123# anchor# when you scroll in post , the url will update according to header id.anchor: true 文章过期提醒可设置是否显示文章过期提醒，以更新时间为基准。 12345678# Displays outdated notice for a post (文章过期提醒)noticeOutdate: enable: true style: flat # style: simple/flat limit_day: 365 # When will it be shown position: top # position: top/bottom message_prev: It has been message_next: days since the last update, the content of the article may be outdated limit_day： 距离更新时间多少天才显示文章过期提醒 message_prev ： 天数之前的文字 message_next：天数之后的文字 文章编辑按钮在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。 1234567# Post edit# Easily browse and edit blog source code online.post_edit: enable: false # url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/ # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/ url: 文章分页按钮可设置分页的逻辑，也可以关闭分页显示 123456# post_pagination (分页)# value: 1 || 2 || false# 1: The 'next post' will link to old post# 2: The 'next post' will link to new post# false: disable paginationpost_pagination: false 参数 解释 post_pagination: false 关闭分页按钮 post_pagination: 1 下一篇显示的是旧文章 post_pagination: 2 下一篇显示的是新文章 头像修改 主题配置文件 123avatar: img: /img/avatar.png effect: true # 头像会一直转圈 图片描述可开启图片Figcaption描述文字显示 优先显示图片的 title 属性，然后是 alt 属性 修改 主题配置文件 1photofigcaption: true 复制相关配置可配置网站是否可以复製、复製的内容是否添加版权信息 1234567# copy settings# copyright: Add the copyright information after copied content (复製的内容后面加上版权信息)copy: enable: true copyright: enable: true limit_count: 50 配置 解释 enable 是否开启网站复制权限 copyright 复制的内容后面加上版权信息 enable 是否开启复复制版权信息添加 limit_count 字数限制，当复制文字大于这个字数限制时，将在复製的内容后面加上版权信息 Footer设置博客年份since是一个来展示你站点起始时间的选项。它位于页面的最底部。 修改 主题配置文件 1234footer: owner: enable: true since: 2018 页脚自定义文本custom_text是一个给你用来在页脚自定义文本的选项。通常你可以在这里写声明文本等。支持 HTML。 修改 主题配置文件 1custom_text: Hi, welcome to my &lt;a href=&quot;https://butterfly.js.org/&quot;&gt;blog&lt;/a&gt;! 对于部分人需要写 ICP 的，也可以写在 custom_text里 1custom_text: &lt;a href=&quot;icp链接&quot;&gt;&lt;img class=&quot;icp-icon&quot; src=&quot;icp图片&quot;&gt;&lt;span&gt;备案号：xxxxxx&lt;/span&gt;&lt;/a&gt; 右下角按钮简繁互换简体繁体互换 右下角会有简繁转换按钮。 修改 主题配置文件 123456789101112translate: enable: true # 默认按钮显示文字(网站是简体，应设置为'default: 繁') default: 简 #网站默认语言，1: 繁体中文, 2: 简体中文 defaultEncoding: 1 #延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0 translateDelay: 0 #当文字是简体时，按钮显示的文字 msgToTraditionalChinese: &quot;繁&quot; #当文字是繁体时，按钮显示的文字 msgToSimplifiedChinese: &quot;简&quot; 夜间模式右下角会有夜间模式按钮 修改 主题配置文件 123456# dark modedarkmode: enable: true # dark mode和 light mode切换按钮 button: true autoChangeMode: false V2.0.0 开始增加一个选项，可开启自动切换light mode 和 dark mode autoChangeMode: 1 跟随系统而变化，不支持的浏览器/系统将按照时间晚上6点到早上6点之间切换为 dark mode autoChangeMode: 2 只按照时间 晚上6点到早上6点之间切换为 dark mode,其余时间为light mode autoChangeMode: false 取消自动切换 阅读模式阅读模式下会去掉除文章外的内容，避免干扰阅读。 只会出现在文章页面，右下角会有阅读模式按钮。 修改 主题配置文件 1readmode: true 按钮排序1234567# Don't modify the following settings unless you know how they work (非必要请不要修改 )# Choose: readmode,translate,darkmode,hideAside,toc,chat,comment# Don't repeat 不要重复rightside_item_order: enable: false hide: # readmode,translate,darkmode,hideAside show: # toc,chat,comment 侧边栏设置侧栏排版可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。 修改 主题配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243aside: enable: true hide: false button: true mobile: true # 手机页面（ 显示宽度 &lt; 768px ）是否显示aside内容 position: right # left or right display: archive: true tag: true category: true card_author: enable: true description: button: enable: true icon: fab fa-github text: Github link: https://github.com/jerryc127/hexo-theme-butterfly card_announcement: enable: true content: This is my Blog card_recent_post: enable: true limit: 5 # if set 0 will show all sort: date # date or updated card_categories: enable: true limit: 8 # if set 0 will show all expand: none # none/true/false card_tags: enable: true limit: 40 # if set 0 will show all color: false card_archives: enable: true type: monthly # yearly or monthly format: MMMM YYYY # eg: YYYY年MM月 order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending limit: 8 # if set 0 will show all card_webinfo: enable: true post_count: true last_push_date: true 访问人数访问 busuanzi 的官方网站查看更多的介绍。 修改 主题配置文件 1234busuanzi: site_uv: true site_pv: true page_pv: true 运行时间网页已运行时间 修改 主题配置文件 123456runtimeshow: enable: true publish_date: 6/7/2018 00:00:00 ##网页开通时间 #格式: 月/日/年 时间 #也可以写成 年/月/日 时间 最新评论 3.1.0 起支持 最新评论只会在刷新时才会去读取，并不会实时变化 由于 API 有 访问次数限制，为了避免调用太多，主题默认存取期限为 10 分鐘。也就是説，调用后资料会存在 localStorage 里，10分鐘内刷新网站只会去 localStorage 读取资料。 10 分鐘期限一过，刷新页面时才会去调取 API 读取新的数据。（ 3.6.0 新增了 storage 配置，可自行配置缓存时间） 在侧边栏显示最新评论板块 修改 主题配置文件 1234567# Aside widget - Newest Commentsnewest_comments: enable: true sort_order: # Don't modify the setting unless you know how it works limit: 6 storage: 10 # unit: mins, save data to localStorage avatar: true 部分配置解释 配置 解释 limit 显示的数量 storage 设置缓存时间，单位：分钟 avatar 是否显示头像 自定义添加栏目搜索系统本地搜索 记得运行 hexo clean 你需要安装wzpan/hexo-generator-search：为 Hexo 生成搜索数据的插件。，根据他的相应文档做相应配置。 修改 主题配置文件 1234local_search: enable: true preload: false CDN: 参考文章： Butterfly - A Simple and Card UI Design theme for Hexo","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"Centos更新yum源","text":"查看当前的 yum 源1yum repolist 对CentOS-Base.repo进行备份1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 使用阿里云源替换本地源1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 清除yum缓存并更新12yum clean allyum makecache 安装epel源12yum list | grep epel-release yum install -y epel-release 使用阿里开源镜像提供的epel源1wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo 再次清除系统yum缓存，并重新生成新的yum缓存12yum clean allyum makecache 查看新 yum 源12yum repolist enabledyum repolist all tips如果在yum makecache的过程中一直报：Another app is currently holding the yum lock; waiting for it to exit…不必慌张，输入以下命令即可 1rm -f /var/run/yum.pid","link":"/2023/01/12/Linux/Centos7%E6%9B%B4%E6%96%B0yum%E6%BA%90/"},{"title":"Linux更换镜像源","text":"UbuntuUbuntu 打开并修改 /etc/apt/sources.list 文件即可 通用源: 1234567891011121314deb mirror://mirrors.ubuntu.com/mirrors.txt focal main restricted universe multiversedeb-src mirror://mirrors.ubuntu.com/mirrors.txt focal main restricted universe multiversedeb mirror://mirrors.ubuntu.com/mirrors.txt focal-updates main restricted universe multiversedeb-src mirror://mirrors.ubuntu.com/mirrors.txt focal-updates main restricted universe multiversedeb mirror://mirrors.ubuntu.com/mirrors.txt focal-security main restricted universe multiversedeb-src mirror://mirrors.ubuntu.com/mirrors.txt focal-security main restricted universe multiversedeb mirror://mirrors.ubuntu.com/mirrors.txt focal-backports main restricted universe multiversedeb-src mirror://mirrors.ubuntu.com/mirrors.txt focal-backports main restricted universe multiversedeb http://archive.canonical.com/ubuntu focal partnerdeb-src http://archive.canonical.com/ubuntu focal partner 阿里源： 1234567891011deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse focal Debian阿里源： 12345678deb mirrors.aliyun.com/debi stretch main non-free contribdeb-src mirrors.aliyun.com/debi stretch main non-free contribdeb mirrors.aliyun.com/debi stretch/updates maindeb-src mirrors.aliyun.com/debi stretch/updates maindeb mirrors.aliyun.com/debi stretch-updates main non-free contribdeb-src mirrors.aliyun.com/debi stretch-updates main non-free contribdeb mirrors.aliyun.com/debi stretch-backports main non-free contribdeb-src mirrors.aliyun.com/debi stretch-backports main non-free contrib Debian 官方全球镜像站列表地址： https://www.debian.org/mirror/list CentOSCentOS 打开并修改 /etc/yum.repos.d/CentOS-Base.repo 文件 阿里源CentOS61wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo CentOS71wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 官方源Centos6123456cd /etc/yum.repos.d/rm -rf CentOS-*rpm -Uvh --force https://vault.centos.org/6.10/os/x86_64/Packages/centos-release-6-10.el6.centos.12.3.x86_64.rpmyum clean allyum makecacheyum update -y Centos7123456cd /etc/yum.repos.d/rm -rf CentOS-*rpm -Uvh --force http://mirror.centos.org/centos-7/7.9.2009/os/x86_64/Packages/centos-release-7-9.2009.0.el7.centos.x86_64.rpmyum clean allyum makecacheyum update -y Centos8123456cd /etc/yum.repos.d/rm -rf CentOS-*rpm -Uvh --force http://mirror.centos.org/centos-8/8/BaseOS/x86_64/os/Packages/centos-linux-release-8.3-1.2011.el8.noarch.rpmyum clean allyum makecacheyum update -y 一键脚本Github 仓库地址： https://github.com/SuperManito/LinuxMirrors GNU/Linux 一键更换国内软件源脚本 本项目旨在为从事计算机相关行业的朋友们提供便利 理论支持所有架构的环境，arm64 环境已经过测试 一键脚本： 1bash &lt;(curl -sSL https://cdn.jsdelivr.net/gh/SuperManito/LinuxMirrors@main/ChangeMirrors.sh) 更新最后别忘了更新，这才是我们换源的目的，不是吗？ Ubuntu12apt update -yapt-get update -y &amp;&amp; apt-get install curl -y CentOS12yum update -y yum update -y &amp;&amp; yum install curl -y","link":"/2023/01/12/Linux/Linux%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90/"},{"title":"Hexo博客文章唯一链接","text":"Hexo的默认文章链接格式是年，月，日，标题这种格式来生成的。如果你的标题是中文的话，那你的URL链接就会包含中文。 复制后的URL路径就是把中文变成了一大堆字符串编码，如果你在其他地方用这边文章的url链接，偶然你又修改了改文章的标题，那这个URL链接就会失效。为了给每一篇文章来上一个属于自己的链接，写下此教程，利用 hexo-abbrlink 插件，A Hexo plugin to generate static post link based on post titles ,来解决这个问题。 参考github官方： hexo-abbrlink 按照此教程配置完之后如下： 安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令： 1npm install hexo-abbrlink --save 修改 config.yml 文件中的永久链接： 123permalink: posts/:abbrlink/ # orpermalink: posts/:abbrlink.html 有两种设置： 12alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)rep -- Represent (the generated link could be presented in hex or dec value) 例如： 1234# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex 最终生成的文章名是根据文章的发布时间戳生成的。 参考文章： rozbo/hexo-abbrlink: create one and only link for every post for hexo","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%94%AF%E4%B8%80%E9%93%BE%E6%8E%A5/"},{"title":"WordPress固定链接(伪静态)的设置方法及建议设置","text":"WordPress 是一个 CMS 管理系统，也就是说，WordPress 的文章、页面、存档页都是通过程序从数据库里面获取数据生成的。虽然 WordPress 的页面可以有千千万万个，但是我们访问这些页面的入口只有一个，那就是根目录的「index.php」，我们访问一个页面时，其实访问的就是「inxdex.php」这个文件，然后这个文件根据全局变量和页面的一些参数，从数据库中获取数据、生成页面，最终发送给我们。 为什么要设置伪静态默认安装环境下，我们访问 WordPress 文章页的 URL 地址为 https://exaple.com/index.php?p=123，这个 URL 中，example.com 是我们的域名，“index.php” 就是我们上面说到的 WordPress 页面入口文件，?p=123 是这个 URL 的参数，其中 123 为页面 ID，index.php 就是根据这个页面 ID 从 WordPress 数据库中获取页面内容，生成页面展示给我们的。 怎么去掉 index.php为了让 URL 更好看一些，对 SEO 更友好一些，很多朋友都会想把这个 index.php 去掉，怎么办到呢？很简单，在 WordPress 的「设置 &gt; 固定链接」设置中选择除了「朴素」之外的其他选项就可以了，保存之后，我们就为 WordPress 开启了伪静态设置。 为了让 URL 更具语义，我们建议选择「文章名」的 URL 结构，如果你不想让 URL 中出现中文，可以使用我们开发的 Wenprise Pinyin Slug 插件自动把 URL 中的中文转换为拼音或英文名。 Apache、Nginx、IIS 等服务器对伪静态的支持做了固定链接设置之后，可能有朋友发现，自己的网站，除了首页，其他页面都打不开了，这是因为你的服务器没有配置对 URL 重定向（也就是伪静态的支持），我们需要为服务器打开 URL 重定向支持。 Nginx 伪静态规则根据我们所了解到的情况，大部分 WordPress 站点现在都是使用的 Nginx 作为 Web 服务器，为 Nginx 添加伪静态设置非常简单，找到您的虚拟主机配置文件，添加以下 Nginx 规则，然后运行 nginx -s reload 重新加载 Nginx 配置就可以了。 1234location / { index index.php index.html index.htm; try_files $uri $uri/ /index.php?$args;} IIS 伪静态规则相信用 IIS 作为 WordPress 的 Web 服务器的朋友不多吧？具体设置方法就不说了，以防万一用得着，把 IIS URL 重定向的设置方法参考链接放到这里好了。 IIS URL Rewrite 模块 Enabling Pretty Permalinks in WordPress Apache 伪静态规则大多数 Apache 服务器都支持使用 .htaccess 文件设置重定向规则，只要您的服务器支持 .htacees 文件，在设置 WordPress 固定链接的时候，WordPress 会自动生成或更新这个文件，不用太多d的设置。 如果您的 Apache 服务器不支持 .htaccess，找管理员提供支持或者参考下面的链接设置即可。 怎么在 Apache 设置设置 htaccess 文件 基本上，支持伪静态设置是每个 WordPress 服务器的基本修养之一，URL 伪静态也是 WordPress SEO 需要做的基本事项之一，每个有追求的 WordPress 站点都要做到。","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/WordPress%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5(%E4%BC%AA%E9%9D%99%E6%80%81)%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8F%8A%E5%BB%BA%E8%AE%AE%E8%AE%BE%E7%BD%AE/"},{"title":"如何挑选博客框架及在线博客平台","text":"转载自 Aegisprogram https://aegisprogram.github.io/2021/07/01/how-to-choose-a-blog/ 在现在这个信息发达的时代，越来越多非程序员出身的人也想要一个自己的博客。目前也诞生了不少的在线博客网站和博客框架，博客大致分为主要分为动态博客和静态博客两大类。其实关于动态博客和静态博客的选择问题，这个问题的看法还是见仁见智。我在这里简单说说两种博客之间的优劣，以及一些比较友好的在线博客网站。 动态博客动态博客，一个运行在服务器上的博客程序，一般提供一个在线的编辑器供使用者在线编写，多数都需要使用 PHP + 数据库。 推荐Wordpress: 十分有名的动态博客框架，几乎有涵盖所有功能的插件，搭建自己的动态博客的首选，全球已经有 40% 的网站使用 wordpress 驱动。 Typecho: 这是在功能性可以和 Wordpress 相媲美的博客框架，但是他的程序本体要比后者更加简洁。 Wix 这是一款以色列的一站式网站创建服务博客框架，不需要了解 DNS 对应、网页编程语言、服务器创建 / 租赁等事务，一切都由 Wix 自动化处理，让用户能专心在网页视觉与内容呈现上，更可以调整手机版的设计及版面。 Halo: 是一款基于 Java 语言，使用 Spring Boot 开发的博客系统，致力于打造最好的 Java 博客系统，比较容易上手。 优势 在线编写比较友好，不需要掌握过多的代码知识。 插件数量多，元素丰富。 响应式网页，交互性比较良好。 不显示后端处理过程，有利于保护自己的源代码 不足 由于使用了数据库和 PHP 等提高了性能，所以消耗的资源比较多。 后端部署较为繁琐，需要日常维护 可免费托管的平台较少 相较于静态博客，动态博客更加容易受到攻击和崩溃。 静态博客所谓静态博客，即通过生成工具（eg： Hexo ； Hugo 等），直接将作者所书写的博文编译成最终的 html；css；js 等静态文件。作者 / 博主，只需将生成的文件部署在静态 server 上面即可被在互联网中访问。 用户通过浏览器访问服务器，直接就回获得已编译的静态资源。比如你现在看到的博客就是基于 Hexo 博客框架部署的静态博客。 推荐Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。不过作者对于该项目的维护不那么积极，估计是要放弃了。 Jekyll 是一个简单的博客形态的静态站点生产机器，是 GitHub 官方推荐部署到 GitHub Pages 的博客框架，可谓是亲儿子。 Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架。Hexo 支持 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hugo 是一种用 Go 语言编写的快速，现代的静态网站生成器，简单、易用、高效、易扩展、快速部署。 优势 没有过多的元素，专注于内容写作。 主题大多都比较简约。 无其他干扰（主要体现在广告比较少） 占用的资源较少，访问速度快，可免费部署的网站多。 可高度定制化，可以自写逻辑，插件等。 不足 需要一定的编程经验才能自定义样式。 插件数量较少。 缺少评论插件，交互式内容比较难以实现。 数学公式的支持不是很好，技术资料极少而多为英语资料，门槛较高。 在线平台除了上面利用博客框架搭建自己的博客之外，我们也可以寻找一个适合自己的在线平台来写作博客。 BloggerBlogger 提供免费主机 Blogspot.com 存放博客，用户不必写任何代码或者安装服务器软件或脚本，透过所见即所得界面轻松地创建、发布、维护和修改自己的网志。允许用户自定义自己的域名（但是后面需接.blogspot.com）。具有较为成熟的中文博客书写和发布功能，使用起来较为简单轻松，内置许多的主题模板，自定义程度较高。 不足.blogspot.com 域名被 GFW 所屏蔽，内陆地区用户访问较为困难，需要使用科学上网手段。 GitHubGitHub 是当今世界上最流行，最大的代码托管网站和开源社区。如果你不想用 GitHub Pages 网页托管博客，那么你可以选择使用 GitHub issues 直接在 GitHub 上写自己的博客。只需要简单新建一个仓库，勾选添加 issues，可以愉快的在 GitHub issues 上利用 Markdown 语法进行书写。不需要你掌握任何的代码能力，只需要简单掌握 Markdown 语法即可，支持本地内容预览，可以通过给 issues 加上不同的标签来进行分类。 不足GFM（GitHub Flavored Markdown）语法对于在 GitHub issues 中编写中文的时候易出现标红，影响写作体验。对于 HTML 标签元素支持不够多。 NotionNotion 是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等，可以进行跨平台使用。 不足要想把 Notion 作为公开页面，需要一定的配置操作，Notion 官方目前还没有提供自定义域名的服务（承诺日后提供），但是我们可以通过自己来进行实现公开页面的功能，以此来达到实现个人网站页面的效果。相关配置 —— 如何为 Notion 公开页面自定义域名 像 Notion 这类在线笔记服务其实有很多种，我很难一一列举，每个人的喜好也不完全相同，只要能实现个人网站效果就可以。 最后 文中的博客框架我也没有办法亲自一一搭建体验，所以这只是一个参考方向，更何况每个人对于博客什么要求，自己什么需求，只有自己最清楚。 动态博客和静态博客各自的优缺点都很明显，按需，按能力选择就好。 无论你是使用自建博客，还是在线网站，亦或者是笔记服务，重要的是你有坚持写博客的毅力。平台重要，但不是最重要的因素。 参考文章: 七大开源 blog 框架介绍 静态博客是什么？常用的静态博客程序有哪些？静态博客的优缺点！","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%9C%A8%E7%BA%BF%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"},{"title":"搭建Typecho个人博客","text":"简介 Typecho是一个基于PHP的开源部落格程序。它使用多种数据库（MySQL、PostgreSQL、SQLite、MariaDB）储存数据，在GPLv2许可证下发行。 特性扩展 Typecho的程序设计逻辑与WordPress相似，它通过插件与模板机制对程序进行扩展。它们可以在不更改部落格内容和Typecho核心部分时，修改部落格的界面和功能。同时Typecho使用独特的模块化架构，这使得扩展十分便利。 Markdown Typecho使用的是Markdown语法，通过HyperDown（页面存档备份，(存于互联网档案馆）解析器进行解析。Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，这也是当下大多数部落格程序所采用的编辑器语法。 简洁 Typecho的程序本体不到500KB，而它的数据表在不包括扩展生成的数据表时仅7张。整站只需几个接口，通过静态继承快速传递参数，插件越多，功能只会越强大，对速度影响却微乎其微。 自适应 Typecho的默认模板和后台，全部采用了响应式设计。所以Typecho的大多数自制模板，都采用了自适应设计。 准备 云服务器一台 域名一个（如果是国内服务器需要备案） 本教程使用的环境 CentOS 7.9.2009 x86_64(Py3.7.9) 宝塔面板腾讯云专享版 7.9.3（预装） 进入面板，安装LNMP，即Nginx、MySQL和PHP，这些环境是运行Typecho程序必不可少的。推荐使用PHP7以上版本，其他保持默认即可。 看大家网站需要什么环境进行选择。如果是生产环境推荐大家使用编译安装，如果只是测试环境选择极速安装。两者的区别是编译安装慢但稳定，极速安装虽然快但是没编译安装稳定。耐心等待，可以在左上角查看进度。 nginx-1.20 pureftpd-1.0.49 mysql-5.7 php-8.0 phpmyadmin-5.1 开始搭建 添加站点 填写域名，多个域名分行填写，没有域名可以用ip地址 FTP文件上传服务可不选，个人认为面板上传文件就很方便 创建数据库 保存好密码以及用户名，后面会用到 上传Typecho文件 进入Typecho官网下载正式版 下载 - Typecho Official Site 打开宝塔面板，进入网站根目录 全选文件删除（user.ini为放跨站配置可以不删) 上传typecho.zip文件压缩包 解压typecho.zip到网站根目录，保证Typecho运行程序在根目录 删除typecho.zip压缩包（可选） 解析域名 进入域名控制台，添加解析记录 将你的域名解析到服务器的ip地址 添加两条解析记录如下： 安装Typecho 浏览器地址栏输入域名xinsong.xyz 仅填写红框，安装时会自动分配您服务器最适合的选项，因此其他保持默认即可（使用刚刚保存的数据库名以及密码） 设置用户名和登录密码以及邮箱（用于每次登录站点） 安装成功 访问站点 设置伪静态和地址重写这一步尤其重要，正确设置伪静态和固定链接可以保证网站被正常访问，顺序一定不要搞错了，先在宝塔设置伪静态规则，再设置Typecho固定链接，否则会开启固定链接会报错，未报错也可能导致除首页之外的任何页面都访问不了。 若未设置伪静态直接启用地址重写会报错，坚持开启则会导致无法访问网站文章。 设置伪静态规则 进入宝塔面板进行站点设置 在宝塔/www/wwwroot/你的域名下 用typecho伪静态 在宝塔/www/wwwroot/你的域名下/又一个文件夹下才是typecho程序 用typecho2 设置固定链接登录网站后台：设置→永久链接 启用地址重写功能（必须） 保存设置 主题 &amp; 插件Typecho 博客本身不带主题/插件商店，因此主题和插件需要自己到论坛、网上去找，下载后上传到网站目录的相应文件夹中，再到网站后台启用即可。 插件位置：网站目录/usr/plugins 主题位置：网站目录/usr/themes 附件位置：网站目录/usr/uploads 安装过程可能会遇到的问题 开启放跨站攻击无法访问站点（宝塔默认开启） ​ 解决方法一：宝塔默认启用”防止跨站”攻击后，网站打不开，善用open_basedir参数 ​ 解决方法二：关闭放跨站攻击（不推荐） 地址重写功能开启失败 ​ 解决方法：开启伪静态 参考文章： 30分钟搭建 Typecho 个人博客教程 - 知乎 宝塔面板安装Typecho开发版本 – 一个轻量的博客程序 - 大鸟博客 博客搭建Typecho个人博客搭建，快速安装，超小白（很简单的） - 掘金 宝塔typecho的伪静态是选择typecho还是typecho2-Web技术-全球主机交流论坛 - Powered by Discuz! 宝塔默认启用”防止跨站”攻击后，网站打不开，善用open_basedir参数","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BATypecho%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"搭建WordPress个人博客","text":"简介 WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。WordPress具有插件架构和模板系统。 截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress 。WordPress 是最受欢迎的网站内容管理系统全球有大约40%的网站（7亿5000个）都是使用WordPress 架设网站的。WordPress 是目前因特网上最流行的博客系统 。WordPress在最著名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。 特性WordPress具有一个带模板处理器（template processor）的页面模板系统（web template system）。 主题编辑 WordPress用户可以安装和切换主题。主题可让用户不改变博客内容和结构的情况下更改界面和WordPress站点的功能。主题可以在WordPress的“外观”管理工具中安装，或者通过FTP上传至主题文件夹。也可以通过编辑主题中的PHP和HTML代码自定义主题。 插件编辑 WordPress （页面存档备份，存于互联网档案馆）的一个特性是它丰富的插件架构，插件能使用户和开发者扩展WordPress程序的功能。当前WordPress插件数据库中有超过18000个插件，包括SEO、控件等等。 多作者共同写作和多博客共存编辑 在WordPress 3.0之前，尽管多个在不同目录中的WordPress程序能被配置成使用不同的数据库，但此时程序仅支持一次部署建立一个博客。WordPress Multi-User（WordPress MU，或简称WPMU）从WordPress中分支，支持一次部署并建立多个博客，还能够被管理员统一管理。WordPress MU成功地使一个网站能够建立自己的博客社群，同时在一个控制面板中控制修改所有的博客。WordPress MU为每个博客建立了八个新数据表。 准备 云服务器一台 域名一个（如果是国内服务器需要备案） 本教程使用的环境 CentOS 7.9.2009 x86_64(Py3.7.9) 宝塔面板腾讯云专享版 7.9.3（预装） 进入面板，安装LNMP，即Nginx、MySQL和PHP，这些环境是运行Typecho程序必不可少的。推荐使用PHP7以上版本，其他保持默认即可。 看大家网站需要什么环境进行选择。如果是生产环境推荐大家使用编译安装，如果只是测试环境选择极速安装。两者的区别是编译安装慢但稳定，极速安装虽然快但是没编译安装稳定。耐心等待，可以在左上角查看进度。 nginx-1.20 pureftpd-1.0.49 mysql-5.7 php-8.0 phpmyadmin-5.1 开始搭建 添加站点 填写域名，多个域名分行填写，没有域名可以用ip地址 FTP文件上传服务可不选，个人认为面板上传文件就很方便 创建数据库 保存好数据库密码以及用户名，后面会用到 上传WordPress文件 进入WordPress官网下载 Download | WordPress.org 打开宝塔面板，进入网站根目录 全选文件删除（user.ini为放跨站配置可以不删) 上传WordPress.zip文件压缩包 解压缩WordPress.zip到网站根目录 删除WordPress.zip压缩包（可选） 进入解压出的WordPress文件夹 全选文件剪贴 返回网站根目录，粘贴 保证wordpress的程序在网站根目录中，如下 解析域名 进入域名控制台，添加解析记录 将你的域名解析到服务器的ip地址 添加两条解析记录如下： 安装WordPress 浏览器地址栏输入你的域名 进入安装程序，选择语言 点击现在就开始 输入数据库名和密码（刚刚保存的） 提交 运行安装程序 设置站点标题、用户名、密码、邮箱（用于每次登录网站后台） 安装WordPress 登录网站（使用设置的用户名和密码） 输入设置的用户名和密码，显示如下页面则安装成功 设置伪静态这一步尤其重要，正确设置伪静态和固定链接可以保证网站被正常访问，顺序一定不要搞错了，先在宝塔设置伪静态规则，再设置WordPress固定链接，否则可能导致除首页之外的任何页面都访问不了。 设置伪静态规则 进入宝塔面板进行站点设置 选择wordpress伪静态，保存 设置固定链接 登录网站后台 设置→固定链接 使用自定义结构，用文章id作为地址 删除链接中的/index.php 按照自己想要的连接格式选中即可，保存更改 主题 &amp; 插件WordPress 博客本身带主题/插件商店，因此可以直接在网站后台进行安装并启用，当然也有许多优秀的主题和插件无法在后台中直接安装，那么这些主题和插件需要自己到论坛、网上去找，下载后在网站后台上传，再到网站后台启用即可。 安装过程可能会遇到的问题 开启放跨站攻击无法访问站点（宝塔默认开启） ​ 解决方法一：宝塔默认启用”防止跨站”攻击后，网站打不开，善用open_basedir参数 ​ 解决方法二：关闭放跨站攻击（不推荐） 开启伪固定连接后文章页面无法访问 ​ 解决方法：开启伪静态 参考文章： 宝塔面板安装WordPress（超详细） - 知乎 使用宝塔面板搭建WordPress网站 宝塔面板搭建WordPress网站完整教程 - 简书","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"搭建Hexo个人博客","text":"简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo安装hexo之前需要安装Nodejs组件，这个在我的另一篇文章： Hexo是我们博客的框架，我们需要在我们的电脑里创建一个文件夹，可以命名为Blog，Hexo框架与你发布的博客网页以后都会在这个文件中。创建好后进入文件夹中，按住shift键，右键鼠标点击打开powershell窗口； 打开后 使用npm命令安装Hexo，命令行窗口输入： 1npm install -g hexo-cli 等待一会儿即可，接着输入命令初始化我们的博客： 1hexo init blog 上面的两个命令都作用于我们刚刚创建的Blog文件夹。 然后我们就可以看到我们的Blog/文件夹目录下会出现一个blog文件夹，接着我们进入blog文件夹； 输入命令： 1cd blog 接下来我们来检测我们网站的雏形，依次输入以下命令； 12345hexo new test_my_sitehexo ghexo s 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。 在浏览器地址窗口输入：localhost:4000 即可访问到我们本地的博客内容。 未经修改过的博客页面应该是上面这个样子的，也可以看到我们刚刚创建的test_my_site这篇文章。 这样就说明我们本地的博客页面是正常的。 现在来介绍常用的Hexo 命令 npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 推送网站刚刚我们看到的只是我们本地的预览，别人并无法访问，接下来要做的就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。 创建Github仓库进入Github网页创建一个新仓库，点击New repository 仓库名为固定格式： Github用户名.github.io 例如我的sxfinn.github.io 我们使用 ssh 免密部署，这种方式可以避免输密码的繁琐，并且速度也是最快的。 创建密钥对为了方便运行 GitHub Actions 时登录 GitHub 账号，我们使用 SSH 方式登录。就是要把设备的私钥交给 GitHub Actions，公钥交给 GitHub，需要去 Settings 里去配置。 进入git bash 123ssh-keygen -t rsa -C &quot;Github的邮箱地址&quot;# 例如 ssh-keygen -t rsa -C &quot;123123123@gmail.com&quot; 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 输入后接着按三个回车 1234567891011121314151617181920212223[root@localhost ~]# ssh-keygen -t rsa &lt;== 建立密钥对，-t代表类型，有RSA和DSA两种Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): &lt;==密钥文件默认存放位置，按Enter即可Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空Enter same passphrase again: &lt;== 再输入一遍密钥锁码Your identification has been saved in /root/.ssh/id_rsa. &lt;== 生成的私钥Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 生成的公钥The key fingerprint is:SHA256:K1qy928tkk1FUuzQtlZK+poeS67vIgPvHw9lQ+KNuZ4 root@localhost.localdomainThe key's randomart image is:+---[RSA 2048]----+| +. || o * . || . .O + || . *. * || S =+ || . =... || .oo =+o+ || ==o+B*o. || oo.=EXO. |+----[SHA256]-----+ 密钥对生成后默认的位置是用户文件。以 windows 为例：密钥对文件在 C:\\Users\\用户名里，其中 Users 可能因为系统原因显示的是用户。这个文件夹里会有一个.ssh 的目录，这个里面就是我们的密钥对。 其中 id_rsa 是私钥，id_rsa.pub 是公钥。 配置公钥，应该已经配好，不然如何上到的项目资源，配置路径：github 网站–&gt;Settings–&gt;SSH and GPG keys 新增一个公钥点击 Add SSH key，然后把 id_rsa.pub 这个文件用文本文档打开，将内容复制进去。 使用下面的命令测试是否成功： 1ssh -T git@github.com 出现如下信息则说明添加成功。 配置部署信息在配置之前我们要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，之后我们对博客配置的修改都是通过此文件来进行的。 如下图： 现在我们要做的就是将Hexo与Github关联起来，打开站点的配置文件_config.yml，下拉到最后修改为： 1234deploy: type: git repo: 你的地址 branch: master 注意：repo一行中“你的地址”，即为你刚刚创建的GitHub仓库的ssh链接。 例如我的： 保存站点配置文件。 我们刚刚配置的文件其实就是在我们执行推送到远端这个hexo d这个命令时，让hexo知道该推送到哪里去，很显然我们部署在我们的GitHub仓库里。 安装Git部署插件，输入命令：（仍然是Blog/blog 目录下） 1npm install hexo-deployer-git --save 一定要记得执行此命令否则无法自动部署。 这时我们输入三条命令： 12345hexo cleanhexo ghexo d 其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即你刚刚创建的仓库名。 你就会发现你的博客已经上线了，可以在网络上被访问了，这与你在本地预览的博客内容是一样的。 绑定域名虽然在网络上已经可以访问到我们的网站了，但我们大多数人都还是想使用自己的个性域名来访问网站的，这就需要绑定我们的域名。接下来我将演示阿里云域名绑定。其他厂商区别也都不大，可以作为参照。 登录到阿里云，进入域名控制台点击解析； 添加解析记录 方案一（建议）：如果是想用主域名和www的域名访问站点 需要添加两个解析记录： 第一个解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的至少一个 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 第二个解析记录的记录类型为CNAME，主机记录为www，记录值为你的新建的仓库名——你的github用户名.github.io 注意：这里直接添加两个CNAME一个类型为@另一个为www都指向 你的github用户名.github.io 也可以的（但主机记录为@的域名添加CNAME记录值可能会有与其他服务，例如电子邮件的冲突问题，因此不建议） 方案二：如果是想使用单独的一个二级域名（包括www域）如blog域名访问站点 Custom domain填入相应域名再添加一个解析记录，记录类型为CNAME，指向 你的github用户名.github.io 即可。 方案三：如果是单独的只想使用主域名访问站点 添加解析记录的记录类型为A，主机记录为@，记录值为ping 你的github用户名.github.io的ip地址，填入为下列 IP 中的一个至少一个 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 Page的自动双重定向如下图添加了我们填写的Custom domain的解析记录会报错：DNS valid for primary，并且提示我们www域名未正确配置，这是为何？ 带着些历史原因，通常我们的印象中www域名和主域名是访问同一个站点的，大部分网站都这个机制，包括Github Page。 这段时间搞了几种框架的网站建设了，我发现不是域名指向站点的 IP 就能访问站点。 以typecho搭建的网站为例，即使一个域名指向了我们的 IP ，但如果我们的站点中没有保存这个域名的信息，也就是没有添加此域名作为访问站点的域名，那么这个域名仍然无法访问我们的站点，也就是说访问站点时是有域名认证的~，能解析到我的 IP 和站点还不行，我的站点还必须认证了此域名。 利用GitHub page部署网站也有一个这个问题，那就是page的 IP 就那么4个，是如何能够访问我们的站点而不是其他人的站点呢？实际上GitHub是根据我们提交的CNAME去确定我们的站点的，CNAME的值会去填充Custom domain，而这个Custom domain会和我们的站点形成一种绑定关系，我们只有使用这个Custom domain才能正确访问站点。 既然只能通过这一个Custom domain来访问站点，那么Github Page是怎么实现的www域名和主域名都能访问站点这样的机制呢？ 原因是Github Page提供了双重定向的机制。 GitHub Page推荐我们通过DNS提供商在配置一个主域名同时配置一个 www 子域名，这样主域名和www的域名都可以访问站点 如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。 正确配置这两个域名后： 如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 虽然只能填写一个Custom domain，也只能通过此Custom domain访问站点，但是通过DNS提供商对www域名和主域名DNS的正确配置GitHub Page会为我们自动创建双重定向，可以让 非Custom domain：www域 和主域其中一个 重定向到Custom domain，从而能够达到www域名和主域名都能访问站点的效果。而如果使用其他子域名（非www），则只能使用这一个子域名访问站点。自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。 例如，如果您将www.example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，example.com则将重定向到www.example.com,如果您将example.com站点配置为自定义域，并且为主域和www域设置了 GitHub Pages DNS 记录，www.example.com则将重定向到example.com. 正是由于Page支持这样的机制，GitHub Page在我们Custom domain设置为 主域名或者www域名时，会主动检测DNS提供方是否将主域名和www域名都正确配置了（即使我们并不想使用重定向机制），像上图这样只添加了我们填写的Custom domain的这一条xinsong.xyz的解析记录，会提示我们：DNS valid for primary，www.xinsong.xyz就不能正确访问我们的站点，只能通过xinsong.xyz去访问。而如果这里的Custom domain是www.xinsong.xyz，并且也只添加了www的解析记录，那么这里也会提示：**DNS valid for primary，并且报错：xinsong.xyz配置错误，也只能通过www.xinsong.xyz访问站点。如果不想看到Page报错和提示或者想使用双重定向机制，那么按照上面的方案一**做就能正确配置不会报错了。 因此提示 DNS valid for primary 是Github Page主动检查是否满足重定向机制的结果，一旦提示我们DNS valid for primary，说明未能创建双重定向，只有使用当前的Custom domain才能访问我们的站点。 登录GitHub，进入之前创建的仓库，点击setting，设置Custom domain，输入你的域名。 这样就通过我们的个性化域名来访问我们自己的网站了。 但是这样做每次推送到远端时这个Custom domain都会被覆盖，需要重新输入，因此还需要做如下操作： 进入Blog/blog/source目录下，创建一个记事本文件，输入GitHub Page页面的Custom domain。这里建议是带www的域名。 保存即可，命名为CNAME，注意保存类型选择所有文件而不是文本文件。 这样我们每次推送到远端时就可以保证我们始终都能使用此域名进行访问。 然后再进入blog文件中打卡powershell，依次执行： 12345hexo cleanhexo ghexo d 这时候无论怎么折腾，我们在浏览器中输入我们的域名，就可以访问我们的网站了。 最终GitHub Page推荐我们在配置一个主域名的同时配置一个 www 子域名。 如果您通过 DNS 提供商正确配置一个顶级域名（例如 example.com ）和一个匹配的 www 子域名（例如 www.example.com ），GitHub 服务器会自动地创建双重定向。 正确配置这两个域名后： 如果你的 CNAME 文件为 example.com，那么 www.example.com 会定向到 example.com。 如果你的 CNAME 文件为 www.example.com，那么 example.com 会定向到 www.example.com。 警告：不要在你的 DNS 提供商上为你的自定义主域名创建一个 CNAME 记录！这样做可能会导致与其他服务，如电子邮件等，在该域的问题。 所以根据GitHub Page的官方说明，总结下： 使用子域名时（非www域），建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此子域去访问站点 单独使用主域名时（不配置www域），建议在DNS提供商上为该主域名创建一个 A 记录（CNAME可行，但不建议，可能发生电子邮件及其他服务的冲突问题），那么只能通过此主域访问站点 使用www/主域名时，建议在DNS提供商上为该主域名创建一个 A 记录，在DNS提供商上为该www域名创建一个 CNAME 记录即可自动创建双重定向（定向到我们CNAME文件中的地址，无论CNAME文件为 www.example.com 还是 example.com ），使用www域和主域均可访问站点 单独使用www域时，建议在DNS提供商上为该子域名创建一个 CNAME 记录，那么只能通过此www域去访问站点 自动重定向仅适用于www子域和其主域名之间，不适用于任何其他子域。 你可以使用除了 www 以外的一个自定义子域名和一个自定义顶端域名来通过域名重定向（有时候也叫“域名转发”）。但是，请注意，这只能用于用户和组织的 Pages，而不是项目的 Pages。 参考文章： 在你的 DNS 提供者上配置 A 记录的技巧 - GitHub Pages 指南 - UDN开源文档 管理 GitHub Pages 站点的自定义域 - GitHub Docs","link":"/2023/01/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"Clash-API一键订阅链接转换","text":"简介Clash for Windows（CFW）应该是目前Windows上最好用的基于规则的跨平台代理工具软件，允许用户可视化操作和支持主流SS/V2ray/Trojan协议，Clash.Net在此基础上对UI进行了美化，比较推荐使用。 转码托管 - 机场订阅和策略组网络上有许多转码托管API，只需要用到一个你的机场订阅链接，就能自动生成转码后的链接地址，通过嵌套在线规则策略组的链接，从而能够应用各种分流规则和策略组，最终API会返回一个链接地址，我们导入此链接地址至客户端，就能按照指定嵌套的规则分流了。 转码托管机场链接一般情况下，这些订阅转换API转码不会保存你的节点信息。通俗来说，只是把你的字符转换成另外一种计算机语言，并套进对应的代理工具软件配置参数的链接中，有顾虑的可以自己搭建API。 🔗订阅转换托管API推荐： ACL4SSR 在线订阅转换（用的人数很多，后端比较稳定） 边缘@订阅转换API（比较稳定） 在线订阅转换工具（魔改版后端，全网功能最全！站点界面很特殊） 这些API中一般会有相应分流规则的选项，接下来我们介绍直接采用ACL4SSR等大佬维护的分流规则，他们的规则策略其实已经能满足绝大部分用户的使用场景。 我们就以转换为最常见的Clash为例，Clash相比其他的客户端有一个特殊之处也需要特别说明：新版内核出现后，新旧订阅不能互相兼容。 进入API，有两种模式： 基础模式； ​ 使用场景例如：当机场提供的 Surge 配置足以满足需求，但额外需要使用 Clash 订阅时，此时可以使用基础方式进行转换。 ​ 基础模式直接生成的话，就是使用默认规则并启用clash新参数的转换，对于最新版的原版clash可以直接使用，旧版clash无法使用。 进阶模式； ​ 使用场景：即对 调用地址 甚至程序目录下的 配置文件 进行个性化的编辑以满足不同的需求。 ​ 进阶模式中，是否启用clash新参数的开关在右下角的“更多选项”里，并且支持选择分流规则和策略组。 ​ 由于基础模式的局限性，我们使用进阶模式转换订阅链接。 👉 转换托管步骤 输入的订阅/节点链接（有多个需要分行写）。 选择客户端，这里选择Clash。 选择后端地址，留空或者默认即可。 选择远程配置，远程配置即clash的代理规则配置文件，这里我选择ACL4SSR Online默认版分组比较全(与Github同步)。 根据需求勾选更多选项。 如需打游戏或者使用Microsoft Store应用，则需勾选下面的“启用UDP”； 如果机场中有chacha20协议的SSR节点（目前仍不支持，会导致无法导入订阅），就需要勾选那个“过滤非法节点”； Clash New Field是否勾选视客户端版本而定，参照下方： 以下为Clash新参数支持情况，请根据版本确定是否勾选Clash New Field： clash内核在2020/08/16release的1.1.0版本开始支持SSR。 Windows版clash在2020/08/21release的0.11.5版本中引入新内核，也就是从这个版本开始，就必须clash新参数。这个版本之前的Windows版clash使用新参数会无法导入订阅。 Mac版clash（clashx）在2020/09/06release的1.30.2版本开始使用新内核，和Windows版一样，从这个版本开始必须使用新参数，之前的版本必须不使用新参数且不支持SSR。 路由器版的openclash使用的TUN内核（这玩意只有一个预览版）在2020/07/25的v0.39.5-beta版开始添加新参数支持，引入新内核。 Android版clash在2020/09/03release的2.1.5版开始支持新参数。可以从谷歌play商店直接安装（搜不到就是安卓版本不够）。 注：Clash New Field选项是只有转换为Clash链接才生效，勾选表示使用新版的写法。新版clash不能兼容旧订阅，旧版clash不能兼容使用新参数的订阅。 根据我自己的需求，这里我勾选了Emoji,Clash New Field,UDP. 点生成订阅链接，获得转码后的链接地址，下面是按照图内的地址转码后得到的结果： 1https://pub-api-1.bianyuan.xyz/sub?target=clash&amp;url=https%3A%2F%2Fcate.com&amp;insert=false&amp;config=https%3A%2F%2Fraw.githubusercontent.com%2FACL4SSR%2FACL4SSR%2Fmaster%2FClash%2Fconfig%2FACL4SSR_Online.ini&amp;emoji=true&amp;list=false&amp;tfo=false&amp;scv=false&amp;fdn=false&amp;sort=false&amp;udp=true&amp;new_name=true 调用参数可用参数远不止这些，介绍一下以上出现的可能必须需要修改的参数： scv：跳过证书检验； 注意： 如果订阅支持tfo就把这项后面的false改成true，默认为false。 有些机场订阅可能要开启跳过证书检验才能正常使用，如果无法使用，请尝试修改参数scv=false为scv=true。原理是因为部分机场用的中转提供的域名是不能通过tls认证的，需要关闭对证书验证才可以使用。 每个API生成的链接显式调用的参数都有差异，如果参数不写，参数的默认配置（true/false）与选择的后端有关，如不满足自身使用场景，请自行修改参数。 参考官方文档：subconverter/README-cn.md at master · tindy2013/subconverter 调用参数说明 调用参数 必要性 示例 解释 target 必要 surge&amp;ver=4 指想要生成的配置类型，详见上方 支持类型 中的参数 url 可选 https%3A%2F%2Fwww.xxx.com 指机场所提供的订阅链接或代理节点的分享链接，需要经过 URLEncode 处理，可选的前提是在 default_url 中进行指定。也可以使用 data URI。可使用 tag:xxx,https%3A%2F%2Fwww.xxx.com 指定该订阅的所有节点归属于xxx分组，用于配置文件中的!!GROUP=XXX 匹配 group 可选 MySS 用于设置该订阅的组名，多用于 SSD/SSR upload_path 可选 MySS.yaml 用于将生成的订阅文件上传至 Gist 后的名称，需要经过 URLEncode 处理 include 可选 详见下文中 include_remarks 指仅保留匹配到的节点，支持正则匹配，需要经过 URLEncode 处理，会覆盖配置文件里的设置 exclude 可选 详见下文中 exclude_remarks 指排除匹配到的节点，支持正则匹配，需要经过 URLEncode 处理，会覆盖配置文件里的设置 config 可选 https%3A%2F%2Fwww.xxx.com 指 外部配置 的地址 (包含分组和规则部分)，需要经过 URLEncode 处理，详见 外部配置 ，当此参数不存在时使用 主程序目录中的配置文件 dev_id 可选 92DSAFA 用于设置 QuantumultX 的远程设备 ID, 以在某些版本上开启远程脚本 filename 可选 MySS 指定所生成订阅的文件名，可以在 Clash For Windows 等支持文件名的软件中显示出来 interval 可选 43200 用于设置托管配置更新间隔，确定配置将更新多长时间，单位为秒 rename 可选 详见下文中 rename 用于自定义重命名，需要经过 URLEncode 处理，会覆盖配置文件里的设置 filter_script 可选 详见下文中 filter_script 用于自定义筛选节点的js代码，需要经过 URLEncode 处理，会覆盖配置文件里的设置。出于安全考虑，链接需包含正确的 token 参数，才会应用该设置 strict 可选 true / false 如果设置为 true，则 Surge 将在上述间隔后要求强制更新 upload 可选 true / false 用于将生成的订阅文件上传至 Gist，需要填写gistconf.ini，默认为 false (即不上传) ,详见 自动上传 emoji 可选 true / false 用于设置节点名称是否包含 Emoji，默认为 true add_emoji 可选 true / false 用于在节点名称前加入 Emoji，默认为 true remove_emoji 可选 true / false 用于设置是否删除节点名称中原有的 Emoji，默认为 true append_type 可选 true / false 用于在节点名称前插入节点类型，如 [SS],[SSR]等 tfo 可选 true / false 用于开启该订阅链接的 TCP Fast Open，默认为 false udp 可选 true / false 用于开启该订阅链接的 UDP，默认为 false list 可选 true / false 用于输出 Surge Node List 或者 Clash Proxy Provider 或者 Quantumult (X) 的节点订阅 或者 解码后的 SIP002 sort 可选 true / false 用于对输出的节点或策略组按节点名进行再次排序，默认为 false sort_script 可选 详见下文 sort_script 用于自定义排序的js代码，需要经过 URLEncode 处理，会覆盖配置文件里的设置。出于安全考虑，链接需包含正确的 token 参数，才会应用该设置 script 可选 true / false 用于生成Clash Script，默认为 false insert 可选 true / false 用于设置是否将配置文件中的 insert_url 插入，默认为 true scv 可选 true / false 用于关闭 TLS 节点的证书检查，默认为 false fdn 可选 true / false 用于过滤目标类型不支持的节点，默认为 true expand 可选 true / false 用于在 API 端处理或转换 Surge, QuantumultX, Clash 的规则列表，即是否将规则全文置入订阅中，默认为 true，设置为 false 则不会将规则全文写进订阅 append_info 可选 true / false 用于输出包含流量或到期信息的节点, 默认为 true，设置为 false 则取消输出 prepend 可选 true / false 用于设置插入 insert_url 时是否插入到所有节点前面，默认为 true classic 可选 true / false 用于设置是否生成 Clash classical rule-provider tls13 可选 true / false 用于设置是否为节点增加tls1.3开启参数 new_name 可选 true / false 如果设置为 true，则将启用 Clash 的新组名称 (proxies, proxy-groups, rules) 根据我自身的使用情况，我选择的参数配置为true的有：emoij，udp，expand，scv，clash新字段名。（许多后端默认开启expand：展开规则全文到订阅，因此可以不写expand参数）。 最终得到的链接导入客户端即可。 其他客户端订阅链接的转换只有Clash由于内核更新导致的新旧版无法兼容而有了Clash New Field选项，因此其他客户端的链接转换无需考虑是否勾选Clash New Field。 其他订阅链接的转换都是按照如上操作只需更换目标客户端即可。 参考文章： subconverter/README-cn.md at master · tindy2013/subconverter","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Clash-API%E4%B8%80%E9%94%AE%E8%AE%A2%E9%98%85%E9%93%BE%E6%8E%A5%E8%BD%AC%E6%8D%A2/"},{"title":"Matlab安装教程","text":"准备操作系统要求 Windows 10（1803版或更高版本） Windows 7 Service Pack 1 Windows Server 2019 Windows Server 2016 处理器要求 最低要求：任何Intel或AMD x86-64处理器推荐：具有四个逻辑核心和AVX2指令集支持的任何Intel或AMD x86-64处理器 内存要求 最小：4 GB 推荐：8 GB 对于Polyspace，建议每个内核4 GB 硬盘要求 最小： 3.1 GB的HDD空间仅用于MATLAB，典型安装为5-8 GB，完整安装所有MathWorks产品可能会占用多达31 GB的磁盘空间 推荐：推荐使用SSD 安装 下载MATLAB 2019b 解压下载的文件 进入R2019b_win64文件夹，右键以管理员的方式运行setup.exe： 选择文件安装密钥，下一步： 同意许可，下一步： 选择我已有我的许可证的文件安装密钥，填入许可证：09806-07443-53955-64350-21751-41297，下一步： 修改要安装路径(路径内不要含有中文，不想装在C盘可以换成D盘，但后面的路径不要动)，下一步： 创建桌面快捷方式，下一步： 这里可以全部安装上，下一步： 确认安装信息，会比较大大概30G，安装： 安装等待即可，时间会比较久： 下一步： 完成 激活 进入解压文件的crack目录： 复制license_standalone.lic文件，打开软件的安装目录，创建licenses文件夹： 将复制的license_standalone.lic粘贴到licenses文件夹内： 复制crack文件夹内的bin文件夹，并将其粘贴到软件安装根目录： 点击【替换目标中的文件】 进入软件安装目录的bin里的win64目录，右键管理员身份运行activate_matlab.exe: 选择“不使用Internet的情况下手动激活”，下一步： 选第一个，浏览打开拷入lic文件，下一步： 完成： 搜索框直接搜索matlab命令即可：","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Matlab%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"Nodejs安装","text":"简介 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 下载进入官网-Download | Node.js LTS为对于大多数用户推荐的版本，一般来说没有特殊需求我们就直接下载这个即可； 安装 勾选协议，点击next 选择安装路径，点击next 选择安装选项，我这里选择添加到环境变量，点击next 选择是否需要组件，不需勾选，直接next 安装，install等待一会儿即可 安装完成 验证是否成功安装注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 检测npm是否安装成功，在命令行中输入npm -v : 发现这里有一个警告，这是版本未更新导致的问题，解决方法如下： 解决方法未出现问题可直接跳过这一步 npm WARN config global --global, --local are deprecated. Use --location=global instead报错解决方法。 将npm升级到最新版本即可 升级方法 在windows中以管理员身份打开cmd，然后执行命令 1npm install -g npm-windows-upgrade 更改脚本策略下载Windows Power Shell然后以管理员身份运行，执行命令 1set-ExecutionPolicy RemoteSigned 输入Y 成功更改脚本策略 在Windows Power Shell上运行命令 1npm-windows-upgrade 选择要更新的版本 选择最新的，按回车即可。 检验npm是否安装成功，命令行输入 npm -v 问题解决！ 到这里，nodejs和npm的安装就全部完成了。 其实此问题是由版本号导致 第二种方法应该也行，是官方提供的方法，同样是用npm-windows-upgrade更新npm，链接在下面： felixrieseberg/npm-windows-upgrade: Upgrade npm on Windows 参考文章： node.js - How do I update npm on Windows? - Stack Overflow npm WARN config global --global, --local are deprecated. Use --location=global instead. 怎么解决-前端-CSDN问答 https://github.com/npm/cli/issues/4980 https://blog.csdn.net/weixin_42288182/article/details/106896534","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Nodejs%E5%AE%89%E8%A3%85/"},{"title":"Cloudflare回源对象存储","text":"简介Cloudflare常应用在网站建设中，不仅省心还省钱。HTTPS 证书实在是太贵了, 一个通配符域名证书一年要至少花上一两千. 那么如何满足广大人民群众建站需求呢? Cloudflare 就是一个很好的选择. Cloudflare 是一家 CDN 提供商, 可以为网站提供反向代理. 它的做法是, 将域名解析到 Cloudflare 的服务器 (或者说代理) 上, 然后浏览器使用 Cloudflare 的证书与代理建立 SSL 连接; 接着代理会与目标服务器使用自签名的证书建立 SSL 连接, 接下来的数据都由代理转发. Cloudflare 会信任这个自签名证书, 所以整个过程都是没问题的. Cloudflare确实良心，我们也可以将其应用在图床上，就可以隐藏我们真是的源站地址。本文将以腾讯云COS为例，使用Cloudflare为COS开启CDN服务，让我们的站点更安全，阿里OSS同样适用，只有略微差别。 腾讯云COS配置 开通COS进入存储桶列表，创建存储桶 众所周知，宽带联盟覆盖区域不包括中国大陆，因此你需要重新开通一个海外地区的存储桶 存储桶名字随便取 权限我这里选择公有读私有写。担心安全问题的朋友可以设置为私有读写，不过需要设置 Bucket 授权策略来允许 Cloudflare 的节点 IP 访问 高级配置默认即可 创建成功 进入此存储桶配置管理，域名传输管理—&gt;自定义源站域名 添加自定义源站域名 保存，复制下方CNAME值，即我们原始的源站访问域名 Cloudflare配置 注册账号，登录Cloudflare 添加站点（我们在腾讯云添加的自定义源站域名的主域名） 选择免费套餐 这里稍等一下，CF添加站点后会自动检查有哪些解析记录，点击继续 更换DNS服务器到Cloudflare我们如果想要使用Cloudflare的CDN和解析服务需要将DNS服务器更改为CF的。 如下图，CF会提供给我们两个框框中的域名服务器，提示我们将DNS服务器更改为CF的 进入你购买域名的厂商，登录您的域注册厂商的管理员帐户，打开对应域名管理，修改DNS服务器 修改DNS服务器为Cloudflare的，将CF分配给我们的域名填入下方框框保存即可 稍等一会儿后配置才会生效，每个域名注册商都有些许不同，但步骤都差不多 更换DNS后，返回Cloudflare，点击完成 然后会出现一些简单配置项，如图配置或者跳过即可 添加CNAME解析记录 为刚刚的自定义源站域名添加CNAME记录指向原始的源站访问域名，并开启CF代理（打开小云朵表示开启CDN加速） 保存 Cloudflare添加域名后，会自动生成通用证书，快速开启全站HTTPS，服务端不用做任何修改，还可以选择开启多种模式 进入SSL/TLS，有四种模式供我们选择，一般来说选择第二个和第三个就可以 回到腾讯云的自定义源站域名配置 注意：这里会有个小警告，但是不用去管，因为我们开启CF代理我们的站点后，CNAME记录的检测可能会出现些问题。 进阶方案：可以参考 基于COS的全球加速解决方案 - AHdark Blog Cloudflare还可以和国内CDN结合，达到国内IP走国内CDN，国外IP走Cloudflare，达到全球加速的效果。 一个域名既作为COS源站的CDN加速域名，又作为Cloudflare代理COS源站的自定义域名。 参考文章： cloudflare使用入门教程，国外最好免费CDN - 知乎 个人图床的最终抉择 | 小康博客 cloudflare+freenom创建自己的域名网站 | Healthy Mind Cloudflare 入门教程：使用 Cloudflare 免费 CDN 加速 &amp; 保护自己的网站 - 知乎 通过Cloudflare开启全站https_Thomas_Lean的博客-CSDN博客_cloudflare https Cloudflare or Vercel —— 网站托管与函数计算服务选择","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Cloudflare%E5%9B%9E%E6%BA%90%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"title":"Typora+Github + Picgo打造个人云笔记","text":"创建仓库 如图创建一个新的仓库 指定仓库名 下载picgo 链接如下： Releases · Molunerfinn/PicGo 下载后一直下一步傻瓜式安装即可。 进入GitHub图床设置 仓库名格式如上：用户名 + 仓库名 分支名根据你的远程分支自行指定 生成TOKEN进入GitHub网站的设置页面 进入个人github账户setting. 点击Developer settings. 选择Personal access tokens. 点击Generate new token. 为你创建的token添加描述 描述一下，例如 Test。 选择token有效期时间。 可以选择永不过期 为token赋予权限。 点击生成。 Picgo配置 点击左边图床设置，选择GitHub图床，具体配置如下 设定仓库名，填写：GitHub名/库名 分支，默认填master 设定Token，刚才保存的token令牌 指定存储路径，默认填img/ 点击确定和设为默认图床 一定保存好，这个Token只能查看一次。 进入PicGo设置，打开时间戳重命名 时间戳可以防止命名冲突。 免费CDN：jsDelivr+Github如果默认不适用自定义域名，github里边这个地方是比较蛋疼的一点，上传的图片啥的，他会给你上传到另一个文件服务器里边，这个地址国内不使用vpn是无法访问的，而我们本地typora的图片链接和GitHub远端存储的链接是一样的，通常如下：https://raw.githubusercontent.com/sxfinn/Pic/master/img/202204120923663.png。 但是这个链接我们在国内是无法访问的，因此需求是给自己个人博客搭建图床的同学就会出现图片无法访问的问题。 解决方法： CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 使用方法Picgo中设定自定义域名，自定义域名格式可以是你的 用户名/仓库名 前加上https://cdn.jsdelivr.net/gh，这样可以加速我们对图片的访问，默认不更改的话图片会是使用如下raw.githubusercontent 前缀的链接。 使用CND加速后，Typora文档的图片的链接会变成我们设置的自定义域名 ：https://cdn.jsdelivr.net/gh/用户名/仓库名/2022xxxxxx.png，而如果我们将文档上传到GitHub服务器上,链接则通常如下： https://camo.githubusercontent.com/e27aa2f17225d131bfa13f46412a4cee2ec4796a29f62fca34cebc2421bc2efe/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f737866696e6e2f5069632f696d672f3230323230343132303935393338322e706e67 例如：我写下这篇文章时的同一张图片 GitHub上远端的链接 本地typora的图片链接 GitHub给出如下解释：为托管您的图像，GitHub 使用 开源项目 Camo。Camo 为每幅图像生成开头为 https://camo.githubuserconten... 的匿名 URL 代理，将会对其他用户隐藏您的浏览器详细信息和相关信息。 参考链接：Github image without camo - Stack Overflow 由于raw.githubusercontent.com 国内域名无法访问， 如果我们想要在个人博客中插入图片这两种前缀的链接都可以使用： camo.githubusercontent.com … cdn.jsdelivr.net/gh … Typora设置 进入typora偏好设置 进入图像 勾选对本地和网络位置上的照片应用上规则。 上传服务选择Picgo 路径是你的Picgo的安装目录，通常在 Program File目录中。 以上步骤完成后，点击 验证图片上传选项 如上图就成功上传了 进入GitHub查看图片 参考文章： PicGo图床与Typora（PicGo+Typora+GitHub的完整设置） - 知乎 搭建自己的图床 - 腾讯云开发者社区-腾讯云 Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 - 简书 使用jsdelivr+Github加速文件 - 银狐笔记 快速免费的公用 CDN —— jsDelivr - Rogn - 博客园","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Typora+Github%20+%20Picgo%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"title":"VSCode外部终端中文乱码问题.md","text":"转载自：https://www.cnblogs.com/stu-jyj3621 在处理这个问题之前，你首先得知道为什么会出现这个这个问题。 你在使用VScode编辑代码时，代码页面中文正常，而终端输出那里中文却为乱码。 出现这个现象的原因是因为编码方式的不同。（VScode的默认编码方式为UTF-8，输出到终端的字符都是UTF-8的，而中国地区下cmd的编码方式GBK） 如果VScode终端那里调用的是cmd，两者编码方式的不同的就导致了中文乱码的问题。 所以我们解决乱码的方式，就是将两者的编码方式统一就行，要么将两者都统一为UTF-8，要么就统一为GBK。（个人建议统一为GBK） 方法一VSCode终端其实调用的是cmd.exe，所以当这里出现中文乱码的时候要解决的是cmd的编码设置问题。 可以通过 chcp 命令查看 cmd 的编码设置，GBK2312 的代码页编号是 936，然后改成utf-8的编码即可； utf-8 对应的代码页编号是 65001 ，所以执行 chcp 65001 就可以把cmd的编码设置成uft-8了； 这样就解决了乱码问题，然后可以再次运行代码查看输出 ； 当然每次使用都输入一遍 chcp 65001 太烦了 ，可以直接在setting.json 中加上 123&quot;code-runner.executorMap&quot;:{ &quot;cpp&quot;:&quot;chcp 65001 &quot; }, 方法二 若是按F5启动调试出现乱码，则可以按 具体操作步骤 文件——&gt;首选项——&gt;设置——&gt;搜索设置——&gt;encoding——&gt;Files：Encoding ——&gt; gbk 修改实现 VScode默认是UTF-8编码格式，我们要做的是更改VScode的默认编码格式为GBK。 下面是有关gbk和UTF-8编码方式的简单介绍： GBK全称《汉字内码扩展规范》（GBK即“国标”、“扩展”汉语拼音的第一个字母，英文名称：Chinese Internal Code Specification） ，中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订，国家技术监督局标准化司、电子工业部科技与质量监督司1995年12月15日联合以技监标函1995 229号文件的形式，将它确定为技术规范指导性文件。这一版的GBK规范为1.0版。 UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码，由Ken Thompson于1992年创建。现在已经标准化为RFC 3629。UTF-8用1到6个字节编码Unicode字符。用在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。 方法三在node.js的调试过称中，经常需要在终端中使用console.log()输入一些变量，然而windows的cmd默认是GBK编码，在调试的过程中会出现乱码。 幸好VScode提供的对内置控制台的运行参数设定，我们可以通过 terminal.integrated.shellArgs.windows 选项对内置控制台的运行进行参数设定。 通过打开“文件”–“首选项”–“用户设置”，然后在setting.json中设置： 12345{ &quot;editor.fontSize&quot;: 18, &quot;terminal.integrated.shellArgs.windows&quot;: [&quot;/K chcp 65001 &gt;nul&quot;], &quot;terminal.integrated.fontFamily&quot;: &quot;Lucida Console&quot;,} /K chcp 65001 &gt;nul 的含义是在运行cmd的时候将编码设置为 65001； &gt;nul 是避免在控制台输出修改编码的信息，否则会输出 active code page: 65001； 同时，把字体修改为 **Lucida Console**。","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VSCode%E5%A4%96%E9%83%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"VSCode配置C-C++环境","text":"转载自：【教程】VScode中配置C语言/C++运行环境_哔哩哔哩_bilibili 下载编辑器VScode 官网：https://code.visualstudio.com/ 安装VScode（建议附加任务全部勾选） 下载编译器MinGW并解压 官网页面：https://www.mingw-w64.org/ 下载页面：https://sourceforge.net/projects/mingw-w64/files/ -内置了iconv工具 非官方下载页面：MinGW Distro - nuwen.net -此版本未内置iconv工具 你可以进入官网自行寻找 你也可以直接点击为你找好的下载页面 下载页面中选择 x86_64-win32-seh 下载 如果你因为网络环境限制无法下载 不限速下载，请笑纳^-^：https://wwn.lanzouh.com/iLOip031ku6b 密码:1234 在C盘中解压文件 理论上你可以在任何地方解压，但注意路径不能包含中文，至于特殊字符请自行测试 将MinGW添加至环境变量 进入mingw64下的bin文件夹，复制当前路径，Win + i唤起系统设置，输入高级系统设置并进入，点击环境变量，选择path，编辑，新建，粘贴路径，按下三个确定 配置VScode插件 打开VScode安装插件 Chinese 和 C/C++ ，等待安装完毕后重启VScode 切换C/C++插件至 1.8.4 版本（非必要，不过对于小白来说更方便，此版本运行即自动配置） 因最新版本不会自动生成launch.json文件，给后续优化带来不便，故退回旧版本。 运行代码 新建文件夹，修改为英文名称并进入，右键 通过Code打开 若在安装时未勾选相关选项，可能没有这个选项，请自行在VScode内操作打开文件夹 新建一个文件，英文命名且扩展名为 .c 编写相关代码 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ printf(&quot;Hello World!\\n&quot;); printf(&quot;你好世界！\\n&quot;); system(&quot;pause&quot;); // 防止运行后自动退出，需头文件stdlib.h return 0;} VScode菜单栏，点击运行，启动调试，稍等程序运行，输出结果在下方终端，上方调试面板，点击最右边的 橙色方框 停止程序运行 调整和优化 请根据自己的需要进行优化 代码运行后 .vscode 文件夹会自动生成在你的源文件目录下 .vscode 文件夹下的 task.json 和 launch.json 用来控制程序的运行和调试 将程序运行在外部控制台【墙裂推荐】 打开.vscode 文件夹下的 launch.json 文件，找到 &quot;externalConsole&quot;: false, 将 false 改为 true 并保存 解决中文乱码问题【墙裂推荐】| VSCode中解决终端的中文乱码问题 - 我等着你 - 博客园 中文乱码是由于VSC的默认编码格式是UTF-8，那么编译后程序的字符串的保存方式仍然为UTF-8，而CMD的编码方式为GBK。GBK的编码中文和符号是双字节，字符和整型是单字节。utf-8的中文和符号是三字节，字符和整型是单字节，二者的中文字符并不兼容。为解决这个问题，我们需要将二者的编码方式设为相同编码。方法多种多样，最方便、副作用最小的是下面将要介绍的方法： 先了解一下gcc编译选项： -finput-charset:输入字符集设置(需要和源文件编码一致)，告诉编译器以什么样的编码形式读入源文件中的字符串。 -fexec-charset:执行字符集设置(需要设置为当前运行环境支持的编码),告诉编译器在内存中以什么样的编码形式保存字符串。 -fwide-exec-charset:宽字符执行编码(在windows下应设置为utf-16LE)，告诉编译器在内存中以什么样的编码形式保存宽字符串。 修改程序编码方式为GBK： 打开.vscode 文件夹下的 task.json 文件，找到 &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; 在后面加上英文 逗号 然后回车到下一行，粘贴下面文本 &quot;-fexec-charset=GBK&quot; 并保存 编译时用&quot;-fexec-charset=GBK&quot;这个参数（目前的配置是有的），生成的程序的字符串就是GBK编码的，源文件编码格式不会受到影响，仍是UTF-8。 注意：加入此参数需要依赖你下载的mingw内置iconv工具！！！ iconv是一个计算机程序以及一套应用程序编程接口的名称。 作为应用程序的iconv采用命令行界面，允许将某种特定编码的文件转换为另一种编码。 若缺少iconv工具使用了此参数，会出现如下报错： 1no iconv implementation, cannot convert from utf-8 to gbk 收纳生成的 exe 可执行文件【可选】 打开.vscode 文件夹下的 task.json 文件，找到 &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; 修改成 &quot;${fileDirname}\\\\coin\\\\${fileBasenameNoExtension}.exe&quot; 并保存，同理，launch.json 下也有相同的字段，需要你修改 在源文件同目录下新建 coin 文件夹，程序运行后，可执行文件将会生成在里面（其中 coin 可修改成你喜欢的英文名字） 这样 .c 文件一多起来的时候，就不会出现 .exe 和 .c 相互穿插在目录中^-^ ​ 以上优化C++的项目同理，不再演示。 提示 若源代码文件夹含有中文路径，将会无法编译程序。 若你的Windows用户名使用了中文，可能无法运行。","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VSCode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/"},{"title":"VScode 修改插件安装目录","text":"管理员权限打开cmd，利用mklink来创建目录符号链接。 把C:\\Users{username}.vscode\\extensions(默认插件位置)的extensions文件夹整个剪切到你想换的位置。 在cmd中输入 mklink /D “C:\\Users{username}.vscode\\extensions” “剪切后的路径” (username即为你的账户的用户名) 类似于Linux中的软链接，仅仅是指向另一个目录的链接，并不占用空间。 注意：不要将新的路径放在VS Code安装目录，VSCode每次更新都会刷新安装目录，会导致非安装时创建的文件夹全部删除，插件也会全部丢失，extensions链接不过去会导致VS Code启动不了(双击，cmd输入code，右键-&gt;通过code打开等操作均无反应)","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/VScode%20%E4%BF%AE%E6%94%B9%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95/"},{"title":"Windows&amp;Office下载地址","text":"Windows 11 正式发布，符合Win 11硬件要求的Win10用户可以通过系统更新功能升级，也可以下载镜像全新安装。建议搭配新发布的Office 2021办公套件使用。 创建适用于 Windows 的安装介质你可以使用安装介质（U 盘或 DVD）来安装 Windows 的新副本、执行全新安装或重新安装 Windows。 要创建安装介质，请转到软件下载网站，你可以在这里找到分步说明。 在该网站上，你可以选择 Windows 版本，并使用 U 盘或 DVD 创建自己的安装介质。 要直接转到某个版本，请选择以下链接之一： Windows 7 Windows 8.1 Windows 10（然后选择“立即下载工具”。）) Windows 11 (然后选择”立即下载工具“。) 重要: 在电脑上安装或重新安装 Windows 之前，请备份你的文件。 了解如何为 Windows 10 和 Windows 11 或 Windows 7 和 Windows 8.1 执行该操作。 要创建安装介质，你需要以下工具： 具有可靠的 Internet 连接的电脑。 下载时间会有所不同，具体取决于你的 Internet 连接。 U 盘、外部硬盘或 DVD。 具有至少 8 GB 空间的空白 U 盘或外部硬盘，或空白 DVD（以及 DVD 刻录机）。 我们建议使用空白 U 盘或空白 DVD，因为其中的任何内容都将被删除。 从 ISO 文件刻录 DVD 时，如果提示光盘映像文件太大，则需要使用双层 (DL) DVD 介质。 Windows 11Windows 11 (business editions) magnet:?xt=urn:btih:7D77AF4A99A4C5AEAB1D401755E473BA7EBD7B1C&amp;dn=zh-cn_windows_11_business_editions_x64_dvd_f5f6bcbd.iso&amp;xl=5413181440 Windows 11 (consumer editions) magnet:?xt=urn:btih:CF0A537944C001AD86B1CA058E8D877F5F022FC6&amp;dn=zh-cn_windows_11_consumer_editions_x64_dvd_904f13e4.iso&amp;xl=5517273088 12consumer editions：零售版本，包含：Home(家庭版); Education(教育版) ; Professional(专业版)business editions：VL版本，包含：Education(教育版); Enterprise (企业版); Professional(专业版) 以上来自MSDN版，可以下载官方升级助手或镜像构建工具安装Win 11 https://www.microsoft.com/zh-cn/software-download/windows11 Office 2021专业增强版（推荐）： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2021Retail.img 专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2021Retail.img 家庭学生版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeStudent2021Retail.img 家庭企业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeBusiness2021Retail.img 独立版（不推荐）： Word：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Word2021Retail.img Excel：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Excel2021Retail.img PowerPoint：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/PowerPoint2021Retail.img Outlook：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Outlook2021Retail.img Access：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Access2021Retail.img Publisher：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Publisher2021Retail.img Visio 2021Visio标准版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioStd2021Retail.img Visio专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2021Retail.img Project 2021Project标准版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectStd2021Retail.img Project专业版： http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2021Retail.img","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Windows&Office%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"},{"title":"Gif动图工具","text":"生成gif动图的五款工具LICEcap 一款比较专业的gif截屏工具，每帧的颜色数量可达到200多个，而且这款工具的体积只有几百KB,除了可以保存GIF格式还支持LCF格式的录制。 ScreenToGif 一款体积非常轻便，而且完全免费的GIF录屏工具，它可以将你录制的GIF图进行再次编辑，还能添加滤镜效果。 GIFGIF 一款小到可怕的GIF录制工具，它的体积大小只有123kb，能满足基本的录制功能并且操作非常简单。 Ulead GIF Animator 一款专业的GIF制作工具，制作界面类似于PS时间轴的制作界面，但是他不能直接录取画面生成GIF动图，只能对视频以及GIF动图进行编辑，还有海量的滤镜和转场效果，并且还能将现有的GIF进行优化。 GifCam 一款很聪明的GIF录屏工具，它能通过多画面的计算，将截取区域相同的部分自动删除，如果对截取区域没有操作，它会将此帧的画面延长，从而使你录制的GIF文件非常小。","link":"/2023/01/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/gif%E5%8A%A8%E5%9B%BE%E5%B7%A5%E5%85%B7/"},{"title":"如何高效的使用Google","text":"转载自 GarveyZhong https://blog.imzjw.cn/posts/aae542e3/ 前言今天在 Dev 社区看到的这篇帖子，虽然自己天天用 Google，但是这些技巧却不是那么的熟悉，所以分享给大家。 原文：Use Google like a pro 译：小嘉的部落格 谷歌搜索是每个开发人员最重要的技能之一。 让我告诉您如何更好地使用 Google。 开始吧！ 使用引号精确匹配搜索e.g &quot;what is javascript&quot; AND 运算符只会返回与他们都相关的结果 e.g html AND css OR 运算符获取与其中一个搜索词相关的结果 e.g (javascript OR python) free course 除此之外还有 | 也是和 OR 一样 - 运算符排除包含搜索词的结果 e.g javascript -css 所以搜出来的结果都是与 javascript 相关 * 通配符作为占位符，会被任何单词或短语替换。 e.g &quot;how to start * in 6 months&quot; site:在单个网站内搜索，这样搜索出来都是与该网站相关的结果，一般想看自己的网站是否被搜索引擎收录了，都可以用 site: e.g site:blog.imzjw.cn 还可以将搜索范围限制为域名后缀，例如 site:com、site:cn、site:org filetype查找特定的文件类型。 e.g filetype:pdf learn css 此外 ext 也是和 filetype 一样 e.g Java ext:pdf 搜索一系列的数字e.g ecmascript 2016..2018","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8Google/"},{"title":"你的电脑为什么不能看4K Netflix","text":"先说一个快捷键Window端通过按下CTRL + SHIFT + ALT + D/Q来查看当前分辨率。 有时候，您只需要耐心首次开始流式传输某些内容时，流式传输可能需要一段时间才能达到其最佳质量设置。为了减少加载时间，较高质量的流将在后台开始缓冲，而较低质量的流将立即播放。 有时，您只需要等待Netflix赶上来即可。您可以随时尝试暂停您的内容并等待几秒钟。即使您在配置文件首选项中将质量设置为“高”，Netflix仍默认在流开始时或连接不良时将其质量降低。 若等待一段时间仍未达到4K，那么通过以下的方法一定可以找到原因。 显示器及显卡要求一、拥有至少支持UHD 4K,60Hz的显示器或电视机,什么牌子都行,且显示器上至少有HDMI2.0及以上接口或者DP1.3及以上接口(尤其注意DP1.2及以下接口不支持HDCP2.2,所以不能看奈飞4K；其次分辨率必须要到38402160才算达标,38401660这种假4K是不行的) 。 二、支援HDMI2.0/a/b或支援DP1.3/1.4的传输线(2021年推荐直接买HDMI2.1或者DP2.0的传输线) 。 三、独立显卡方面: NVIDIA：需要至少GeForce GTX 1050或更高版本显卡+3GB或更高的显存+387.96或更新的驱动程序 AMD：由于AMD对DRM防盗版机制的跟进非常缓慢，目前仅旗下Polaris系列显卡（例如RX470/480/570/580/590），或者Navi系列显卡（例如RX5500/5600/5700）支持观看奈飞4K，Vega系列所有显卡因为不支持Microsoft Playready3.0 DRM，所以全部不能看奈飞4K；对于支持的显卡，需要Adrenalin 2019 Edition 19.8.1或更新的驱动程序。 常见浏览器播放Netflix视频时最高支持的分辨率 (补充：表格较老，最新的safari已经支持4KNetflix了） HEVC视频扩展要观看Netflix 4K视频一定需要下载此扩展才可以，通常微软商店里下载使用是收费的，但是来自厂商的 HEVC 视频扩展在大部分电脑上是免费的。 免费版地址 任意浏览器输入下面地址： ms-windows-store://pdp/?ProductId=9n4wgh0z6vhq 或者点击下面的链接： 来自设备制造商的 HEVC 视频扩展 - Microsoft Store 应用程序 收费版地址： https://www.microsoft.com/zh-cn/p/hevc-video-extensions/9nmzlz57r3t7?activetab=pivot:overviewtab 然后就是网速要跟得上，4K最少30mb的速度，可以去fast.com测试。 总结Netflix 可在 Windows 电脑或平板电脑上支持超高清格式。 如需流媒体播放超高清内容，您需要： 已安装最新 Windows 更新的 Windows 10 或 Windows 11。 必须安装 HEVC 视频扩展。 注意：许多 Windows 10 和 Windows 11 设备可以免费安装 HEVC 视频扩展，但是部分电脑需要从 Microsoft 处购买才可以安装。 如果您不确定或需要安装视频扩展方面的帮助，请联系设备制造商。 Microsoft Edge 浏览器或者适用于 Windows 的 Netflix App。 支持 60Hz 4K 的显示器（如果是外接显示器，需要 HDCP 2.2 连接）。 注意：1. 连接至您的电脑的每一台显示器都必须满足这些要求才能以超高清格式进行流媒体播放。 ​ 2. HDCP 2.2 需要显卡接口、显示器接口、传输线都满足 HDMI2.0或者DP1.4以上。 如果使用集成 GPU：Intel 第 7 代酷睿 CPU 或更新版本的 CPU，或 AMD Ryzen CPU。 如果使用独立 GPU：符合这些要求的 Nvidia Geforce GPU，或 AMD Radeon RX 400 系列或更新版本的 GPU。 支持流媒体播放超高清内容的 Netflix 套餐。 15 Mbps 或更快的稳定互联网连接速度。 流媒体播放画质设置为“自动”或“高”。 以上所说的要求有任何一个不满足，在视频介绍中都不会出现4K标签，也就代表着无法播放4K分辨率播放。 使用软件检查终极大法：如果还是不能看并且找不到原因，下载测试软件 https://cn.cyberlink.com/prog/bd-support/diagnosis.do 安装后如上图操作可得到下图结果： 对于框框中的三项即可，这三项都满足，是一定可以观看Netflix的4K视频的，如果都满足依然无法播放，可能是网络的原因。 HEVC-10bit部分没有通过则说明： 微软的HEVC插件没有购买安装； 显卡太旧，不支持10位HEVC解码； HDCP2.2部分没有通过则说明： 显示器不是HDMI2.0或者DP1.4以上接口； 没有使用HDMI2.0及以上或者DP1.4及以上的传输线； 显卡不是HDMI2.0或者DP1.4以上接口； 参考视频： 用PC显示器正确看奈飞4K片源|下载微软免费HEVC视频扩展插件|换区下载奈飞APP - YouTube","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9C%8B4K%20Netflix/"},{"title":"简易教程-Clash-自定义在线分流规则策略组","text":"转载自：简易教程 | Clash | 自定义在线分流规则策略组 - Yatta漫游小镇 简介Clash for Windows（CFW）应该是目前Windows和macOS上最好用的基于规则的跨平台代理工具软件，允许用户可视化操作和支持主流SS/V2ray/Trojan多协议。Clash.Net在此基础上对UI进行了美化，也推荐使用。 已经上手Clash的用户大都是在用ACL4SSR或其他大佬的维护的分流策略，他们的规则策略其实已经能满足绝大部分用户的使用场景，但是还有一小撮用户（比如我）由于工作或者个人使用习惯的差异，有些分流没有包含这些差异在内，这时统一使用Final（漏网之鱼）来回切换就比较麻烦，因此这种情况下，制作属于自己的分流规则策略组还是很有必要的。 将折腾过后得出的方法分享给大家，少走点弯路。本教程理论上适用于所有Clash内核的代理工具，如Clash X Pro，Clash for Android（CFA）以及路由器版的OpenClash。 👇🏼 教程整体逻辑 👇🏼 → 制作线上分流规则和策略组文件→ 转码托管机场订阅和分流策略组文件地址→ 将转码后的分流策略组文件地址正确放入订阅转换API链接中→ 导入最终配置文件链接到CFW 制作线上分流规则和策略组这一步是为了创建符合你使用习惯的分流规则 .list 和策略组 .ini 文件。原则上只要有一个可以线上读写维护的库就可以，这里推荐Github库和VPS，本文仅以Github版教程抛砖引玉，VPS版就是现在本地写好再传到服务器就好了。 一般情况下，并不是所有分流规则完全都要自己写，大部分可以使用大佬维护的分流规则，然后写自己需要的分流规则，最后整理出自用分流策略组文件。 分流规则库推荐 👉🏼 注册一个Github账号，有邮箱就能注册。（已有跳过这步） 获取正确Github链接地址：点开所需文件，在右上方点 **Raw**，然后完整拷贝浏览器 raw.githubusercontent 开头的链接地址。 ACL4SSR的库:https://github.com/ACL4SSR/ACL4SSR/tree/master/Clash blackmatrix7的库:https://github.com/blackmatrix7/ios_rule_script/tree/master/rule/Clash 神机规则库:https://github.com/DivineEngine/Profiles/tree/master/Clash/RuleSet 分流规则参考使用 .list 后缀文件。 如果参考的分流规则是 .yaml 后缀文件，建议先只选取部分需要的规则，然后复制转移或 fork 该规则到个人Github库中，把 - 字段用全部替换的方式删掉，再重命名为 .list 后缀文件。 制作自用分流规则 命名：文件命名随意，但是一定是英文+以 .list 结尾。 英文的 ; 和 # 都是常用的注释符号，表示该行代码不会生效，常用于代码前的分类和备注。 👉 常用规则写法参考: 12345# 表示包含xxx.com域名后缀下的所有网站链接DOMAIN-SUFFIX,xxx.com# 表示包含这个xxxx域名关键词的所有网站链接DOMAIN-KEYWORD,xxxx 👉 以PayPal分流规则为例： 12345# PayPalDOMAIN-SUFFIX,paypal.comDOMAIN-SUFFIX,paypal.meDOMAIN-SUFFIX,paypalobjects.comDOMAIN-KEYWORD,paypal 👇 更多写法可以参考Clash文档 👇 https://docs.cfw.lbyczf.com/contents/ui/profiles/rules.html 制作分流策略组 命名：文件命名随意，但是一定是英文+以 .ini 结尾。 .ini 配置文件中：ruleset 指的是配配置中包含的分流规则，custom_proxy_group 指的是最终在Clash中呈现的分流策略组及其排序。 ruleset 排序原则：重要直连分流规则 &gt; 去广告规则 &gt; 小分流 &gt; 国内外大分流 &gt; 补充规则。 策略组的排序非常重要，因为分流策略组的匹配是按照至上而下收录，匹配到了就停止不再往下，比如YouTube规则要放在国外媒体前面，而完整的国外媒体规则包含了YouTube, Netflix, Pornhub等等，所以分流规则较大要放在YouTube小分流规则后面。 👉 分流策略组模板参考： ACL4SSR的配置文件：https://raw.githubusercontent.com/ACL4SSR/ACL4SSR/master/Clash/config/ACL4SSR_Online_Full.ini 👉 分流策略组文件说明： 一般情况下，只需要对 ruleset 和 custom_proxy_group 进行修改即可，其他地方不懂就不改。 ruleset 和 custom_proxy_group 中分流规则和策略组自定义命名要完全对应，但是可以几个同命名而不同地址的 .list 分流规则对应一个策略组。 📌 举个例子：我创建3条 ruleset 分流规则并链接到Github的地址，且全部都命名 全球直连 ，那在 custom_proxy_group 中命名为 全球直连 策略组会全部应用上面三条分流规则。 👉 Ruleset说明：逗号前的红框位置为该分流规则的命名，逗号后为该分流规则.list后缀的地址链接，如果规则同名最终会共同叠加生效。 👉 Custom_proxy_group说明：这个分组为在CFW图形界面最终呈现的策略组排序。**Select** 后面有多少 []XXXX 代表该策略组有多少种规则可以选，可以自定义，一般用 上飘点 分隔，最后一项后不需要加 **上飘点**。 12345678910# 以下代码是CFW默认自带的，不用特意再写，结合上图，按需设置策略组的选项→ DIRECT: 直连 → REJECT: 该规则下不走网络活动，常用于广告拦截→ .*: 表示加入你订阅中所有节点 → url-test: 表示有该代码下的节点会自动测速 # 自动归类节点 - 以图片中香港节点策略组为例→ (港|HK|Hong Kong)代表具有&quot;港&quot;，&quot;HK&quot;，&quot;HongKong&quot;关键词的节点会归类到香港节点这个策略组中，测速以 http://www.gstatic.com/generate_204`300,,50为准。 提交上传配置文件 ⚠️温馨提示⚠️ 在GitHub上面几步改好的 .list 和 .ini 文件，要点 Commit Change 提交，再去拷贝 Raw 文件链接。 转码托管 - 机场订阅和策略组这里只要用到两种链接，一种是你的机场订阅链接，另一种则是你先前编辑好 .ini 分流策略组配置的链接。 转码托管机场链接这一步是利用开源订阅转换API转码你的机场订阅链接，如果有网易云解锁节点链接也可以加入一并转换。 一般情况下，这些订阅转换API转码不会保存你的节点信息。通俗来说，只是把你的字符转换成另外一种计算机语言，并套进对应的代理工具软件配置参数的链接中，不放心且有能力的也可以自己搭建API。 🔗订阅转换托管API推荐： ACL4SSR 在线订阅转换 边缘@订阅转换API 👉 转换托管步骤 输入的订阅/节点链接，选择生成类型，这里我们默认选 **Clash**（也有叫Clash新参数的） 点生成订阅链接，获得转码后的链接地址，下面是按照图内的地址转码后得到的结果： 12345678910# 温馨提示：往右拖动还有内容# 该配置文件地址还没有嵌入策略组地址信息# 这里以我截图乱填的一个个订阅地址为例https://pub-api-1.bianyuan.xyz/sub?target=clash&amp;url=https%3A%2F%2Fcate.com&amp;insert=false# 预留一下策略组配置文件地址位置，在上面链接的基础上合并下面这串代码&amp;insert=false&amp;config=peizhiwenjian&amp;emoji=true&amp;list=false&amp;udp=false&amp;tfo=false&amp;scv=false&amp;fdn=false&amp;sort=false# 如果订阅支持udp, tfo就把这两项后面的false改成true，默认为false，加完后完整链接为：https://pub-api-1.bianyuan.xyz/sub?target=clash&amp;url=https%3A%2F%2Fcate.com&amp;insert=false&amp;config=peizhiwenjian&amp;emoji=true&amp;list=false&amp;udp=false&amp;tfo=false&amp;scv=false&amp;fdn=false&amp;sort=false 转码分流策略组先前我们已经编辑好我们自定义的 .ini 后缀的分流策略组配置文件，在Github上，我们要拷贝这个文件的 Raw 地址，这个地址才是文件的源地址。 上图页面并不是**.ini**文件的地址，实际上此文件是存储在Raw地址的： 👉 转换策略组步骤 在https://www.urlencoder.org/ 上转码，按照下图步骤。 把转码后链接地址粘贴在下方链接中 peizhiwenjian 处即可成功获得最终的配置文件。 12345# 温馨提示：往右拖动还有内容# &amp;insert 前为先前通过`api.dler.io`转换后的订阅地址# peizhiwenjian 替换成你转码后配置文件地址，一定是.ini结尾的https://pub-api-1.bianyuan.xyz/sub?target=clash&amp;url=https%3A%2F%2Fcate.com&amp;insert=false&amp;config=peizhiwenjian&amp;emoji=true&amp;list=false&amp;udp=false&amp;tfo=false&amp;scv=false&amp;fdn=false&amp;sort=false 导入配置文件地址到Clash按照图示导入最终的配置文件到 CFW 或 **Clash.Net**，完结撒花！ API有可能会被墙，建议在编辑自用分流规则时加入你使用的订阅转换API域名。 每次Github的配置文件修改后，由于缓存的原因，CFW建议过一两分钟再点更新配置文件。 使用托管API得到的链接，更新时会偶尔套用失效，应该是服务器问题，等待一两分钟再次更新就好了。","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B-Clash-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%BA%BF%E5%88%86%E6%B5%81%E8%A7%84%E5%88%99%E7%AD%96%E7%95%A5%E7%BB%84/"},{"title":"腾讯云CDN加速COS图床","text":"准备首先你得有个备案了的域名，之前腾讯云是可以支持默认CDN加速域名的，不过目前已经无法使用了，因此我们只能使用自定义域名了。 腾讯云：对象存储 开启默认 CDN 加速域名-控制台指南-文档中心-腾讯云-腾讯云 自2022年5月9日起，对象存储（Cloud Object Storage，COS）服务将不再支持新增默认 CDN 加速域名。您已开启、或曾经开启的默认 CDN 加速域名不会受到影响，可以继续使用，但建议您使用自定义 CDN 加速域名代替默认 CDN 加速域名。关于自定义 CDN 加速域名的操作指引，请参见 开启自定义 CDN 加速域名 文档。 接入域名步骤如下： 开通 CDN 服务配置 CDN 前，您需要 开通 CDN 服务。如果您已开通 CDN 服务，请继续后续操作步骤. 操作步骤进入 CDN 控制台，在左侧导航栏中找到域名管理，单击添加域名。 域名配置 选择加速区域 填写加速域名 如果您接入的域名为以下情况，则需要进行域名归属权验证，验证步骤请参考下方： 首次接入该域名。 该域名已被其他用户接入。 接入域名为泛域名。 选择加速类型 其他选填项(后续可在域名管理中更改) 域名配置 我只有一个备案了的域名，因此我选择使用此域名加前缀子域名作为我的加速域名 由于我已经做过了CDN接入，因此这里不在显示需要验证，通常我们还需要DNS解析验证，步骤如下： DNS 解析验证操作步骤 单击验证方法，获取 DNS 验证所需要的解析记录信息，在验证完成前保持页面打开。 如果您的域名解析商为腾讯云，进入 域名服务控制台，找到该域名并单击解析，添加一条记录类型为 TXT 的 DNS 记录，主机记录填写为 _cdnauth。如果您的域名解析商为阿里云，同样找到该域名并单击解析，添加一条记录类型为 TXT 的 DNS 记录，主机记录填写为 _cdnauth。 如果您的域名解析商为阿里云，进入域名服务控制台，找到该域名并单击解析，添加一条记录类型为 TXT 的 DNS 记录，主机记录填写为 _cdnauth。 等待 TXT 解析生效，单击验证按钮进行验证。 注意： 为接入域名验证归属权添加 TXT 记录，无论接入的是三级域名（如：a.test.com）还是多级域名（a.b.test.com），均是在主域名（test.com）下进行的，主域名前的主机记录值填写为：_cdnauth。 源站配置 选择源站类型 选择回源协议 输入源站地址 配置回源 HOST 我们使用的是腾讯云的COS源直接选择就好，回源协议就选择https，如果你的存储桶是私有读写，那么开启私有桶访问权限。 由于是COS源不需要我们去输入地址，腾讯云中可以直接选择。 回源HOST会在源站地址选择后自动填入，不需要手动输入。 服务配置由于我并没有大文件资源，因此不需要开启分片回源（这里根据个人需求选择） 用量封顶配置根据个人需求选择，这里我是默认配置； 全部配置结束后点击“确认提交” 接入完成完成添加域名操作后，请耐心等待域名配置下发至全网节点，下发时间约5 - 10分钟。 解析CDN域名当您在腾讯云 CDN 内成功完成添加域名后，腾讯云 CDN 会为您的域名分配一个专属的 CNAME 地址，您还需要完成 CNAME 配置，才可以将用户的访问指向腾讯云 CDN 节点，使CDN加速生效。 返回域名管理，在您域名成功解析前，CNAME 处会有提示 icon。复制此处的 CNAME 值。 进入您的域名解析商域名控制台，我这里用的是阿里云。 单击要解析的域名，进入解析记录页。 进入解析记录页后，单击添加记录按钮，开始设置解析记录。 （这里我添加pic子域名域名进行演示） 将记录类型选择为 CNAME。主机记录即域名前缀，可任意填写（如：pic）。记录值填写为步骤1中复制的CNAME值。解析线路，TTL 默认即可。 注意：这里我的图片配得有点问题，应该是使用哪个自定义域名就添加相应的CNAME的解析记录，我有两个自定义CDN域名，由于imge.xinsong.xyz已经在使用了，所以这里我使用了pic.xinsong.xyz来演示。 验证 CNAME 是否生效不同的 DNS 服务商CNAME 生效的时间略有不同，一般在半个小时之内生效。您可以通过 nslookup 或 dig 的方式来查询 CNAME 是否生效，若应答的CNAME记录是我们配置的CNAME，则说明配置成功，此时您已成功开启加速服务。 这里我使用dig的方法验证。 打开CMD ，命令行输入dig + 你的自定义域名； 配置CDN域名进入CDN控制台—&gt;域名管理—&gt;要配置的域名 访问控制可以进行防盗链配置以及ip黑白名单等，这里我仅仅设置了ip限频 根据个人需求配置即可。 申请ssl证书通常一个ssl证书只能绑定一个域名，即使是子域名也是需要的。因此还需要申请一个证书并且绑定我们的CDN域名。 腾讯云提供了免费的证书申请，期限为一年过期了重新申请就行。 申请免费证书：https://cloud.tencent.com/document/product/400/6814 流程： 比较简单，具体参照官方文档。 添加证书申请结束后，进入“https配置”中添加证书； 腾讯云中申请的证书由腾讯云托管，我们选择已托管证书中添加证书。 https配置指南：https://cloud.tencent.com/document/product/228/41687 配置https，建议如下图更改 打开HTTPS 2.0； 开启HTTPS强制跳转； Picgo配置到这里就可以使用我们的CDN域名了。 进入Picgo腾讯云COS设置： 这里只用修改两个东西 存储路径：随便一个名字 设定自定义域名：将您接入的域名填入“设定自定义域名”一栏 验证图片上传选项 到此就结束了，我们可以使用腾讯云提供的CDN服务了。 参考文章： 对象存储 开启自定义 CDN 加速域名-控制台指南-文档中心-腾讯云 内容分发网络 CDN 接入域名-快速入门-文档中心-腾讯云 内容分发网络 CDN 配置 CNAME-快速入门-文档中心-腾讯云 内容分发网络 CDN 配置指南-文档中心-腾讯云 内容分发网络 CDN 域名配置-配置指南-文档中心-腾讯云 腾讯云cos接入腾讯cdn加速图床 - it小离","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9FCOS%E5%9B%BE%E5%BA%8A/"},{"title":"排序简介","text":"排序的概念及其运用 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 内部排序：数据元素全部放在内存中的排序。 外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 排序的应用例如大学排名： 分类 计算的时间复杂度（最差、平均、和最好性能） 内存使用量（以及其他电脑资源的使用） 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序 依据排序的方法：插入、交换、选择、合并等等。 常见的排序算法虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。","link":"/2023/01/13/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B/"},{"title":"腾讯云COS+Picgo搭建图床","text":"写在前面jsDelivr凉了，因此一直在寻找新的个站图片存储方案，最终还是觉得腾讯云的对象存储服务比较合适，在此分享折腾的过程。 先来介绍两个概念： 对象存储 对象存储（Cloud Object Storage，COS）是腾讯云提供的一种存储海量文件的分布式存储服务，用户可通过网络随时存储和查看数据。腾讯云 COS 使所有用户都能使用具备高扩展性、低成本、可靠和安全的数据存储服务。COS 通过控制台、API、SDK 和工具等多样化方式简单、快速地接入，实现了海量数据存储和管理。通过 COS 可以进行任意格式文件的上传、下载和管理。腾讯云提供了直观的 Web 管理界面，同时遍布全国范围的 CDN 节点可以对文件下载进行加速。 存储桶 存储桶（Bucket）是对象的载体，可理解为存放对象的“容器”，且该“容器”无容量上限。对象以扁平化结构存放在存储桶中，无文件夹和目录的概念，用户可选择将对象存放到单个或多个存储桶中。 购买对象存储(cos)资源包购买链接：https://curl.qcloud.com/CcQyuzkZ 创建存储桶列表 这里是因为我用做来做个人图床，所以考虑到自己的一个用量，10G完全满足我了。其中流量中的外网下行流量包(图片访问一次就会产生费用)，和CDN回源流量包(CDN节点向 COS 获取数据所产生的CDN回源流量)，其实也要购买的，但是我是小站，用不了那么多，直接选择按量计费，不选择购买这两个的资源包，余额准备几块钱就好了。 来到腾讯云对象存储控制台，创建存储 高级配置可以不去管它 访问权限选择公有读私有写，否则图片无法读取，其他的根据自己往下填写就可以。 地域建议离你所在的位置越近越好。 腾讯云头像–&gt;访问管理–&gt; API密钥管理，创建密钥，就会生成 APPID、SecretId和SecretKey 配置Picgo 打开 PicGO； 进入腾讯云COS设置 填写好前面三个信息后，存储空间名和区域的信息在刚刚创建对象存储控制台那里，这里注意的是，COS版本选择 v5 ； 设定存储空间名是存储桶的名字； 存储区域通常是ap-刚刚选择的地区名 指定存储路径选择img/，暂时不需要填写自定义域名； ​ 记得设置为默认图床，否则picgo不会默认上传到COS； 配置Typora 勾选本地和网络位置的图片使用上传规则，如图； 验证图片上传选项成功即可。 到此，就可以直接使用Picgo上传图片了，这时图片的链接是 https://sxnico-imgaes-1310265079.cos.ap-chengdu.myqcloud.com（对于我而言，取决于你的存储桶名称） COS也支持公网直接访问，但是流量费太贵，直接访问不划算，况且腾讯云还每个月会赠送10G的免费CDN流量，完全可以利用起来。 对于访问量少的站点来说完全足够了，不过这还不够好，最近注意到腾讯云COS+CDN的搭配既能不占用服务器的宽带，又能快速上传下载文件，而且以我目前的使用量来说基本上不花钱，这里分享下我的折腾过程，在我的另一篇文章中。 参考文章： 腾讯云COS对象存储+PicGo搭建图床教程 - 腾讯云开发者社区-腾讯云 腾讯云COS搭建图床-it小离","link":"/2023/01/12/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%85%BE%E8%AE%AF%E4%BA%91COS+Picgo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"title":"快速排序","text":"简介快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！ 至于为什么就是比相同时间复杂度的算法快，参考《算法艺术与信息学竞赛》如下信息： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。 步骤为： 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。 选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。 算法图示： 挑选基准值选取基准值有数种具体方法，我们从最基本的开始。 基准值是可以任意选取的，那么最简单的我们通常选用待排序序列中的第一个元素作为基准值，但是伴随着一些问题，所以常常采用如下两种方式： 随机选取基准值。 选取区间两端和中间的数据中的中位数作为基准值。 分割升序序列： 将比基准值大的数都放在基准值后面，比基准值小的数放在基准值的前面 降序序列： 将比基准值大的数都放在基准值前面，比基准值小的数放在基准值的后面 常用方法： hoare 挖坑法 快慢双指针 递归子序列递归的可靠性 基准的左边全都是小于基准的值，而基准的右边全是大于基准的数，说明基准数在排序后的位置是不变的，那么将左子序列和右子序列分别排序，那么这个序列一定是有序的。于是我们递归调用快排将左子序列和右子序列排序，就可以完成排序。 结束条件 如果当前序列已经没有元素或者仅仅只有一个元素，那么我们认为此序列已经有序，无需排序，结束递归。 递归优化 定义排序n个元素问题为 T(n)。 递归的最好情况是每一此递归的序列选取的基准值都是中位数，那么相当于每次将序列二分，分成两个子问题T(n/2)，因此可以看作递归一颗高度为 log(n) 的二叉树，每一层分割时间复杂度都是O(n)，所以时间复杂度为O(nlog(n)). 最坏情况是每一次递归的序列选取的基准值都是当前序列中的最大值或最小值，那么它会被分割子问题T(1)和T(n - 1)，那么那么递归次数是线性的，每一层分割的时间复杂度都是O(n)，所以时间复杂度为O(n2)。 因此对于一些特殊情况下需要排序的序列，例如本就是单调的序列，那么应避免使用序列两端的值作为基准。 有如下处理方法。 三数取中法选基准值 随机取基准值 观察log(n)的图像： 随着x的增大斜率是逐渐减小的，也就是说在x较大时，x的变化引起的y的变化更小，因此，在数值较大时，log(n)比n要小得多，而在x较小时（通常为x &lt; 8），它们之间得差别并不大，但是栈帧的开辟的开销是比较大的，这时候只需要排序几个数时，递归所带来的栈帧开销就显得比较浪费资源。 所以在数据个数较少时，为了减少栈帧得开销，可以选择插入排序的策略。（个人认为不会带来很大的效率提升，在release版本下栈帧的开辟优化后与使用插入法效率上的差异并不大。） 如下处理方法： 递归序列元素个数较少时采用插入排序 挑选基准值以及分割子区间既然有用到递归，那么代码通常会比较简洁，我们先统一选取第一个元素为基准值作为示范，展示几种不同的方法分割序列。 hoare考虑定义双指针 left , right 分列数组左右两端，循环执行： 指针 right 从左向右寻找比基准值大的数； 指针 left 从右向左寻找比基准值小的数； 将 arr[left] 和 arr[right] 交换。 可始终保证： 指针 left 左边都是小于基准值的数，指针 right 右边都是大于基准值的数。 算法流程： 初始化： 初始化left, right 双指针，分别指向数组 arr 左右两端； 循环交换： 当 left = right 时跳出； 指针 right 遇到比基准值小的值则执行 right-- 跳过，直到找到大于基准的值； 指针 left 遇到比基准值大的值则执行 left++ 跳过，直到找到小于基准的值； 交换 arr[left] 和 arr[right] 值； 注意：left指针和right指针的谁先移动很重要，这决定了最终left和right会停留在小于基准的最后一个位置还是停留在此位置的下一个位置。 动图如下： 代码： 123456789101112131415int PartSort(int* arr, int left, int right){ int keyi = left; int key = arr[keyi]; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) --right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) ++left; swap(arr + left, arr + right); } swap(arr + keyi, arr + left); return left;} 优化三数取中法选基准值 1234567891011121314151617181920212223242526272829int GetMid(int* arr, int left, int right){ int mid = left + (right - left) / 2; if (arr[left] &lt; arr[mid]) swap(arr + left, arr + mid); if (arr[left] &lt; arr[right]) swap(arr + left, arr + right); if (arr[mid] &lt; arr[right]) swap(arr + mid, arr + right); return mid;//返回中间值的下标}int PartSort(int* arr, int left, int right){ int keyi = GetMid(arr, left, right); int key = arr[keyi]; swap(arr + keyi, arr + left);//将key与left交换，后面的过程即与前面相同 keyi = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) --right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) ++left; swap(arr + left, arr + right); } swap(arr + keyi, arr + left); return left;} 随机选取基准值 1234567891011121314151617int PartSort(int* arr, int left, int right){ int keyi = left + rand() % (right - left + 1); int key = arr[keyi]; swap(arr + keyi, arr + left); keyi = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) --right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) ++left; swap(arr + left, arr + right); } swap(arr + keyi, arr + left); return left;} 注意：此方法的两指针的遍历顺序和基准值的选取位置有关，基准值在最右和最左边是是不相同的两种情况。 挖坑法考虑定义双指针 left , right ，和分列数组左右两端和变量key，循环执行： 将第一个数据存储在key中，形成一个坑位； 指针 right 从右向左寻找比基准值小的数； 找到后将数据填入之前的坑位，并且此数据的位置形成新的坑位； 指针 left 从左向右寻找比基准值大的数； 找到后将数据填入之前的坑位，并且此数据的位置形成新的坑位； 可始终保证left的左边都是小于基准的值，right右边都是大于基准的值 算法流程： 初始化 left，right双指针，分别指向数组arr的左右两端，key存储arr[left]的值作为基准； 循环填坑，当left=right时跳出； 指针 right 遇到比基准大的数则 right--跳过，直到遇到比基准小的值； 将找到的值填坑，并更新坑的位置为当前位置； 指针 left 遇到比基准小的数则 left++跳过，直到遇到比基准大的值； 将找到的值填坑，并更新坑的位置为当前位置； 动图如下： 代码： 12345678910111213141516171819int PartSort(int* arr, int left, int right){ int keyi = left; int key = arr[left]; int pit = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) right--; arr[pit] = arr[right]; pit = right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) left++; arr[pit] = arr[left]; pit = left; } arr[pit] = key; return pit;} 优化三数取中法选基准值 1234567891011121314151617181920212223242526272829303132int GetMid(int* arr, int left, int right){ int mid = left + (right - left) / 2; if (arr[left] &lt; arr[mid]) swap(arr + left, arr + mid); if (arr[left] &lt; arr[right]) swap(arr + left, arr + right); if (arr[mid] &lt; arr[right]) swap(arr + mid, arr + right); return mid;}int PartSort(int* arr, int left, int right){ int keyi = GetMid(arr, left, right); swap(arr + left, arr + keyi); int key = arr[left]; int pit = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) right--; arr[pit] = arr[right]; pit = right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) left++; arr[pit] = arr[left]; pit = left; } arr[pit] = key; return pit;} 随机选取基准值 1234567891011121314151617181920int PartSort(int* arr, int left, int right){ int keyi = rand() % (right - left + 1) + left; swap(arr + left, arr + keyi); int key = arr[left]; int pit = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) right--; arr[pit] = arr[right]; pit = right; while (left &lt; right &amp;&amp; arr[left] &lt;= key) left++; arr[pit] = arr[left]; pit = left; } arr[pit] = key; return pit;} 快慢双指针考虑定义前后双指针于序列头部，循环执行： 双指针 cur 和 prev ，cur 在前， prev 在后 ； cur 的作用是向前搜索比基准值小位置 ，prev 的作用是指向存放当前小于基准值的最后一个位置； cur 向前移动，当它搜索到大于基准值的数时，将它和 arr[++prev] 交换，此时 prev 向前移动一个位置 ； 可始终保证prev的左边全为比基准值小的数，prev和cur之间全为比基准值大或者等于基准的数； 算法流程： 初始化：prev指向序列的第一个元素，cur指向序列的第二个元素； 循环交换：直到cur遍历完所以元素； 指针cur遇到大于基准的数则cur++跳过，直到遇到小于基准的数； ++prev，交换arr[cur] 和 arr[prev]的值，++cur继续遍历; 动图如下： 代码： 1234567891011121314int PartSort(int* arr, int left, int right){ int prev = left; int cur = left + 1; int key = arr[left]; while (cur &lt;= right) { if (arr[cur] &lt;= key &amp;&amp; arr[++prev] != arr[cur])//这里也可以写成++prev != cur swap(arr + prev, arr + cur); ++cur; } swap(arr + prev, arr + left); return prev;} 优化三数取中法选基准值 12345678910111213141516171819202122232425262728int GetMid(int* arr, int left, int right){ int mid = left + (right - left) / 2; if (arr[left] &lt; arr[mid]) swap(arr + left, arr + mid); if (arr[left] &lt; arr[right]) swap(arr + left, arr + right); if (arr[mid] &lt; arr[right]) swap(arr + mid, arr + right); return mid;}int PartSort(int* arr, int left, int right){ int keyi = GetMid(arr, left, right); swap(arr + left, arr + keyi); int prev = left; int cur = left + 1; int key = arr[left]; while (cur &lt;= right) { if (arr[cur] &lt;= key &amp;&amp; arr[++prev] != arr[cur])//这里也可以写成++prev != cur swap(arr + prev, arr + cur); ++cur; } swap(arr + prev, arr + left); return prev;} 随机选取基准值 12345678910111213141516int PartSort(int* arr, int left, int right){ int keyi = rand() % (right - left + 1) + left; swap(arr + left, arr + keyi); int prev = left; int cur = left + 1; int key = arr[left]; while (cur &lt;= right) { if (arr[cur] &lt;= key &amp;&amp; arr[++prev] != arr[cur])//这里也可以写成++prev != cur swap(arr + prev, arr + cur); ++cur; } swap(arr + prev, arr + left); return prev;} 由于cur要找的是小于基准的值，而prev和cur之间都是大于等于基准的值，只有prev和cur紧挨着才会出现arr[++prev]=arr[cur]的情况，因此条件可改为++prev != cur； 递归子序列代码实现： 12345678void QuickSort(int* arr, int left, int right){ if (left &gt;= right) return; int pos = PartSort3(arr, left, right); QuickSort(arr, left, pos - 1);//递归左子序列 QuickSort(arr, pos + 1, right);//递归右子序列} 如图所示，随着递归深度的增加，栈帧的开辟个数也逐层递增，最终会变成只拥有一个元素或者零个元素的子问题，而对于这些一个元素的序列甚至零个元素的序列，也开辟了一块栈帧，而这是完全没有必要的，栈区的资源非常有限，这样做实在浪费，因此我们在处理这种较少规模的问题时，可以采用数据量少时（通常是元素个数小于8）可以使用整体性能比较好的插入排序作为小规模问题的补充。 递归优化： 123456789101112131415161718192021222324252627282930void InsertSort(int* arr, int sz){ int i = 0; for (i = 1; i &lt; sz; i++) { int j = 0; int tmp = arr[i]; for (j = i - 1; j &gt;= 0; j--) { if (arr[j] &lt; tmp)//遇到了比目标小的数，不在向前遍历，break break; arr[j + 1] = arr[j]; } arr[j + 1] = tmp;//插入到最后一个比较数据的后面 }}void QuickSort(int* arr, int left, int right){ if (left &gt;= right)//只有一个或0个元素时已经有序，无需排序 return; if (right - left + 1 &lt;= 8)//子序列元素较少时停止递归而采用插入排序，减少栈帧的开销。 { InsertSort(arr + left, right - left + 1);//插入排序序列的首地址以及元素个数 return; } int pos = PartSort3(arr, left, right); QuickSort1(arr, left, pos - 1); QuickSort1(arr, pos + 1, right);} 非递归版模拟压栈 快速排序的递归方法是先对当前序列进行分割，在递归的去分割基准的左右子序列，就像是二叉树的前序遍历或者是层序遍历，因此我们可以自己写出一个栈来模拟逐层分割这个过程。 每一次递归我们的传参都是序列的首地址以及左右边界区间，因此我们模拟这个过程时压入栈中的是需要分割序列的区间。 总之我们的目的是达到对于每个序列都是先分割当前序列，再分割两个子序列。 使用栈模拟： 类比二叉树前序遍历 将左右区间值压入栈，循环执行： 取栈顶的区间值，然后分割此区间； 如果子区间的序列无序则分别将两个子区间的值压入栈； 12345678910111213141516//栈的定义typedef int DataType;typedef struct Stack{ DataType* a; int top; int capacity;}Stack;void StackInit(Stack* ps);void StackPush(Stack* ps, DataType x);void StackPop(Stack* ps);DataType StackTop(Stack* ps);void StackDestory(Stack* ps);bool StackEmpty(Stack* ps);void StackPrint(Stack* ps); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp;}//以双指针分割法为例int PartSort(int* arr, int left, int right){ int keyi = left + rand() % (right - left + 1); swap(arr + left, arr + keyi); int key = arr[left]; int prev = left; int cur = prev + 1; while (cur &lt;= right) { if (arr[cur] &lt; key &amp;&amp; arr[++prev] != arr[cur]) swap(arr + prev, arr + cur); cur++; } swap(arr + left, arr + prev); return prev;}//快排非递归void QuickSort(int* arr, int left, int right){ if (left &gt;= right) return; //PartSort(arr, left, right); Stack s; StackInit(&amp;s); StackPush(&amp;s, left); StackPush(&amp;s, right); while (!StackEmpty(&amp;s)) { int end = StackTop(&amp;s); StackPop(&amp;s); int begin = StackTop(&amp;s); StackPop(&amp;s); int keyi = PartSort(arr, begin, end); if (begin &lt; pos - 1) { StackPush(&amp;s, begin); StackPush(&amp;s, keyi - 1); } if (pos + 1 &lt; end) { StackPush(&amp;s, keyi + 1); StackPush(&amp;s, end); } } StackDestory(&amp;s);} 使用队列模拟： 类比二叉树层序遍历 将左右区间值入队，循环执行： 取队列前端的区间值，然后分割此区间； 如果子区间的序列无序则分别将两个子区间的值入队； 12345678910111213141516171819202122typedef int DataType;typedef struct QNode{ DataType val; struct QNode* next;}QNode;typedef struct Queue{ QNode* phead; QNode* tail;}Queue;//链表结构void QueueInit(Queue* pq);void QueuePush(Queue* pq, DataType val);void QueuePop(Queue* pq);size_t QueueSize(Queue* pq);bool QueueEmpty(Queue* pq);void QueueDestory(Queue* pq);DataType QueueFront(Queue* pq);DataType QueueBack(Queue* pq); 12345678910111213141516171819202122232425262728void QuickSort(int* arr, int left, int right){ if (left &gt;= right) return; Queue q; QueueInit(&amp;q); QueuePush(&amp;q, left); QueuePush(&amp;q, right); while (!QueueEmpty(&amp;q)) { int begin = QueueFront(&amp;q); QueuePop(&amp;q); int end = QueueFront(&amp;q); QueuePop(&amp;q); int keyi = PartSort(arr, begin, end); if (begin &lt; keyi - 1) { QueuePush(&amp;q, begin); QueuePush(&amp;q, keyi); } if (keyi + 1 &lt; end) { QueuePush(&amp;q, keyi + 1); QueuePush(&amp;q, end); } } QueueDestory(&amp;q);}","link":"/2023/01/13/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"比较排序","text":"算法简介：排序排序是一个非常经典的问题，它以特定顺序（递增、非递减（递增或扁平））对数组（或列表）的项目（可以比较，例如整数、浮点数、字符串等）进行重新排序)、递减、非递增（递减或平坦）、字典式等）。 有许多不同的排序算法，每一种都有自己的优点和局限性。 排序通常用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。 以下所以排序都以升序为例. 冒泡排序冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法： 冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换它们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 助记码 参考：冒泡排序 - 维基百科，自由的百科全书 123i∈[0,N-1) //循环N-1遍 j∈[0,N-1-i) //每遍循环要处理的无序部分 swap(j,j+1) //两两排序（升序/降序） 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 冒泡排序图示： 每一轮冒泡，会将无序序列中最大的数“浮”到无序序列的最后一个位置，此位置成为”有序”，并且为有序序列中的最小值，有序序列的个数增加1，无序序列的个数减1，当只有一个位置是无序时，整个数组有序。 代码实现： 1234567891011121314151617181920212223242526void swap(int* s1, int* s2){ int tmp = *s1; *s1 = *s2; *s2 = tmp;}void BubbleSort(int* arr, int sz){ int i = 0; for (i = 0; i &lt; sz - 1; i++) { int flag = 0;//flag来标记是否还需要继续排序 int j = 0; for (j = 0; j &lt; sz - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { flag = 1;//标记仍需排序 swap(arr + j + 1, arr + j); } } if (flag == 0)//如果if一次都没进去，说明数组已经有序，直接退出 break; }} 算法分析： 最坏时间复杂度 ​ 最坏时间复杂度是序列为降序，设无序序列有 x 个，则每轮冒泡都需要交换 x - 1次，结果即为等差数列求和 ​ $\\sum\\limits_{x=1}^{n - 1}$x = n(n - 1) / 2，即O(n2) 最优时间复杂度 ​ 序列本就为有序序列，遍历一次即跳出，即O(n) 平均时间复杂度 ​ O(n2) 空间复杂度 ​ O(1) 总结： 冒泡排序对n个项目需要O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。 插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到**O(1)**的额外空间的排序)，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 Insertion Sort 和打扑克牌时非常相似，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。 举例： 摸牌顺序: {5 2 4 6 1 3}。 首先拿起第一张牌, 手上有 {5}。 拿起第二张牌 2, 把 2 insert 到手上的牌 {5}, 得到 {2 5}。 拿起第三张牌 4, 把 4 insert 到手上的牌 {2 5}, 得到 {2 4 5}。 以此类推。 算法： 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 插入排序图示： 代码实现： 1234567891011121314151617void InsertSort(int* arr, int sz){ int i = 0; for (i = 1; i &lt; sz; i++) { int j = 0; int tmp = arr[i]; for (j = i - 1; j &gt;= 0; j--) { if (arr[j] &lt; tmp)//遇到了比目标小的数，不在向前遍历，break break; arr[j + 1] = arr[j]; } arr[j + 1] = tmp;//插入到最后一个比较数据的后面 }} 算法分析： 最坏时间复杂度 ​ 序列为降序时，每插入下标为 i 的值，需要移动i - 1个数据，因此也是等差数列求和，即O(n2) 最优时间复杂度 ​ 序列为升序时，每次插入都不需要移动元素，即O(n) 平均时间复杂度 ​ O(n2) 空间复杂度 ​ O(1) 直接插入排序的特性总结： 元素集合越接近有序，直接插入排序算法的时间效率越高 时间复杂度：O(N^2) 空间复杂度：O(1)，它是一种稳定的排序算法 稳定性：稳定 插入排序对几乎有序的序列排序的效率很高，接近于O(n). 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 Shell排序希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 如图几乎有序序列有着先行排序的效率 因此我们可以先对要排序的数组进行预排序，让他变成几乎有序的状态。 以升序为例，我们的目的是： 让大的数更快的到后面 让小的数更快的到前面 普通的插入排序是从前到后依次插入，跨度为1，那么为了更快我们可以增加跨度。（跨度越大意味着每次插入数据只需要移动较少的次数，便可以大致到它排序后的位置） 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行常数次比较和交换即可到正确位置。 原始数组： 长度length = 10 初始步长 gap = length / 2 = 5 ​ 即两个一组，被分为了五组： ​ 这和大家军训时教官让大家挨着重复报数 0 或者 1 一样，喊到1的为一组，喊到0的为一组； ​ （同一条线上的为一组） ​ 只不过这里是从0报数到4，那么报数相同的分为一组，有不同的5个数，那就是5组咯。 ​ 即步长为多少，就分为多少组。 对上面5组数据分别进行插入排序，例如第一组【8，3】，经过插入排序就变成了【3，8】(升序)。 ​ 那么每一组经过排序后就成为了有序序列。 ​ 结果如下图： ​ ​ 可以看到，每一组中较小的数都移动到了前半部分，而较大的数则移动到了后半部分。 继续缩小步长 gap = length / 2 / 2 = 2 ​ 即被分为了两组，【3】【5】分别是这两组数组的头部。 ​ 再对以上两组分别进行插入排序 ​ 例如第一组：【3，1，0，9，7】，经过插入排序后变成【0，1，3，7，9】。 ​ 两组数据分别排序后结果如图： ​ ​ 此时整个数组已经近乎有序，大的数集中在数组尾部，小的数集中在数组头部。 ​ 因此，就可以对整个数组进行直接插入排序即可完成升序排序。 ​ 继续缩小步长，使gap = 1即可，即整个数组为一组，进行直接插入排序，因为数组已经几乎有序，只需要进行 少量调整即可完成排序。 ​ 希尔排序示意图： 代码实现： 12345678910111213141516171819void ShellSort(int* arr, int sz){ for (int gap = sz / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; sz; i++)//每一次的预排序时间复杂度大致是O(n) { int tmp = arr[i]; int j = 0; for (j = i - gap; j &gt;= 0; j -= gap) { if (arr[j] &gt; tmp) arr[j + gap] = arr[j]; else break; } arr[j + gap] = tmp; } }} 官方建议是步长选择gap = n / 3 + 1，这里用的n / 2。 算法分析： 平均时间复杂度 ​ 根据步长序列的不同而不同。 最坏时间复杂度 ​ 根据步长序列的不同而不同，已知最好的：O(n log^2^(n)) 最优时间复杂度 ​ O(n) 空间复杂度 ​ O(1) 希尔排序的特性总结： 希尔排序是对直接插入排序的优化。 当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些树中给出的希尔排序的时间复杂度都不固定： 稳定性：不稳定 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。 选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多(n - 1)次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 算法实现： 1234567891011121314151617181920212223242526272829303132333435363738394041void SelectionSort(int* arr, int sz){ int left = 0; int right = sz - 1; while (left &lt; right) { int minid = left; for (int i = left; i &lt;= right; i++) { //每次挑出最小的值的索引 if (arr[i] &lt; arr[minid]) minid = i; } swap(arr + left, arr + minid); left++; }}//优化void SelectionSort(int* arr, int sz){ int left = 0; int right = sz - 1; while (left &lt; right) { int i = 0; int minid = left; int maxid = left; for (i = left + 1; i &lt;= right; i++) { //每次挑出最小的和最大的 if (arr[i] &gt; arr[maxid]) maxid = i; if (arr[i] &lt; arr[minid]) minid = i; } if (left == maxid)//如果minid和left的交换会影响maxid的下标，则需要修正maxid maxid = minid; swap(arr + minid, arr + left); swap(arr + maxid, arr + right); left++; right--; }} 算法分析： 最坏时间复杂度 ​ 序列为降序时，找到最小值需要无序序列的元素个数，寻找 n - 1次即可，总次数为等差数列求和，即O(n2) 最优时间复杂度 ​ 序列为升序时，和最坏情况相同，即O(n2)，虽然如此，但没有交换操作。 平均时间复杂度 ​ O(n2) 空间复杂度 ​ O(1) 直接选择排序的特性总结： 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定性：不稳定 原地操作和少量的数据交换几乎是选择排序的唯二优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 如果数组完全有序，冒泡内循环的交换一次都不会执行，而选择排序每次还要遍历并且和本身交换一次，此时冒泡效率高。但这种情况极少，所以丼从算法的角度看，选择优于冒泡。 总体效率体来说 ，希尔排序 &gt; 插入排序 &gt; 选择排序 &gt; 冒泡排序","link":"/2023/01/13/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F/"},{"title":"jsDelivr域名遭到DNS污染","text":"转载自：【杂谈】jsDelivr域名遭到DNS污染 – Luminous’ Home jsDelivr域名遭到DNS污染在jsDelivr被吊销ICP许可证四个月后的4月28日，cdn.jsdelivr.net开始遭到污染，这一个赫赫有名的静态资源库面向中国大陆的服务最终倒在了政策和监管双重压力之下。 写在前面虽然从四个月前那次宕机失去中国大陆CDN开始，很大一部分网站已经陆陆续续将静态资源切出jsDelivr，但是碍于jsDelivr多年的深耕以及服务的独特性，仍有不少场景下引用有jsDelivr的链接。不同于以往的短时间宕机，这次的“污染”几近于死刑，意味着cdn.jsdelivr.net在中国大陆服务的彻底终结，从此这个网站将不再是慢，而是不可及。 jsDelivr的命运2022年4月28日，jsDelivr得到了与Facebook、Twitter等如出一辙的安排，主要的服务域名遭到DNS污染。在正常状态下，当你请求网站域名域名时，你的DNS服务器会逐级向上寻找这个域名的解析记录，并通过这个链条将它指向的服务器返回给你，实现域名与服务器的融合。若你的DNS逐级向上请求记录的过程中，出现了一个中间人提前抢答了错误的记录，而非来自域名权威服务器的正确回复，导致返回的结果并不是指向正确服务器的，连接因此不能建立，这便是DNS污染。其中的原因，还是要从一开始说起。 惊艳四座的jsDelivr不知道提到jsDelivr，大家都是从哪一项服务开始接触到它的？由中国最大的传统CDN提供商网宿（QUANTIL）赞助，支持cdnjs和GitHub内容直接加速引用，它的应用可以说是迄今为止所有静态库中最为广泛的了。大到各种门户网站，小到个人博客，乃至去广告规则订阅、图床、插件静态库等等种种衍生场景，都能见到它的身影。 在网宿的协助下，2016年12月jsDelivr挂名在上海幻文信息科技有限公司下完成了企业ICP备案，取得了备案号【沪ICP备15005128号-2】。这是一家网宿用于代理备案的公司，通过天眼查等工具很容易看出来，历史上共有8个网站在这个公司挂名进行备案，目前除了所谓的主页已全部注销。 这是历史上第一个以较为正规的方式进入中国大陆的海外静态资源库项目，在网宿与诸多海外赞助商协同下，5年中jsDelivr提供了非常稳定且出色的服务。jsDelivr官方毫不掩饰对自己能够在中国大陆合法提供服务的喜悦，专门在节点页面中写下了“我们拥有中国政府的ICP许可证，拥有数百个服务节点的巨大中国网络”的字眼。 然而千里之堤溃于蚁穴，纵使拥有网宿这样强有力的支撑，也难抵运营以来遇到的重重阻碍。 一波三折的大陆服务在网宿负责中国大陆的CDN节点这几年中，因为网宿方面的问题导致了几次SSL证书过期而宕机，博主有印象的在2019、2020年都有出现过。如果说那些都是网宿单方面的失误的话，2019年10月的暂时退出是jsDelivr官方面临的第一次危机。2018年工信部对域名备案政策颁布了新的规定，只有注册局在中国大陆拥有代理公司并完成申报、且域名停放在在中国大陆注册商的情况下才可以进行备案。jsDelivr挂名的公司在2019年需要进行了负责人信息的变更，备案主体信息需要进行修改，这在多个域名中都可以查到记录。 当时，jsDelivr暂时关闭了中国大陆的节点，转而使用网宿位于中国台湾和韩国首尔的节点提供服务，加载速度一落千丈。当时博主还向官方发送了一封邮件进行了咨询，官方也亲切地回应是在更新ICP备案，将在不久之后恢复。较早的issue中，官方人员进行了更详细的解释，他们在更新ICP备案的过程中遇到新规的要求将备案域名转入至中国大陆的服务商的问题，在评估后他们认为没有一种安全的方式能够确保在服务不中断的前提下将域名转移至中国大陆，因此暂时关闭中国大陆的节点等待进一步的探讨。最终在一个月后，jsDelivr恢复了位于中国大陆的节点，这次风波算是告一段落。 接下来的三年中大体相安无事，除了几乎每年一度的网宿忘记更新SSL证书。但是由于支持对GitHub项目的完整加速，对jsDelivr的滥用日趋严重，GitHub+jsDelivr图床、视频床甚至网盘层出不穷。如果说以上只是对免费资源的滥用，在GitHub中储存成人、邪教等文件通过jsDelivr向中国大陆分发，则是将jsDelivr一步步推向万丈深渊。 在2020年的8月15日，jsDelivr在官方GitHub项目中首次更新了使用限制说明（点击前往），我截取了其中较为重要的一部分，这是官方第一次明确表示禁止多种滥用行为并添加了对中国大陆政策的额外说明。在这之后，官方在网宿方向屏蔽了一系列不符合中国大陆法律内容的项目。但是由于是针对整个GitHub项目的通用加速，官方的封禁显然远远比不过肆意滥用的脚步。 命中注定的结局jsDelivr对中国大陆的态度一直颇为暧昧，在2019年风波平息后，有不少人提议针对中国大陆的服务中GitHub加速项目应当审核开放或关闭此项以防止滥用，但官方认为将项目推送cdnjs也是很容易的事，单单禁用GitHub并不能解决不合理利用的问题，于是便没有了后文。 于是在2021年12月20日，当项目组成员在另一个半球睡得正香的时候，自上而下的命令压力下网宿直接关闭了jsDelivr的大陆CDN，几个小时后jsDelivr的ICP备案也被注销。当jsDelivr项目工作人员起来时，一脸茫然地发现网宿在未告知原因的情况下关闭了中国大陆的CDN，在愤怒之余将DNS记录切换至了Fastly恢复了jsDelivr的访问，这次的风波暂时告一段落。 但是网宿这次为何突然关闭CDN的原因依然众说纷纭，有内部人士称是因为网安部门发现了通过jsDelivr的链接传播邪教内容，但这些无从考证，官方自始至终也未对此给出任何解释。但无法改变的是，jsDelivr失去了ICP许可证，不再拥有位于中国大陆的CDN节点，加载速度大幅下降，官方也不再通过区域服务商对内容进行过滤。 在这之前有一个同样支持GitHub加速的静态资源库statically.io已被SNI阻断，与曾经的jsDelivr唯一的不同便是没有ICP许可证的保护。它走过的路，冥冥中暗示着jsDelivr注定的结局。 2022年4月28日，jsDelivr在中国大陆确认遭到DNS污染，乐章到此戛然而止。 代替方案我本身也是jsDelivr的使用者，个站的图片资源已经无法加载，目前正在想办法找替代方案，也许从此后再没有免费稳定的产品了。目前考虑腾讯的付费COS吧。 结语于是，到底是谁杀死了jsDelivr呢？是jsDelivr审核不够严谨？是网宿的不辞而别？是政策的“一刀切”？博主不知道，相信各位看官自己心里都有自己的答案吧。 本来只是想简单讲几句，没想到就说了这么多，一篇文章难免会参杂有个人情感，文中如果有不够严谨的地方请多指点。 最后，晚安jsDelivr，感谢您和诸多的赞助商这么多年来为用户无偿提供这样便捷的服务~","link":"/2023/01/13/%E6%9D%82%E8%B0%88%E7%A2%8E%E7%A2%8E%E5%BF%B5/jsDelivr%E5%9F%9F%E5%90%8D%E9%81%AD%E5%88%B0DNS%E6%B1%A1%E6%9F%93/"},{"title":"机场如何选择","text":"转载自 EdNovas https://ednovas.xyz/2020/12/31/%E6%9C%BA%E5%9C%BA/ 电丸科技 AK在购买机场之前推荐先看看这个视频 如果有时间也可以看看他的【硬核翻墙 / 科学上网】系列视频 中别的视频，也都收益匪浅。 机场测速至于大机场推荐的话，https://www.duyaoss.com/ 这个网站有适合电信、联通、移动的几十家机场测速，也包括机场网址。 谷歌上也一般可以直接搜索到各大机场。TG 频道和群组，YouTube 也可找到很多。 机场套餐购买原则 免费域名（freenom 五大免费域名：tk ml ga cf gq）注册的机场不考虑，机场主连节点都能下本儿买，他还能差俩钱买个域名？ 购买前建议试用，无论是白嫖试用还是购买试用套餐，每个人的网络情况不一样，建议要试用稳妥。不要买太贵，除非你贼有钱；不要买太便宜，你想想节点成本很低？ 机场面板感观不好的不考虑，机场面板是机场门面，如果面板一堆报错没及时修复你能相信他有技术优化维持好节点？ 选择在晚上上网高峰期测速或者体验，一家机场的技术实力在这个时间段表现如何最明显。 最好月付，不要季付年付，rixcloud 布丁都能跑路，剩下的机场不用多说。机场是一定会跑路和倒闭，只是时间问题，机场做大被盯上请去喝茶机场倒闭。机场太小入不敷出直接跑路。 最好选择机场成立三个月以上或半年以上的机场，怎么鉴别时间？可以加机场 telegram 群搜索他第一条信息什么时候发的。 最好选择机场管理员在境外的，毕竟境内的容易被喝茶大家都懂😏 如果经常要逛特定网站或者下载要提前了解机场的审计规则封号规则。 查共享厉害的机场特别是还精确到设备的建议别买，容易纷争多，特别是对出差党不友好。 机场管理团队人品不好还跟用户骂人把自己当大爷把用户当孙子的，别买他家机场套餐，不然像 rixcloud 一样花钱买气受。 真要购买机场套餐，要看看最近机场有没有什么优惠码活动。能省点钱何乐不为呢？ 别人告诉你 xxx 机场好，测速图好，看看就行，每个人的网络环境运营商带宽设备位置线路不一样，肯定要自己用过才能感知，一味地推 xxx 机场好肯定是受利益驱使。 注意机场节点的倍率，限速，区域，流媒体解锁，游戏延迟加速，专线类型，运营商线路优化等等是否符合你自身需求。 对速度和延迟有要求的注意看一下是否有中转机、iplc 等线路，直连线路速度延迟有时没那么理想。 不太建议选择在 QQ 微信建立用户群的机场，尽量还是选择 TG 群，虽然这有种机场加大跑路的风险，但墙内平台还是要少沾染翻墙内容。 可以去品云等综合机场品析 TG 群了解一下你想购买机场的情况，有时聊着聊着说不定避免一些坑。 机场最真实的购买原则：天时地利人和运气好 总结要记住： 适合自己的机场才是最好的。 不要听信别人的推荐，特别是 YouTube 博主和熟人的推荐还带一个 aff 邀请码后缀的。 机场跑路是随时都有可能发生的事，不管是大机场还是小机场（大机场翻车几率更小点罢了）。 理智购买和消费，买 1 家主力机场，1 家备用机场一般就足够。 外网并非法外之地，注意言论和行为。","link":"/2023/01/13/%E6%9D%82%E8%B0%88%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%9C%BA%E5%9C%BA%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"}],"tags":[{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"类和对象","slug":"类和对象","link":"/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"小游戏","slug":"小游戏","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"数据存储","slug":"数据存储","link":"/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"数据类型","slug":"数据类型","link":"/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"文件操作","slug":"文件操作","link":"/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"字符","slug":"字符","link":"/tags/%E5%AD%97%E7%AC%A6/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"操作符","slug":"操作符","link":"/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"gcc","slug":"gcc","link":"/tags/gcc/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客美化","slug":"博客美化","link":"/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"yum源","slug":"yum源","link":"/tags/yum%E6%BA%90/"},{"name":"镜像源","slug":"镜像源","link":"/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"固定链接","slug":"固定链接","link":"/tags/%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"typecho","slug":"typecho","link":"/tags/typecho/"},{"name":"clash","slug":"clash","link":"/tags/clash/"},{"name":"matblab","slug":"matblab","link":"/tags/matblab/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"乱码","slug":"乱码","link":"/tags/%E4%B9%B1%E7%A0%81/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"office","slug":"office","link":"/tags/office/"},{"name":"gif","slug":"gif","link":"/tags/gif/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"netflix","slug":"netflix","link":"/tags/netflix/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"jsDelivr","slug":"jsDelivr","link":"/tags/jsDelivr/"},{"name":"机场","slug":"机场","link":"/tags/%E6%9C%BA%E5%9C%BA/"}],"categories":[{"name":"Cpp","slug":"Cpp","link":"/categories/Cpp/"},{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"WordPress","slug":"WordPress","link":"/categories/WordPress/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂谈碎碎念","slug":"杂谈碎碎念","link":"/categories/%E6%9D%82%E8%B0%88%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"404","text":"糟糕！出了些偏差！ 您似乎来到了没有知识存在的荒原… 要不，试试搜索？","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { createFilter } from \"@rollup/pluginutils\"; function string(opts = {}) { if (!opts.include) { throw Error(\"include option should be specified\"); } const filter = createFilter(opts.include, opts.exclude); return { name: \"string\", transform(code, id) { if (filter(id)) { return { code: `export default ${JSON.stringify(code)};`, map: { mappings: \"\" } }; } }, renderChunk(code, chunk, outputOptions = {}) { return `/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ ` + code; } }; } export default { input: \"src/waifu-tips.js\", plugins: [nodeResolve(), string({ include: \"**/*.svg\", })] };","link":"/live2d-widget/rollup.config.js"},{"title":"","text":"Live2D Widget 特性 Feature在网页中添加 Live2D 看板娘。兼容 PJAX，支持无刷新加载。Add Live2D widget to web page. Compatible with PJAX. （注：以上人物模型仅供展示之用，本仓库并不包含任何模型。） 你也可以查看示例网页： 在 米米的博客 的左下角可查看效果 demo.html，展现基础功能 login.html，仿 NPM 的登陆界面 使用 Usage如果你是小白，或者只需要最基础的功能，那么只用将这一行代码加入 html 页面的 head 或 body 中，即可加载看板娘： 1&lt;script src=&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 添加代码的位置取决于你的网站的构建方式。例如，如果你使用的是 Hexo，那么需要在主题的模版文件中添加以上代码。对于用各种模版引擎生成的页面，修改方法类似。如果网站启用了 PJAX，由于看板娘不必每页刷新，需要注意将该脚本放到 PJAX 刷新区域之外。 但是！我们强烈推荐自己进行配置，让看板娘更加适合你的网站！如果你有兴趣自己折腾的话，请看下面的详细说明。 配置 Configuration你可以对照 autoload.js 的源码查看可选的配置项目。autoload.js 会自动加载三个文件：waifu.css，live2d.min.js 和 waifu-tips.js。waifu-tips.js 会创建 initWidget 函数，这就是加载看板娘的主函数。initWidget 函数接收一个 Object 类型的参数，作为看板娘的配置。以下是配置选项： 选项 类型 默认值 说明 waifuPath string https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/waifu-tips.json 看板娘资源路径，可自行修改 apiPath string https://live2d.fghrsh.net/api/ API 路径，可选参数 cdnPath string https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/ CDN 路径，可选参数 tools string[] 见 autoload.js 加载的小工具按钮，可选参数 其中，apiPath 和 cdnPath 两个参数设置其中一项即可。apiPath 是后端 API 的 URL，可以自行搭建，并增加模型（需要修改的内容比较多，此处不再赘述），可以参考 live2d_api。而 cdnPath 则是通过 jsDelivr 这样的 CDN 服务加载资源，更加稳定。 自定义 Customization如果以上「配置」部分提供的选项还不足以满足你的需求，那么你可以自己进行修改。本仓库的目录结构如下： src/waifu-tips.js 包含了按钮和对话框的逻辑； waifu-tips.js 是由 src/waifu-tips.js 自动打包生成的，不建议直接修改； waifu-tips.json 中定义了触发条件（selector，CSS 选择器）和触发时显示的文字（text）； waifu.css 是看板娘的样式表。 waifu-tips.json 中默认的 CSS 选择器规则是对 Hexo 的 NexT 主题 有效的，为了适用于你自己的网页，可能需要自行修改，或增加新内容。警告：waifu-tips.json 中的内容可能不适合所有年龄段，或不宜在工作期间访问。在使用时，请自行确保它们是合适的。 要在本地部署本项目的开发测试环境，你需要安装 Node.js 和 npm，然后执行以下命令： 123git clone https://github.com/stevenjoezhang/live2d-widget.gitnpm installnpm run build 如果有任何疑问，欢迎提 Issue。如果有任何修改建议，欢迎提 Pull Request。 部署 Deploy在本地完成了修改后，你可以将修改后的项目部署在服务器上，或者通过 CDN 加载，以便在网页中使用。 Using CDN要自定义有关内容，可以把这个仓库 Fork 一份，然后把修改后的内容通过 git push 到你的仓库中。这时，使用方法对应地变为 1&lt;script src=&quot;https://fastly.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 将此处的 username 替换为你的 GitHub 用户名。为了使 CDN 的内容正常刷新，需要创建新的 git tag 并推送至 GitHub 仓库中，否则此处的 @latest 仍然指向更新前的文件。此外 CDN 本身存在缓存，因此改动可能需要一定的时间生效。相关文档： Git Basics - Tagging Managing releases in a repository Self-host你也可以直接把这些文件放到服务器上，而不是通过 CDN 加载。 如果你能够通过 ssh 连接你的主机，请把 Fork 并修改后的代码仓库克隆到服务器上。 如果你的主机无法用 ssh 连接（例如一般的虚拟主机），请在本地修改好代码后，通过 ftp 等方式将文件上传到主机的网站的目录下。 如果你是通过 Hexo 等工具部署的静态博客，请把本项目的代码放在博客源文件目录下（例如 source 目录）。重新部署博客时，相关文件就会自动上传到对应的路径下。为了避免这些文件被 Hexo 插件错误地修改，可能需要设置 skip_render。 这样，整个项目就可以通过你的域名访问了。不妨试试能否正常地通过浏览器打开 autoload.js 和 live2d.min.js 等文件，并确认这些文件的内容是完整和正确的。一切正常的话，接下来修改 autoload.js 中的常量 live2d_path 为 live2d-widget 这一目录的 URL 即可。比如说，如果你能够通过 1https://example.com/path/to/live2d-widget/live2d.min.js 访问到 live2d.min.js，那么就把 live2d_path 的值修改为 1https://example.com/path/to/live2d-widget/ 路径末尾的 / 一定要加上。完成后，在你要添加看板娘的界面加入 1&lt;script src=&quot;https://example.com/path/to/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 就可以加载了。 鸣谢 Thanks 感谢 BrowserStack 容许我们在真实的浏览器中测试此项目。Thanks to BrowserStack for providing the infrastructure that allows us to test in real browsers! 感谢 jsDelivr 提供的 CDN 服务。Thanks jsDelivr for providing public CDN service. 代码自这篇博文魔改而来：https://www.fghrsh.net/post/123.html 感谢 一言 提供的语句接口。 点击看板娘的纸飞机按钮时，会出现一个彩蛋，这来自于 WebsiteAsteroids。 更多 More更多内容可以参考：https://nocilol.me/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02https://github.com/xiazeyu/live2d-widget.jshttps://github.com/summerscar/live2dDemo 关于后端 API 模型：https://github.com/xiazeyu/live2d-widget-modelshttps://github.com/xiaoski/live2d_models_collection 除此之外，还有桌面版本：https://github.com/amorist/platelethttps://github.com/akiroz/Live2D-Widgethttps://github.com/zenghongtu/PPethttps://github.com/LikeNeko/L2dPetForMac 以及 Wallpaper Engine：https://github.com/guansss/nep-live2d 许可证 LicenseReleased under the GNU General Public License v3http://www.gnu.org/licenses/gpl-3.0.html 本仓库并不包含任何模型，用作展示的所有 Live2D 模型、图片、动作数据等版权均属于其原作者，仅供研究学习，不得用于商业用途。 Live2D 官方网站：https://www.live2d.com/en/https://live2d.github.io Live2D Cubism Core は Live2D Proprietary Software License で提供しています。https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.htmlLive2D Cubism Components は Live2D Open Software License で提供しています。http://www.live2d.com/eula/live2d-open-software-license-agreement_en.html The terms and conditions do prohibit modification, but obfuscating in live2d.min.js would not be considered illegal modification. https://community.live2d.com/discussion/140/webgl-developer-licence-and-javascript-question 更新 Update2018年10月31日，由 fghrsh 提供的原 API 停用，请更新至新地址。参考文章：https://www.fghrsh.net/post/170.html 2020年1月1日起，本项目不再依赖于 jQuery。 2022年11月1日起，本项目不再需要用户单独加载 Font Awesome。","link":"/live2d-widget/README.html"},{"title":"","text":"// live2d_path 参数建议使用绝对路径 //const live2d_path = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\"; const live2d_path = \"/live2d-widget/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { // 配置选项的具体用法见 README.md initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", //apiPath: \"https://live2d.fghrsh.net/api/\", //cdnPath: \"https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\", cdnPath: \"https://npm.elemecdn.com/akilar-live2dapi@latest/\", tools: [\"hitokoto\", \"asteroids\", \"switch-model\", \"switch-texture\", \"photo\", \"info\", \"quit\"] }); }); } console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);","link":"/live2d-widget/autoload.js"},{"title":"","text":"{\"name\":\"live2d-widget\",\"version\":\"0.9.0\",\"description\":\"Live2D widget for web pages\",\"main\":\"autoload.js\",\"type\":\"module\",\"scripts\":{\"build\":\"rollup -c rollup.config.js -f iife | terser -c -m > waifu-tips.js\",\"build-dev\":\"rollup -c rollup.config.js -f iife -o waifu-tips.js -w\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/stevenjoezhang/live2d-widget.git\"},\"keywords\":[\"Live2d\"],\"author\":\"stevenjoezhang \",\"license\":\"GPL-3.0-or-later\",\"bugs\":{\"url\":\"https://github.com/stevenjoezhang/live2d-widget/issues\"},\"homepage\":\"https://github.com/stevenjoezhang/live2d-widget#readme\",\"devDependencies\":{\"@fortawesome/fontawesome-free\":\"^6.2.0\",\"@rollup/plugin-node-resolve\":\"^15.0.0\",\"@rollup/pluginutils\":\"^5.0.1\",\"rollup\":\"^3.2.3\",\"terser\":\"^5.15.1\"}}","link":"/live2d-widget/package.json"},{"title":"","text":"/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ !function(){\"use strict\";function e(e){return Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e}let t;function o(o,s,n){if(!o||sessionStorage.getItem(\"waifu-text\")&&sessionStorage.getItem(\"waifu-text\")>n)return;t&&(clearTimeout(t),t=null),o=e(o),sessionStorage.setItem(\"waifu-text\",n);const i=document.getElementById(\"waifu-tips\");i.innerHTML=o,i.classList.add(\"waifu-tips-active\"),t=setTimeout((()=>{sessionStorage.removeItem(\"waifu-text\"),i.classList.remove(\"waifu-tips-active\")}),s)}class s{constructor(e){let{apiPath:t,cdnPath:o}=e,s=!1;if(\"string\"==typeof o)s=!0,o.endsWith(\"/\")||(o+=\"/\");else{if(\"string\"!=typeof t)throw\"Invalid initWidget argument!\";t.endsWith(\"/\")||(t+=\"/\")}this.useCDN=s,this.apiPath=t,this.cdnPath=o}async loadModelList(){const e=await fetch(`${this.cdnPath}model_list.json`);this.modelList=await e.json()}async loadModel(t,s,n){if(localStorage.setItem(\"modelId\",t),localStorage.setItem(\"modelTexturesId\",s),o(n,4e3,10),this.useCDN){this.modelList||await this.loadModelList();const o=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${o}/index.json`)}else loadlive2d(\"live2d\",`${this.apiPath}get/?id=${t}-${s}`),console.log(`Live2D 模型 ${t}-${s} 加载完成`)}async loadRandModel(){const t=localStorage.getItem(\"modelId\"),s=localStorage.getItem(\"modelTexturesId\");if(this.useCDN){this.modelList||await this.loadModelList();const s=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${s}/index.json`),o(\"我的新衣服好看嘛？\",4e3,10)}else fetch(`${this.apiPath}rand_textures/?id=${t}-${s}`).then((e=>e.json())).then((e=>{1!==e.textures.id||1!==s&&0!==s?this.loadModel(t,e.textures.id,\"我的新衣服好看嘛？\"):o(\"我还没有其他衣服呢！\",4e3,10)}))}async loadOtherModel(){let e=localStorage.getItem(\"modelId\");if(this.useCDN){this.modelList||await this.loadModelList();const t=++e>=this.modelList.models.length?0:e;this.loadModel(t,0,this.modelList.messages[t])}else fetch(`${this.apiPath}switch/?id=${e}`).then((e=>e.json())).then((e=>{this.loadModel(e.model.id,0,e.model.message)}))}}const n={hitokoto:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:function(){fetch(\"https://v1.hitokoto.cn\").then((e=>e.json())).then((e=>{const t=`这句一言来自 「${e.from}」，是 ${e.creator} 在 hitokoto.cn 投稿的。`;o(e.hitokoto,6e3,9),setTimeout((()=>{o(t,4e3,9)}),6e3)}))}},asteroids:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{if(window.Asteroids)window.ASTEROIDSPLAYERS||(window.ASTEROIDSPLAYERS=[]),window.ASTEROIDSPLAYERS.push(new Asteroids);else{const e=document.createElement(\"script\");e.src=\"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\",document.head.appendChild(e)}}},\"switch-model\":{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{}},\"switch-texture\":{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{}},photo:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{o(\"照好了嘛，是不是很可爱呢？\",6e3,9),Live2D.captureName=\"photo.png\",Live2D.captureFrame=!0}},info:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{open(\"https://github.com/stevenjoezhang/live2d-widget\")}},quit:{icon:'\\x3c!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --\\x3e',callback:()=>{localStorage.setItem(\"waifu-display\",Date.now()),o(\"愿你有一天能与重要的人重逢。\",2e3,11),document.getElementById(\"waifu\").style.bottom=\"-500px\",setTimeout((()=>{document.getElementById(\"waifu\").style.display=\"none\",document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\")}),3e3)}}};function i(t){const i=new s(t);function c(t){let s,n=!1,i=t.message.default;window.addEventListener(\"mousemove\",(()=>n=!0)),window.addEventListener(\"keydown\",(()=>n=!0)),setInterval((()=>{n?(n=!1,clearInterval(s),s=null):s||(s=setInterval((()=>{o(i,6e3,9)}),2e4))}),1e3),o(function(e){if(\"/\"===location.pathname)for(let{hour:t,text:o}of e){const e=new Date,s=t.split(\"-\")[0],n=t.split(\"-\")[1]||s;if(s{for(let{selector:n,text:i}of t.click)if(s.target.matches(n))return i=e(i),i=i.replace(\"{text}\",s.target.innerText),void o(i,4e3,8)})),t.seasons.forEach((({date:t,text:o})=>{const s=new Date,n=t.split(\"-\")[0],c=t.split(\"-\")[1]||n;n.split(\"/\")[0]{document.hidden||o(t.message.visibilitychange,6e3,9)}))}localStorage.removeItem(\"waifu-display\"),sessionStorage.removeItem(\"waifu-text\"),document.body.insertAdjacentHTML(\"beforeend\",'\\n \\n \\n \\n '),setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0),function(){n[\"switch-model\"].callback=()=>i.loadOtherModel(),n[\"switch-texture\"].callback=()=>i.loadRandModel(),Array.isArray(t.tools)||(t.tools=Object.keys(n));for(let e of t.tools)if(n[e]){const{icon:t,callback:o}=n[e];document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\",`${t}`),document.getElementById(`waifu-tool-${e}`).addEventListener(\"click\",o)}}(),function(){let e=localStorage.getItem(\"modelId\"),o=localStorage.getItem(\"modelTexturesId\");null===e&&(e=1,o=53),i.loadModel(e,o),fetch(t.waifuPath).then((e=>e.json())).then(c)}()}window.initWidget=function(e,t){\"string\"==typeof e&&(e={waifuPath:e,apiPath:t}),document.body.insertAdjacentHTML(\"beforeend\",'\\n 看板娘\\n ');const o=document.getElementById(\"waifu-toggle\");o.addEventListener(\"click\",(()=>{o.classList.remove(\"waifu-toggle-active\"),o.getAttribute(\"first-time\")?(i(e),o.removeAttribute(\"first-time\")):(localStorage.removeItem(\"waifu-display\"),document.getElementById(\"waifu\").style.display=\"\",setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0))})),localStorage.getItem(\"waifu-display\")&&Date.now()-localStorage.getItem(\"waifu-display\"){o.classList.add(\"waifu-toggle-active\")}),0)):i(e)}}();","link":"/live2d-widget/waifu-tips.js"},{"title":"","text":"{\"mouseover\":[{\"selector\":\"#live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool-hitokoto\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool-asteroids\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool-switch-model\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool-switch-texture\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool-photo\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool-info\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool-quit\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home a\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about a\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags a\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\"]},{\"selector\":\".menu-item-categories a\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\"]},{\"selector\":\".menu-item-archives a\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\"]},{\"selector\":\".menu-item-friends a\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search a\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".menu-item a\",\"text\":[\"快看看这里都有什么呢？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\".followme\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".copy-btn\",\"text\":[\"代码可以直接点击复制哟。\"]},{\"selector\":\".highlight .table-container, .gist\",\"text\":[\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".beian a\",\"text\":[\"我也是有户口的人哦。\",\"我的主人可是遵纪守法的好主人。\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}],\"time\":[{\"hour\":\"6-7\",\"text\":\"早上好！一日之计在于晨，美好的一天就要开始了～\"},{\"hour\":\"8-11\",\"text\":\"上午好！工作顺利嘛，不要久坐，多起来走动走动哦！\"},{\"hour\":\"12-13\",\"text\":\"中午了，工作了一个上午，现在是午餐时间！\"},{\"hour\":\"14-17\",\"text\":\"午后很容易犯困呢，今天的运动目标完成了吗？\"},{\"hour\":\"18-19\",\"text\":\"傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～\"},{\"hour\":\"20-21\",\"text\":\"晚上好，今天过得怎么样？\"},{\"hour\":\"22-23\",\"text\":[\"已经这么晚了呀，早点休息吧，晚安～\",\"深夜时要爱护眼睛呀！\"]},{\"hour\":\"0-5\",\"text\":\"你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？\"}],\"message\":{\"default\":[\"好久不见，日子过得好快呢……\",\"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\",\"嗨～快来逗我玩吧！\",\"拿小拳拳锤你胸口！\",\"记得把小家加入收藏夹哦！\"],\"console\":\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\",\"copy\":\"你都复制了些什么呀，转载要记得加上出处哦！\",\"visibilitychange\":\"哇，你终于回来了～\"}}","link":"/live2d-widget/waifu-tips.json"},{"title":"","text":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 12px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; /*left: 0;*/ right: 15px; line-height: 0; margin-bottom: -10px; position: fixed; transform: translateY(3px); transition: transform .3s ease-in-out, bottom 3s ease-in-out; z-index: 1000; } #waifu:hover { transform: translateY(0); } #waifu-tips { animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #live2d { cursor: grab; height: 300px; position: relative; width: 300px; } #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; right: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { display: block; height: 30px; text-align: center; } #waifu-tool svg { fill: #7b8c9d; cursor: pointer; height: 25px; transition: fill .3s; } #waifu-tool svg:hover { fill: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }","link":"/live2d-widget/waifu.css"},{"title":"","text":"看板娘登陆平台 html, body { height: 100%; } body { display: flex; align-items: center; justify-content: center; padding-top: 40px; padding-bottom: 40px; background-color: #f5f5f5; } .form-signin { width: 100%; max-width: 330px; padding: 15px; margin: 0 auto; } .form-signin .checkbox { font-weight: 400; } .form-signin .form-control { position: relative; box-sizing: border-box; height: auto; padding: 10px; font-size: 16px; } .form-signin .form-control:focus { z-index: 2; } .form-signin input[type=text] { margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .form-signin input[type=password] { margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; } #stage { position: relative; } #stage img { width: 100%; margin-bottom: 20px; border-radius: 20px; } #stage button { position: absolute; padding: 0; } #inner { position: relative; background-color: #999; clip-path: circle(120px at center); } #cover { position: absolute; background-color: #CB3837; width: 100%; height: 100%; bottom: 10%; transition: all 1s; box-shadow: 0 0 0 5px rgba(0, 0, 0, .1); } #text { position: absolute; bottom: 30%; font-size: 2em; left: 50%; transform: translateX(-50%); opacity: 0.4; font-weight: bold; } #detail { position: absolute; background: rgba(255, 255, 255, .1); width: 100%; height: 10px; bottom: 0; } #handle { position: absolute; background: #ccc; bottom: -2px; box-shadow: 0 1px 0 1px rgba(0, 0, 0, .1); height: 8px; left: 50%; margin-left: -15px; width: 30px; cursor: pointer; } #info { left: 40px; bottom: 20px; } #refresh { right: 40px; bottom: 20px; } #live2d { cursor: grab; height: 300px; width: 300px; } #live2d:active { cursor: grabbing; } MIMIPOWERED 看板娘登陆平台 用户名 密码 记住我 登录 Copyleft &copy; Mimi 2019 /* * _(:з」∠)_ * Created by Shuqiao Zhang in 2019. * https://zhangshuqiao.org */ /* * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */ window.addEventListener(\"load\", () => { \"use strict\"; if (!CSS.supports(\"clip-path\", \"circle(120px at center)\")) { document.getElementById(\"stage\").innerHTML = ''; return; } const apiPath = \"https://live2d.fghrsh.net/api\"; let state = 0, loading = false, modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { modelId = 1; modelTexturesId = 53; } loadModel(modelId, modelTexturesId); function loadModel(modelId, modelTexturesId) { localStorage.setItem(\"modelId\", modelId); if (modelTexturesId === undefined) modelTexturesId = 0; localStorage.setItem(\"modelTexturesId\", modelTexturesId); loadlive2d(\"live2d\", `${apiPath}/get/?id=${modelId}-${modelTexturesId}`, null); console.log(\"live2d\", `模型 ${modelId}-${modelTexturesId} 加载完成`); setTimeout(() => { coverPosition(\"80%\"); state = 2; }, 2000); } function loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); fetch(`${apiPath}/rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { loadModel(modelId, result.textures.id); setTimeout(() => { state = 2; coverPosition(\"80%\"); loading = false; }, 1000); }); } function loadOtherModel() { const modelId = localStorage.getItem(\"modelId\"); fetch(`${apiPath}/switch/?id=${modelId}`) .then(response => response.json()) .then(result => { loadModel(result.model.id); }); } function coverPosition(pos) { document.getElementById(\"cover\").style.bottom = pos; } document.getElementById(\"info\").addEventListener(\"click\", () => { fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { alert(\"「\" + result.hitokoto + \"」——\" + result.from); }); }); document.getElementById(\"refresh\").addEventListener(\"click\", () => { if (loading) return; state = 0; coverPosition(\"10%\"); loading = true; setTimeout(loadRandModel, 1000); }); document.getElementById(\"handle\").addEventListener(\"click\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } else if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"focus\", () => { if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"blur\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } }); });","link":"/live2d-widget/demo/login.html"},{"title":"","text":"Live2D 看板娘 / Demo #github svg { transition: all 1s; fill: #222; color: #fff; position: absolute; top: 0; right: 0; border: 0; width: 80px; height: 80px; } #github:hover svg { width: 160px; height: 160px; }","link":"/live2d-widget/demo/demo.html"},{"title":"","text":"import randomSelection from \"./utils.js\"; let messageTimer; function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); const tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } export default showMessage;","link":"/live2d-widget/src/message.js"},{"title":"","text":"import Model from \"./model.js\"; import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; import tools from \"./tools.js\"; function loadWidget(config) { const model = new Model(config); localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); (function registerTools() { tools[\"switch-model\"].callback = () => model.loadOtherModel(); tools[\"switch-texture\"].callback = () => model.loadRandModel(); if (!Array.isArray(config.tools)) { config.tools = Object.keys(tools); } for (let tool of config.tools) { if (tools[tool]) { const { icon, callback } = tools[tool]; document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\", `${icon}`); document.getElementById(`waifu-tool-${tool}`).addEventListener(\"click\", callback); } } })(); function welcomeMessage(time) { if (location.pathname === \"/\") { // 如果是主页 for (let { hour, text } of time) { const now = new Date(), after = hour.split(\"-\")[0], before = hour.split(\"-\")[1] || after; if (after userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(messageArray, 6000, 9); }, 20000); } }, 1000); showMessage(welcomeMessage(result.time), 7000, 11); window.addEventListener(\"mouseover\", event => { for (let { selector, text } of result.mouseover) { if (!event.target.closest(selector)) continue; if (lastHoverElement === selector) return; lastHoverElement = selector; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); window.addEventListener(\"click\", event => { for (let { selector, text } of result.click) { if (!event.target.closest(selector)) continue; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); result.seasons.forEach(({ date, text }) => { const now = new Date(), after = date.split(\"-\")[0], before = date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] { if (!document.hidden) showMessage(result.message.visibilitychange, 6000, 9); }); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 1; // 模型 ID modelTexturesId = 53; // 材质 ID } model.loadModel(modelId, modelTexturesId); fetch(config.waifuPath) .then(response => response.json()) .then(registerEventListener); })(); } function initWidget(config, apiPath) { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); const toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } } export default initWidget;","link":"/live2d-widget/src/index.js"},{"title":"","text":"import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; class Model { constructor(config) { let { apiPath, cdnPath } = config; let useCDN = false; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } else if (typeof apiPath === \"string\") { if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; } else { throw \"Invalid initWidget argument!\"; } this.useCDN = useCDN; this.apiPath = apiPath; this.cdnPath = cdnPath; } async loadModelList() { const response = await fetch(`${this.cdnPath}model_list.json`); this.modelList = await response.json(); } async loadModel(modelId, modelTexturesId, message) { localStorage.setItem(\"modelId\", modelId); localStorage.setItem(\"modelTexturesId\", modelTexturesId); showMessage(message, 4000, 10); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); } else { loadlive2d(\"live2d\", `${this.apiPath}get/?id=${modelId}-${modelTexturesId}`); console.log(`Live2D 模型 ${modelId}-${modelTexturesId} 加载完成`); } } async loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); showMessage(\"我的新衣服好看嘛？\", 4000, 10); } else { // 可选 \"rand\"(随机), \"switch\"(顺序) fetch(`${this.apiPath}rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { if (result.textures.id === 1 && (modelTexturesId === 1 || modelTexturesId === 0)) showMessage(\"我还没有其他衣服呢！\", 4000, 10); else this.loadModel(modelId, result.textures.id, \"我的新衣服好看嘛？\"); }); } } async loadOtherModel() { let modelId = localStorage.getItem(\"modelId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const index = (++modelId >= this.modelList.models.length) ? 0 : modelId; this.loadModel(index, 0, this.modelList.messages[index]); } else { fetch(`${this.apiPath}switch/?id=${modelId}`) .then(response => response.json()) .then(result => { this.loadModel(result.model.id, 0, result.model.message); }); } } } export default Model;","link":"/live2d-widget/src/model.js"},{"title":"","text":"import fa_comment from \"@fortawesome/fontawesome-free/svgs/solid/comment.svg\"; import fa_paper_plane from \"@fortawesome/fontawesome-free/svgs/solid/paper-plane.svg\"; import fa_user_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-user.svg\"; import fa_street_view from \"@fortawesome/fontawesome-free/svgs/solid/street-view.svg\"; import fa_camera_retro from \"@fortawesome/fontawesome-free/svgs/solid/camera-retro.svg\"; import fa_info_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-info.svg\"; import fa_xmark from \"@fortawesome/fontawesome-free/svgs/solid/xmark.svg\"; import showMessage from \"./message.js\"; function showHitokoto() { // 增加 hitokoto.cn 的 API fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { const text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } const tools = { \"hitokoto\": { icon: fa_comment, callback: showHitokoto }, \"asteroids\": { icon: fa_paper_plane, callback: () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { const script = document.createElement(\"script\"); script.src = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\"; document.head.appendChild(script); } } }, \"switch-model\": { icon: fa_user_circle, callback: () => {} }, \"switch-texture\": { icon: fa_street_view, callback: () => {} }, \"photo\": { icon: fa_camera_retro, callback: () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; } }, \"info\": { icon: fa_info_circle, callback: () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); } }, \"quit\": { icon: fa_xmark, callback: () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.bottom = \"-500px\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); } } }; export default tools;","link":"/live2d-widget/src/tools.js"},{"title":"","text":"function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } export default randomSelection;","link":"/live2d-widget/src/utils.js"},{"title":"","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t","link":"/live2d-widget/live2d.min.js"},{"title":"","text":"import initWidget from \"./index.js\"; window.initWidget = initWidget;","link":"/live2d-widget/src/waifu-tips.js"}]}